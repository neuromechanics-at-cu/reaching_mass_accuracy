---
title: "Analyses for *Disentangling the effects of metabolic cost and accuracy on movement vigor*"
author: "Garrick W. Bruening, Shruthi Sukumar, Robert J. Courter, Megan K. O'Brien, Alaa A. Ahmed"
output:
  bookdown::html_document2:
    toc: true
  bookdown::pdf_document2: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r setup, include=FALSE}
#====================== SETUP ==============================
# Load packages
pacman::p_load(ggplot2, ggthemes, lmtest, tidyr, multcomp,
               lme4, nlstools, knitr, RColorBrewer, wesanderson,
               extrafont, cowplot, latex2exp, R.matlab, boot, 
               viridis, dplyr, moments, ggridges)
# library(ggplot2)
# library(ggthemes)
# library(lmtest)
# library(tidyr)
# library(multcomp)
# library(lme4)
# library(nlstools)
# library(knitr)
# library("RColorBrewer")
# library(wesanderson)
# library(extrafont)
# library(cowplot)
# library(latex2exp)
# library('R.matlab')
# library(boot)
# library(viridis)
# library(dplyr)
# library(moments)
# library(ggridges)

#====================== Load Fonts
# font_import()
loadfonts(device='win')
windowsFonts(Times=windowsFont("TT Times New Roman"))
extrafont::loadfonts()

# custom ggplot theme
# theme_set(theme_cowplot(font_size=12,font_family = "Times"))
# theme_set(theme_gray(base_family = "Times"))
theme_set(theme_classic()+
            theme(axis.text         = element_text(color='black'),
                  axis.ticks        = element_line(color='black'),
                  legend.text       = element_text(size=15),
                  legend.text.align = 0,
                  legend.position   = 'right',
                  plot.title        = element_text(hjust = 0.5),
                  axis.line         = element_line(color='black')))
# theme_set(theme_cowplot())
```


```{r, echo=FALSE, include=FALSE}
#====================== LOAD DATA ==============================
# Set the directory to save the graphs
save_plots = 0 # set this to 1 to save plots
met_plots_dir <- paste('/GRAPHS/Metabolics/',sep='')
pref_plots_dir <- paste('/GRAPHS/Preferred',sep='')

prefdata <-read.csv('DATA/2018Data-UnorderednoFML.csv') # Experiment 2a
pilotdata <- read.csv('DATA/Pilot_Data-UnorderednoFML.csv') # Experiment 2b data
smalltdata <- read.csv('DATA/DataArcT-UnorderednoFML.csv') # Experiment 2c data

metdata<-read.csv('DATA/Met_data_erik_test.csv') # Kinematics for metabolics data
mpdata <- read.csv('DATA/met_power_data.csv') # Metabolic Power data
mpdata_rest <- readMat('DATA/baselinemetabolics.mat')$baseline # Resting metabolic rate

eff_masses_pref <- read.csv('DATA/eff_masses_pref.csv',header=0) # Effective masses for 2a
eff_masses_meta <- read.csv('DATA/eff_masses_meta.csv',header=0) # Effective masses for metabolic data

react_sim <-read.csv('DATA/react_sim.csv') # get act from 0 lbs, apply to 3,5,8 lbs. Use method 3. 
torque2_data <- read.csv('DATA/sum_torque2_only.csv') # Torque squared from metabolic data 
torque2_mj_data <- read.csv('DATA/sum_torque2_scscript.csv') # Torque squared from minimum jerk.

# Loading Resample data. Pref = 2a, Smallt = 2b, Pilot = 2c
resample_data_pref_abs = R.matlab::readMat('DATA/Resample_data_pref_abs_wait4mvt.mat')
resample_data_pref_perc = R.matlab::readMat('DATA/Resample_data_perc.mat')
resample_data_pilot_abs = R.matlab::readMat('DATA/Resample_data_pilot_abs_wait4mvt.mat')
resample_data_smallt_abs = R.matlab::readMat('DATA/Resample_data_smallt_abs_wait4mvt.mat')

# ===================== Add things =================================================
# This section adds many of the reaction time metrics from the indexs (idx)
# It also relabels peak velocity towards the target to radial velocity.
pilotdata$reacttoback <- (pilotdata$idxmoveback - pilotdata$idxonset)*.005
pilotdata$reaction_tanv <- .005*pilotdata$reaction_tanv
pilotdata$movedur <- pilotdata$reacttoback
pilotdata$peakvel_target <- pilotdata$peakvel_radv

prefdata$success = abs(prefdata$miss_dist)<.014
smalltdata$success = abs(smalltdata$maxex)<.11 & abs(smalltdata$missangle)<7

prefdata$reaction_tanv <- .005*prefdata$reaction_tanv
smalltdata$reaction_tanv <- .005*smalltdata$reaction_tanv

prefdata$reaction_erik <- 0.005*(prefdata$idxonsetErik-prefdata$idxtargetshow)
prefdata$reaction_vthresh <- 0.005*(prefdata$vthres_onset-prefdata$idxtargetshow)
prefdata$reaction_extrap <- 0.005*(prefdata$idxonset_extrap-prefdata$idxtargetshow)

smalltdata$reaction_erik <- 0.005*(smalltdata$idxonsetErik-smalltdata$idxtargetshow)
smalltdata$reaction_vthresh <- 0.005*(smalltdata$vthres_onset-smalltdata$idxtargetshow)
smalltdata$reaction_extrap <- 0.005*(smalltdata$idxonset_extrap-smalltdata$idxtargetshow)

pilotdata$reaction_erik <- 0.005*(pilotdata$idxonsetErik-pilotdata$idxtargetshow)
pilotdata$reaction_vthresh <- 0.005*(pilotdata$vthres_onset-pilotdata$idxtargetshow)
pilotdata$reaction_extrap <- 0.005*(pilotdata$idxonset_extrap-pilotdata$idxtargetshow)

prefdata$peakvel_target   <- prefdata$peakvel_radv
smalltdata$peakvel_target <- smalltdata$peakvel_radv
pilotdata$peakvel_target  <- pilotdata$peakvel_radv

# ===================== Adding exp 2a, 2b, and 2c Eff_mass =======================
# Adding Column for estimated eff_mass to preferred (2a) experiment.
# eff_mass is the average effective mass, eff_mass2 is individual subject effective mass
index <- c(0,3,5,8)
values <- c(2.506,3.959,4.894,6.282)
subjects = c(1,2,3,4,5,6,7,8,9,10,11,12)
prefdata$eff_mass <- values[match(prefdata$condition,index)]
pilotdata$eff_mass <- values[match(pilotdata$condition,index)]
smalltdata$eff_mass <- values[match(smalltdata$condition,index)]

eff_mass = numeric(length(prefdata$movedur))
for (i in 1:length(prefdata$movedur)){
    eff_mass[i] = eff_masses_pref[match(prefdata$condition[i],index),match(prefdata$subj[i],subjects)]
}
prefdata$eff_mass2 <- eff_mass

# ========================== Adding Metabolics Effective Mass =========================================
# Adds effective mass to the metabolic power (mpdata) data and metabolic kinematic data (metdata).
# In mpdata: effmass = Average eff mass. effmass2 = subject specific eff mass.
# In metdata: Both effmass and eff_mass2 are subject specific. eff_mass is the average values.
index <- c(2.47,4.73,6.99,11.50)
values <- c(1,2,3,4)
mpdata$condition <- values[match(mpdata$effmass,index)]

index <- c(2.47,4.73,6.99,11.50)
values <- c(2.44,4.830,7.13,11.69)
mpdata$effmass <- values[match(mpdata$effmass,index)]

# Adding Column for estimated eff_mass to preferred experiment.
index <- unique(mpdata$effmass)
eff_mass = numeric(length(mpdata$subj))
for (i in 1:length(mpdata$subject)){
  eff_mass[i] = eff_masses_meta[match(mpdata$effmass[i],index),match(mpdata$subj[i],subjects)]
}
mpdata$effmass2 <- eff_mass

for (i in 1:length(mpdata$subject)){
  mpdata$metpowerrest[i] = mpdata_rest[mpdata$subject[i],mpdata$condition[i]]
}

# Adding Column for estimated eff_mass to metabolic experiment.
eff_mass = numeric(length(metdata$subj))
for (i in 1:length(metdata$subj)){
    eff_mass[i] = eff_masses_meta[metdata$condition[i],metdata$subj[i]]
}
metdata$eff_mass2 <- eff_mass

index <- c(1,2,3,4)
values <- c(2.44,4.830,7.13,11.69)
subjects = c(1,2,3,4,5,6,7,8)
eff_mass = numeric(length(metdata$subj))
for (i in 1:length(metdata$subj)){
    eff_mass[i] = eff_masses_meta[match(metdata$condition[i],index),match(metdata$subj[i],subjects)]
}
metdata$effmass = metdata$eff_mass

# Add Average effective mass
index <- c(1,2,3,4)
values <- c(2.44,4.830,7.13,11.69)
metdata$eff_mass <- values[match(metdata$condition,index)]

#============================ Filtering =========================
filtering_func <- function(vars,data,dataname){
  temp_data = filter(data, subj == 1000)
  str = list()
  filt_tab = c()
  var_filts = c(0,0,0,0)
  for (cond in c(0,3,5,8)){
    for (subject in unique(data$subj)){
      subj_data = filter(data, subj == subject, condition == cond)
      var_count = 1
      for (var in vars){
        eval(parse(text = paste('subj_data$var = subj_data$',var,sep='')))
        subj_data_len = length(subj_data$subj)
        inter_quart_range = IQR(subj_data$var)
        # high_point = median(subj_data$var)+1.58*inter_quart_range
        # low_point  = median(subj_data$var)-1.58*inter_quart_range
        
        high_point = median(subj_data$var)+100*inter_quart_range
        low_point  = median(subj_data$var)-100*inter_quart_range
        
        # outliers = boxplot.stats(filter(subj_data, condition == cond)$var)$out
        var_filts[var_count] = var_filts[var_count] + (subj_data_len-length(filter(subj_data, var < high_point, var > low_point)$subj))
        
        subj_data = filter(subj_data, var < high_point, var > low_point)
        filt_tab = rbind(filt_tab, c(subject, cond, var, low_point, high_point))
        var_count = var_count + 1
      }
      # subj_data = filter(subj_data, var < high_point, var > low_point)[,-length(colnames(subj_data))]
      temp_data = rbind(temp_data,subj_data[,-length(colnames(subj_data))])
    }
  }
  output = list('data' = temp_data, 'filt_data' = filt_tab)
  return(output)
}

# Check the filtering, because the filtering also reorders the mass levels, which
# is required for later. Could probably reorder them somehow, but this is how it
# is right now. This doesn't actually filter anything out.
pref_orig_len = length(filter(prefdata,odd_trial==1)$subj)
prefdata <- filter(prefdata,odd_trial==1, reaction_tanv > .05) # Filter to only odd trials and reasonable reaction times
temp_pref <- filtering_func(c('movedur','reaction_tanv','reaction_tanvel','miss_dist'),prefdata,'prefdata')$data
prefdata <- temp_pref

# pilotdata <- filter(pilotdata,reacttoback<3.0,reacttoback>.25,idxonset1<100)
pilotdata <- filter(pilotdata,trialtot>200, reaction_tanv > .05)
pilot_orig_len = length(pilotdata$subj)
pilotdata$miss_dist <- pilotdata$maxex
pilotdata <- filtering_func(c('movedur','reaction_tanv','reaction_tanvel','miss_dist'),pilotdata,'pilotdata')$data
# pilotdata <- filter(pilotdata,maxex<.20)

smallt_orig_len = length(smalltdata$subj)
smalltdata <- filtering_func(c('movedur','reaction_tanv','reaction_tanvel'),smalltdata,'smalltdata')$data
smalltdata = filter(smalltdata, reaction_tanv > .05)
# smalltdata <- filter(pilotdata,max)

# ========================== Factoring ================================================
# Changes some variables to factor for use later.

prefdata_factor <- prefdata
prefdata_factor$eff_mass <- as.factor(prefdata_factor$eff_mass)
prefdata_factor$condition <- as.factor(prefdata_factor$condition)
prefdata_factor$targetnum <- as.factor(prefdata_factor$targetnum)

smalltdata_factor <- smalltdata
smalltdata_factor$eff_mass <- as.factor(smalltdata_factor$eff_mass)
smalltdata_factor$condition <- as.factor(smalltdata_factor$condition)
smalltdata_factor$targetnum <- as.factor(smalltdata_factor$targetnum)

pilotdata_factor <- pilotdata
pilotdata_factor$eff_mass <- as.factor(pilotdata_factor$eff_mass)
pilotdata_factor$condition <- as.factor(pilotdata_factor$condition)
pilotdata_factor$targetnum <- as.factor(pilotdata_factor$targetnum)

# ========================== Filtering Metabolics Data ================================================
# Filter the metabolic data by common metrics, and odd trials.
met_orig_length = length(metdata$movedur)

metdata = filter(metdata,odd_trial==1)
met_length = length(metdata$movedur)
# Filter by miss distance, movement duration, maximum excursion, reaction time, and miss angle.
metdata <- filter(metdata,miss_dist<.1,movedur>.2,movedur<2,maxex<.2,reaction_tanv<.5,abs(missangle)<50)

metdata = cbind(metdata,metdata$trial%%2==0)
colnames(metdata) = append(colnames(metdata)[1:length(colnames(metdata))-1],'outward')
metdata = filter(metdata,odd_trial==1)

# ========================== Adding normalized ================================================
# Add normalized metrics to experiment 2a, 2b, and 2c for specific metrics.
add_norm <- function(data, variables){
  for (vari in variables){
    eval(parse(text = paste('zero_vals = aggregate(',vari,'~ subj + condition,data,mean)',sep = '')))
    zero_vals = zero_vals[zero_vals$condition == '0',]
    for (k in 1:length(data$subj)){
      data[k,paste(vari,'_norm',sep='')] = data[k,vari]/zero_vals[zero_vals$subj == data[k,'subj'],vari]
    }
  }
  return(data)
}

prefdata <- add_norm(prefdata,c('movedur','peakvel_target','reaction_tanv','miss_dist'))
smalltdata <- add_norm(smalltdata,c('movedur','peakvel_target','reaction_tanv','miss_dist'))
pilotdata <- add_norm(pilotdata,c('movedur','peakvel_target','reaction_tanv','miss_dist'))

# ========================== Adding Variance Metrics =========================================
# Add metrics for standard deviation as the experiment progresses for a window of 20 trials.
# This is to check that people are consistent throughout the experiment.
stdev_trial_plot <- function(data, variable, add_or_plot){
  if (add_or_plot=='add'){
    max_trial = max(data$trial)
    
    for (k in 11:(length(data$subj)-10)){
      if (var(data[(k-10):(k+10),'eff_mass'])==0){
        if ('speed' %in% colnames(data) && var(data[(k-10):(k+10),'speed'])==0){
          data[k,paste(variable,'_sd',sep='')] = sd(data[(k-10):(k+10),variable])
        } else {
          data[k,paste(variable,'_sd',sep='')] = sd(data[(k-10):(k+10),variable])
        }
      } else {
        data[k,paste(variable,'_sd',sep='')] = NaN
      }
    }
    
    return(data)
  }
  if (add_or_plot=='plot'){
    eval(parse(text = paste('data$yvar = data$',variable,'_sd',sep='')))
    g<-ggplot(data=data)+
      geom_smooth(aes(x=trial,
                      y=yvar,
                      color = factor(subj)))+
      # theme_classic()
      labs(x = 'Trial Number', y = paste('StDev (',variable,')',sep=''),color = 'Subject')
    
    if ('speed' %in% colnames(data)){
      g<-g+facet_grid(rows = vars(eff_mass),cols = vars(speed))
    } else {
      g<-g+facet_grid(rows = vars(eff_mass))
    }
    return(g)
  }
}

average_trial_plot <- function(data, variable, add_or_plot){
  if (add_or_plot=='add'){
    max_trial = max(data$trial)
    
    for (k in 11:(length(data$subj)-10)){
      if (var(data[(k-10):(k+10),'eff_mass'])==0){
        if ('speed' %in% colnames(data) && var(data[(k-10):(k+10),'speed'])==0){
          data[k,paste(variable,'_avg',sep='')] = mean(data[(k-10):(k+10),variable])
        } else {
          data[k,paste(variable,'_avg',sep='')] = mean(data[(k-10):(k+10),variable])
        }
      } else {
        data[k,paste(variable,'_avg',sep='')] = NaN
      }
    }
    
    return(data)
  }
  if (add_or_plot=='plot'){
    eval(parse(text = paste('data$yvar = data$',variable,'_avg',sep='')))
    g<-ggplot(data=data)+
      geom_smooth(aes(x=trial,
                      y=yvar,
                      color = factor(subj)))+
      # theme_classic()
      labs(x = 'Trial Number', y = paste('Average (',variable,')',sep=''),color = 'Subject')
    
    if ('speed' %in% colnames(data)){
      g<-g+facet_grid(rows = vars(eff_mass),cols = vars(speed))
    } else {
      g<-g+facet_grid(rows = vars(eff_mass))
    }
    return(g)
  }
}

for (variable in c('miss_dist','miss_rad','missangle')){
  prefdata <- stdev_trial_plot(prefdata,variable,'add')
  smalltdata <- stdev_trial_plot(smalltdata,variable,'add')
  pilotdata <- stdev_trial_plot(pilotdata,variable,'add')
  metdata <- stdev_trial_plot(metdata,variable,'add')

  prefdata <- average_trial_plot(prefdata,variable,'add')
  smalltdata <- average_trial_plot(smalltdata,variable,'add')
  pilotdata <- average_trial_plot(pilotdata,variable,'add')
  metdata <- average_trial_plot(metdata,variable,'add')
}

# =========================== Generate the df for 3 experiments ===================
# This makes the data frame for use in stats later.
# This data frame is then saved as prefpilot.
prefdata$exp <- 'pref'
pilotdata$exp <- 'pilot'
smalltdata$exp <- 'smallt'
smalltdata$subj <- smalltdata$subj+12
pilotdata$subj <- pilotdata$subj+12+12

allexp_plot <- function(vars,data,...){
  str = paste('a=as.data.frame(cbind(',data,'$subj,',data,'$eff_mass,',data,'$condition,',data,'$exp',sep='')
  for (var in vars){
    # print(var)
    str = paste(str,',',data,'$',var,sep='')
  }
  str = paste(str,'))',sep='')
  a = eval(parse(text=str))
  colnames(a) = c('subj','eff_mass','condition','exp',vars)
  a$eff_mass = as.numeric(as.character(a$eff_mass))
  a$condition = as.numeric(as.character(a$condition))
  for (var in vars){
    eval(parse(text = paste('a$',var,' = as.numeric(as.character(a$',var,'))',sep='')))
  }
  return(a)
}

# These are all the variables that we want in the new data frame.
vars = c('targetnum','movedur','movedur_norm',
         'peakvel_target','peakvel_target_norm','idxpeakv',
         'miss_dist','miss_dist_norm',
         'reaction_tanv','reaction_tanv_norm','reaction_tanvel',
         'pathltar','missangle','miss_rad','trial',
         'miss_dist_avg','miss_dist_sd',
         'missangle_avg','missangle_sd',
         'miss_rad_avg','miss_rad_sd')
a=allexp_plot(vars,'prefdata')
b=allexp_plot(vars,'pilotdata')
c=allexp_plot(vars,'smalltdata')

b$peakvel_target = pilotdata$peakvel_radv

prefpilot=data.frame(rbind(a,b,c))
prefpilot$exp <- factor(prefpilot$exp, levels = c('pref','smallt','pilot'))
prefpilot = filter(prefpilot,movedur<1.75)
prefpilot$subj <- as.numeric(prefpilot$subj)

# ===================== Setting plots sizes ===================
# This just sets plotting sizes so that across the different plots hopefully
# the sizes would be the same.
# Pref stuff
vplot_point_size = 0
vplot_avg_point_size = 3
v_plot_line_size = 1
v_plot_err_bar_size = 1

vel_plot_line_size = 1
vel_plot_point_size = 3

err_plot_point_size = 1
err_plot_line_size = 1

react_plot_point_size = 1

# Met stuff
met_point_size = 2.5
met_costmin_size = met_point_size-2
met_line_size = .5

met_errorbar_size = .25

# ===================== Functions ===================
# This is a long section, that just has a bunch of functions.
# I'll try to describe what each of these functions accomplish.

vplot <- function(variable,data,...){
  
  # Violin Plotting Function
  # This function takes in the dataframe ('data'), and the variable name ('variable')
  # as a string to create a violin plot. 
  # Example use: vplot('movedur',prefdata)
    
  exp = list(...)
  string = paste('a = aggregate(',variable,' ~ subj + eff_mass,data,mean)
                  b = aggregate(',variable,' ~ subj + eff_mass,data,sd)
                  c = cbind(a,b$',variable,')
                  colnames(c) = c(\'subj\',\'eff_mass\',\'dep_var\',\'dep_var_sd\')
                  
                  d = aggregate(',variable,' ~ eff_mass,data,mean)
                  e = aggregate(',variable,' ~ eff_mass,a,sd)
                  e = cbind(e$eff_mass,d$',variable,',e$',variable,')
                  colnames(e) = c(\'eff_mass\',\'dep_var_avg\',\'dep_var_sd\')'
                 )
  eval(parse(text=string))
  
  string = paste('g<-ggplot()+
                     geom_violin(data=data,aes(x=eff_mass,y=',variable,',fill = factor(eff_mass)))',sep='')
  eval(parse(text = string))
  g<-g+
    scale_x_continuous(breaks=c(sort(unique(c$eff_mass))))+
    scale_fill_manual(values=mass_colors)+
    geom_point(data=data.frame(c),
              aes(x=eff_mass,
                  y=dep_var),
              size=vplot_point_size)+
    geom_line(data=data.frame(e),
             aes(eff_mass,
                 y=dep_var_avg),
             size=v_plot_line_size)+
    geom_point(data=data.frame(e),
              aes(eff_mass,
                  y=dep_var_avg),
              size=vplot_avg_point_size)+
    geom_errorbar(data=data.frame(e),
                 aes(x    = eff_mass,
                     y    = dep_var_avg, 
                     ymin = dep_var_avg-dep_var_sd,
                     ymax = dep_var_avg+dep_var_sd),
                 size=v_plot_err_bar_size,
                 width = 0) +
    theme(text              = element_text(color='black'),
          axis.text         = element_text(color='black'),
          axis.ticks        = element_line(color='black'),
          plot.title        = element_text(hjust = 0.5),
          axis.line         = element_line(color='black'))+
    labs(x = 'Effective Mass (kg)', color = 'Effective\nMass (kg)', fill = 'Effective\nMass (kg)')+
    geom_hline(yintercept=e[1,2],linetype='dashed',size=.5)
    
  
  # string = paste('ggplot()+
  #                    geom_violin(data=data,aes(x=eff_mass,y=',variable,',fill = factor(eff_mass)))+
  #                    scale_x_continuous(breaks=c(sort(unique(data$eff_mass))))+
  #                    scale_fill_manual(values=mass_colors)+
  #                    geom_point(data=aggregate(',variable,'~subj+eff_mass,data,mean),aes(x=eff_mass,y=',variable,'),size=vplot_point_size)+
  #                    # geom_line(data=c,aes(x=eff_mass,y=dep_var,group=factor(subj)))+
  #                    geom_line(data=aggregate(',variable,'~eff_mass,data,mean),aes(eff_mass,y=',variable,'),size=v_plot_line_size)+
  #                    geom_point(data=aggregate(',variable,'~eff_mass,data,mean),aes(eff_mass,y=',variable,'),size=vplot_avg_point_size)+
  #                    geom_errorbar(data=data.frame(e),aes(x= eff_mass,
  #                                                         y=movedur_avg, 
  #                                                         ymin = movedur_avg-movedur_sd,
  #                                                         ymax=movedur_avg+movedur_sd),
  #                                                     size=v_plot_err_bar_size,
  #                                                     width = 0) +
  #                    theme(text              = element_text(color=\'black\'),
  #                          axis.text         = element_text(color=\'black\'),
  #                          axis.ticks        = element_line(color=\'black\'),
  #                          plot.title        = element_text(hjust = 0.5),
  #                          axis.line         = element_line(color=\'black\'))+
  #                    labs(title=\'',exp,'\')+
  #                    labs(x = \'Effective Mass (kg)\', color = \'Effective\nMass (kg)\')',sep='')
  # eval(parse(text = string))
  
  return(g)
}

avg_plot <- function(variable,data,ylab,shape=21,...){
  
  # This function creates the average plot for a single variable.
  # The average is average of subject averages.
  # The standard error is the SE is standard error of subject means.
  # This is mainly used in plotting the miss variance metrics.
  
  exp = list(...)
  tempdf = eval(parse(text = paste('aggregate(',variable,' ~ subj + eff_mass,data,mean)',sep='')))
  nsubj = max(tempdf$subj)
  string = paste('a = aggregate(',variable,' ~ eff_mass,tempdf,mean)
                  b = aggregate(',variable,' ~ eff_mass,tempdf,sd)
                  c = cbind(a,b$',variable,'/sqrt(nsubj))
                  colnames(c) = c(\'eff_mass\',\'dep_var\',\'dep_var_sd\')',
                 sep = ''
                 )
  eval(parse(text=string))
  
  g<-ggplot()+
    scale_x_continuous(breaks=c(sort(unique(data$eff_mass))))+
    geom_line(data=c,
              aes(x=eff_mass,
                  y=dep_var),
              size=v_plot_line_size)+
    geom_hline(data = c,aes(yintercept = c[1,2]),
               linetype = 'dashed',
               size=.5)+
    geom_errorbar(data=data.frame(c),
                  aes(x    = eff_mass,
                      y    = dep_var, 
                      ymin = dep_var-dep_var_sd,
                      ymax = dep_var+dep_var_sd),
                  size=v_plot_err_bar_size,
                  width = 0)+
    geom_point(data=c,
               aes(x=eff_mass,
                   y=dep_var,
                   fill = factor(eff_mass)),
               color = 'black',
               shape = shape,
               size=vplot_point_size+4)+
    scale_fill_manual(values=mass_colors)+
    # theme_classic()
    theme(text              = element_text(color='black'),
         axis.text         = element_text(color ='black'),
         axis.ticks        = element_line(color ='black'),
         plot.title        = element_text(hjust = 0.5),
         axis.line         = element_line(color ='black'))+
    labs(x = 'Effective Mass (kg)', fill = 'Effective\nMass (kg)')
  if (!missing(ylab)){
    g <- g+labs(y = ylab)
  }
  return(g)
}

avg_plot2 <- function(variable,data,ylab,shape_labs,...){
  # Very similar to the previous function, except it can plot multiple metrics at 
  # once. This is used for the reaction time velocity plots comparing the
  # different algorithms.
  exp = list(...)
  if (length(variable)>1){
    var_count = 1
    var1 = variable[1]
    tempdf = eval(parse(text = paste('aggregate(',var1,' ~ subj + eff_mass,data,mean)',sep='')))
    nsubj = max(tempdf$subj)
    
    string = paste('a = aggregate(',var1,' ~ eff_mass,tempdf,mean)
                    b = aggregate(',var1,' ~ eff_mass,tempdf,sd)
                    c = cbind(a,b$',var1,'/sqrt(nsubj),rep(var_count,4))
                    colnames(c) = c(\'eff_mass\',\'dep_var\',\'dep_var_se\',\'var_num\')',
                   sep = ''
                   )
    eval(parse(text=string))
    
    var_count = 2
    for (var1 in variable[2:length(variable)]){
      tempdf = eval(parse(text = paste('aggregate(',var1,' ~ subj + eff_mass,data,mean)',sep='')))
      nsubj = max(tempdf$subj)
      
      string = paste('a = aggregate(',var1,' ~ eff_mass,tempdf,mean) %>% `colnames<-`(c(\'eff_mass\',\'dep_var\'))
                    b = aggregate(',var1,' ~ eff_mass,tempdf,sd) %>% `colnames<-`(c(\'eff_mass\',\'dep_var_sd\'))')
      eval(parse(text = string))
      string = paste('c = rbind(c,cbind(a, b$dep_var_sd/sqrt(nsubj), rep(var_count,4)) %>% `colnames<-`(c(\'eff_mass\',\'dep_var\',\'dep_var_se\',\'var_num\')))')
      eval(parse(text = string))
      
      var_count = var_count + 1
    }
  } else {
    tempdf = eval(parse(text = paste('aggregate(',var1,' ~ subj + eff_mass,data,mean)',sep='')))
    nsubj = max(tempdf$subj)
    
    string = paste('a = aggregate(',variable,' ~ eff_mass,tempdf,mean)
                    b = aggregate(',variable,' ~ eff_mass,tempdf,sd)
                    c = cbind(a,b$',variable,'/sqrt(nsubj))
                    colnames(c) = c(\'eff_mass\',\'dep_var',1,'\',\'dep_var_se',1,'\')',
                   sep = ''
                   )
    eval(parse(text=string))
  }
  
  g<-ggplot()+
    scale_x_continuous(breaks=c(sort(unique(data$eff_mass))))
    
  for (var_count in 1:length(variable)){
    g <- g+geom_line(data=filter(c,var_count==var_num),
              aes(x=eff_mass,
                  y=dep_var),
              size=v_plot_line_size)
  }
    g<-g+geom_hline(data = c,
               aes(yintercept = c[1,2]),
               linetype = 'dashed',
               size=.5)+
    geom_errorbar(data=data.frame(c),
                  aes(x    = eff_mass,
                      y    = dep_var, 
                      ymin = dep_var-dep_var_se,
                      ymax = dep_var+dep_var_se),
                  size=v_plot_err_bar_size,
                  width = 0)+
    geom_point(data=c,
               aes(x=eff_mass,
                   y=dep_var,
                   color = 'black',
                   shape = factor(var_num)),
               size=vplot_point_size+7.5)+
    geom_point(data=c,
               aes(x=eff_mass,
                   y=dep_var,
                   color = factor(eff_mass),
                   shape = factor(var_num)),
               size=vplot_point_size+6)+
    scale_color_manual(values=c(mass_colors,'black'))+
    # theme_classic()
    theme(text              = element_text(color='black'),
         axis.text         = element_text(color ='black'),
         axis.ticks        = element_line(color ='black'),
         plot.title        = element_text(hjust = 0.5),
         axis.line         = element_line(color ='black'))+
    labs(x = 'Effective Mass (kg)', color = 'Effective\nMass (kg)')
  if (!missing(ylab)){
    g <- g+labs(y = ylab)
  }
  if (!missing(shape_labs)){
    g <- g+scale_shape_manual(values = c(16,17,15,18),labels = shape_labs)+labs(shape = 'Algorithm')
  }
  return(g)
}

all_exp_avg_plot <- function(variable,data1,data2,data3,ylab,...){
  # Plots all three experiments (2a, 2b, 2c) for the metric ('variable').
  # Plots mean of subject means. SE is standard error of subject means.
  exp = list(...)
  c = c()
  
  exps = c('2a','2b','2c')
  tempdf = list()
  for (datasets in c(1,2,3)){
    tempdf[[datasets]] = eval(parse(text = paste('aggregate(',variable,' ~ subj + eff_mass,data',datasets,',mean)',sep='')))
    nsubj = max(tempdf[[datasets]]$subj)
    string = paste('a = aggregate(',variable,' ~ eff_mass,tempdf[[datasets]],mean)
                    b = aggregate(',variable,' ~ eff_mass,tempdf[[datasets]],sd)
                    tempdf[[datasets]] = cbind(a,b$',variable,'/sqrt(nsubj))
                    colnames(tempdf[[datasets]]) = c(\'eff_mass\',\'dep_var\',\'dep_var_sd\')',
                   sep = ''
                   )
    eval(parse(text=string))
    tempdf[[datasets]]$exp = exps[datasets]
  }
  c = rbind(tempdf[[1]],tempdf[[2]],tempdf[[3]])
                
  g<-ggplot()+
    scale_x_continuous(breaks=c(sort(unique(c$eff_mass))))+
    geom_line(data=c,
              aes(x = eff_mass,
                  y = dep_var,
                  group = exp),
              size=v_plot_line_size)+
    geom_hline(aes(yintercept = filter(c,exp=='2a')[1,2]),
               linetype = 'dashed',
               size=.5)+
    geom_hline(aes(yintercept = filter(c,exp=='2b')[1,2]),
               linetype = 'dashed',
               size=.5)+
    geom_hline(aes(yintercept = filter(c,exp=='2c')[1,2]),
               linetype = 'dashed',
               size=.5)+
    geom_errorbar(data=data.frame(c),
                  aes(x    = eff_mass,
                      y    = dep_var, 
                      ymin = dep_var-dep_var_sd,
                      ymax = dep_var+dep_var_sd),
                  size=v_plot_err_bar_size,
                  width = 0)+
    geom_point(data=c,
               aes(x=eff_mass,
                   y=dep_var,
                   fill = factor(eff_mass),
                   shape = factor(exp)),
               size=vplot_point_size+6,
               color = 'black')+
    scale_fill_manual(values=c(mass_colors,'black'))+
    scale_shape_manual(values=c(21,22,24))+
    # theme_classic()
    theme(text              = element_text(color='black'),
          axis.text         = element_text(color ='black'),
          axis.ticks        = element_line(color ='black'),
          plot.title        = element_text(hjust = 0.5),
          axis.line         = element_line(color ='black'))+
    labs(x = 'Effective Mass (kg)',
         shape = 'Experiment')+
    guides(fill='none')
  if (!missing(ylab)){
    g <- g+labs(y = ylab)
  }
  return(g)
}

all_exp_avg_plot_addmass <- function(variable,data1,data2,data3,ylab,...){
  
  # Plots all three experiments (2a, 2b, 2c) for the metric ('variable').
  # Slightly different from previous function, x axis is added mass, not 
  # effective mass.
  # Plots mean of subject means. SE is standard error of subject means.
  
  exp = list(...)
  c = c()
  
  exps = c('2a','2b','2c')
  tempdf = list()
  for (datasets in c(1,2,3)){
    temp_data = eval(parse(text = paste('data',datasets,sep='')))
    tempdf[[datasets]] = eval(parse(text = paste('aggregate(',variable,' ~ subj + condition,data',datasets,',mean)',sep='')))
    nsubj = max(tempdf[[datasets]]$subj)
    string = paste('a = aggregate(',variable,' ~ condition,tempdf[[datasets]],mean)
                    b = aggregate(',variable,' ~ condition,tempdf[[datasets]],sd)
                    tempdf[[datasets]] = cbind(a,b$',variable,'/sqrt(nsubj))
                    colnames(tempdf[[datasets]]) = c(\'condition\',\'dep_var\',\'dep_var_sd\')',
                   sep = ''
    )
    eval(parse(text=string))
    tempdf[[datasets]]$exp = exps[datasets]
    # tempdf[[datasets]]$dep_var_sd = sse_prop(temp_data,variable)
  }
  c = rbind(tempdf[[1]],tempdf[[2]],tempdf[[3]])
  
  g<-ggplot()+
    scale_x_continuous(labels = round(sort(unique(c$condition)/2.2),3),
                       breaks=c(sort(unique(c$condition))))+
    geom_line(data=c,
              aes(x = condition,
                  y = dep_var,
                  group = exp,
                  color = exp),
              size=v_plot_line_size+1)+
    geom_hline(aes(yintercept = filter(c,exp=='2a')[1,2]),
               linetype = 'dashed',
               size=.5)+
    geom_hline(aes(yintercept = filter(c,exp=='2b')[1,2]),
               linetype = 'dashed',
               size=.5)+
    geom_hline(aes(yintercept = filter(c,exp=='2c')[1,2]),
               linetype = 'dashed',
               size=.5)+
    geom_errorbar(data=data.frame(c),
                  aes(x    = condition,
                      y    = dep_var, 
                      ymin = dep_var-dep_var_sd,
                      ymax = dep_var+dep_var_sd),
                  size=v_plot_err_bar_size,
                  width = 0)+
    geom_point(data=c,
               aes(x=condition,
                   y=dep_var,
                   fill = factor(condition)),
               shape = 21,#factor(exp)),
               size = vplot_point_size+3,
               color = 'black')+
    scale_fill_manual(values=c(mass_colors,'black'))+
    # scale_shape_manual(values=c(21,22,24))+
    # scale_color_manual(values = c(gg_color_hue(3)[1],
    #                               gg_color_hue(3)[3],
    #                               gg_color_hue(3)[2]))+
    scale_color_manual(values = c('#535263','#919093','#bcbcbc'))+
    # theme_classic()
    theme(text              = element_text(color='black'),
          axis.text         = element_text(color ='black'),
          axis.ticks        = element_line(color ='black'),
          plot.title        = element_text(hjust = 0.5),
          axis.line         = element_line(color ='black'))+
    labs(x = 'Added mass (kg)',
         shape = 'Experiment',
         color = 'Experiment')+
    guides(fill='none')
  if (!missing(ylab)){
    g <- g+labs(y = ylab)
  }
  return(g)
}

bytarget_plot <- function(variable,data1,data2,data3,ylab,...){
  # Similar to the previous functions, except splits things by target.
  # Means are mean of subject means. SE are SE of subject means.
  exp = list(...)
  c = c()
  
  exps = c('2a','2b','2c')
  tempdf = list()
  for (datasets in c(1,2,3)){
    tempdf[[datasets]] = eval(parse(text = paste('aggregate(',variable,' ~ subj + condition + targetnum,data',datasets,',mean)',sep='')))
    nsubj = max(tempdf[[datasets]]$subj)
    string = paste('a = aggregate(',variable,' ~ condition + targetnum,tempdf[[datasets]],mean)
                    b = aggregate(',variable,' ~ condition + targetnum,tempdf[[datasets]],sd)
                    tempdf[[datasets]] = cbind(a,b$',variable,'/sqrt(nsubj))
                    colnames(tempdf[[datasets]]) = c(\'condition\',\'dep_var\',\'target\',\'dep_var_sd\')',
                   sep = ''
    )
    eval(parse(text=string))
    tempdf[[datasets]]$exp = exps[datasets]
  }
  c = rbind(tempdf[[1]],tempdf[[2]],tempdf[[3]])
  
  g<-ggplot()+
    scale_x_continuous(labels = round(sort(unique(c$condition)/2.2),3),
                       breaks=c(sort(unique(c$condition))))+
    geom_line(data=c,
              aes(x = condition,
                  y = dep_var,
                  group = exp),
              size=v_plot_line_size)+
    geom_hline(aes(yintercept = filter(c,exp=='2a')[1,2]),
               linetype = 'dashed',
               size=.5)+
    geom_hline(aes(yintercept = filter(c,exp=='2b')[1,2]),
               linetype = 'dashed',
               size=.5)+
    geom_hline(aes(yintercept = filter(c,exp=='2c')[1,2]),
               linetype = 'dashed',
               size=.5)+
    geom_errorbar(data=data.frame(c),
                  aes(x    = condition,
                      y    = dep_var, 
                      ymin = dep_var-dep_var_sd,
                      ymax = dep_var+dep_var_sd),
                  size=v_plot_err_bar_size,
                  width = 0)+
    geom_point(data=c,
               aes(x=condition,
                   y=dep_var,
                   fill = factor(condition),
                   shape = factor(exp)),
               size=vplot_point_size+6,
               color = 'black')+
    scale_fill_manual(values=c(mass_colors,'black'))+
    scale_shape_manual(values=c(21,22,24))+
    # theme_classic()
    theme(text              = element_text(color='black'),
          axis.text         = element_text(color ='black'),
          axis.ticks        = element_line(color ='black'),
          plot.title        = element_text(hjust = 0.5),
          axis.line         = element_line(color ='black'))+
    labs(x = 'Added mass (kg)',
         shape = 'Experiment')+
    guides(fill='none')
  if (!missing(ylab)){
    g <- g+labs(y = ylab)
  }
  return(g)
}

# Function to plot a variable by target
bytarget_plot <- function(var, data){
  # Target plot function for a single experiment
  data$condition = as.factor(data$condition)
  data <- summarySE(data, measurevar=var, groupvars=c("targetnum","condition"))
  bytarget_plot<-ggplot(data,
            aes(x=targetnum,
                y=movedur,
                color= condition,
                group = condition))+
    geom_errorbar(aes(ymin=movedur-se,
                      ymax=movedur+se),
                  width=.2,
                  size = 1)+
    geom_line(size = 1)+
    geom_point(size = 4)+
    scale_color_manual(values = mass_colors)
  return(bytarget_plot)
}

#Another stat summary function
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
                      conf.interval=.95, .drop=TRUE) {
  # 'Gives count, mean, standard deviation, standard error of the mean, and confidence interval (default 95%).'
    library(plyr)

    # New version of length which can handle NA's: if na.rm==T, don't count them
    length2 <- function (x, na.rm=FALSE) {
        if (na.rm) sum(!is.na(x))
        else       length(x)
    }

    # This does the summary. For each group's data frame, return a vector with
    # N, mean, and sd
    datac <- ddply(data, groupvars, .drop=.drop,
      .fun = function(xx, col) {
        c(N    = length2(xx[[col]], na.rm=na.rm),
          mean = mean   (xx[[col]], na.rm=na.rm),
          sd   = sd     (xx[[col]], na.rm=na.rm)
        )
      },
      measurevar
    )

    # Rename the "mean" column    
    datac <- rename(datac, c("mean" = measurevar))

    datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean

    # Confidence interval multiplier for standard error
    # Calculate t-statistic for confidence interval: 
    # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
    ciMult <- qt(conf.interval/2 + .5, datac$N-1)
    datac$ci <- datac$se * ciMult

    return(datac)
}

data_summary <- function(x) {
  # Function to produce summary statistics (mean and +/- sd)
   m <- mean(x)
   ymin <- m-sd(x)
   ymax <- m+sd(x)
   return(c(y=m,ymin=ymin,ymax=ymax))
}

p_fisch_func <- function(var,data){
  #Fischer Method Function
  # Does fischer method for statistical test and returns pvalue.
  p_fisch = c()
  chi_fisch = 0
  for (subjnum in unique(data$subj)){
    str = paste('p_fisch[subjnum] = anova(lm(',var,'~ targetnum + eff_mass2 + targetnum*eff_mass2,
             data=filter(data,subj == subjnum)))$`Pr(>F)`[2]',sep='')
    eval(parse(text = str))
    chi_fisch = chi_fisch + log(p_fisch[subjnum])
  }
  chi_fisch = -2*chi_fisch
  return(pchisq(chi_fisch, df=subjnum*2, lower.tail=FALSE))
}

gg_color_hue <- function(n) {
  # Function to sample colors from ggplot
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}

number_ticks <- function(n) {function(limits) pretty(limits, n)}

# Set some plots to fix. 
# Changes some colors so that its black not gray.
plots_to_fix = c('MPGross',
                 'MCGross',
                 'miss_dist_grouped_met',
                 'miss_anglevar_grouped_met',
                 'radial_endpointvar_grouped_met',
                 'reaction_bydur_met')
fix_plot_theme <- function(plot_to_fix,font){
    string = paste(plot_to_fix,'<-',plot_to_fix,'+
                   # theme_classic()
                   theme(text              = element_text(family=',font,',color=\'black\'),
                   axis.text         = element_text(color=\'black\'),
                   axis.ticks        = element_line(color=\'black\'),
                   plot.title        = element_text(hjust = 0.5),
                   axis.line         = element_line(color=\'black\'),
                   legend.position   = \'none\')',sep = '')
    eval(parse(text = string))
    return(plot_to_fix)
}


# String Generating function
# These are used to explain that linear mixed model outputs.
# Takes in the dataset, the variable, and a label.
mass_exp_int_stringgen <- function(dataset, test_var, label){
  dataset$test_var = dataset[[test_var]]
  if ('targetnum' %in% colnames(dataset)){
    mass_exp_int_test = cftest(lmer(test_var ~ factor(targetnum) + eff_mass*factor(exp) +  (1|subj),data=dataset))
  } else {
    mass_exp_int_test = cftest(lmer(test_var ~ eff_mass*factor(exp) +  (1|subj),data=dataset))
  }
  
  if (mass_exp_int_test$test$pvalues[['eff_mass']] < 0.05){
    main_mass = paste('There is an overall effect of mass on ',label,' (slope = ',
                      formatC(mass_exp_int_test$coef[['eff_mass']],format = 'e',digits = 3),
                      ', p = ', formatC(mass_exp_int_test$test$pvalues[['eff_mass']],format = 'e',digits = 3),').', sep = '')
  } else {
    main_mass = paste('There is NOT an overall effect of mass on ',label,' (p = ',
                      formatC(mass_exp_int_test$test$pvalues[['eff_mass']],format = 'e',digits = 3),').',
                      sep = '')
  }
  
  # Main effects
  
  # 2b
  if (mass_exp_int_test$test$pvalues[['factor(exp)smallt']] < 0.05){
    if (mass_exp_int_test$coef[['factor(exp)smallt']] > 0){
      main_2b = paste('Experiment 2b ',label,' is significantly greater than 2a (slope = ',
                        formatC(mass_exp_int_test$coef[['factor(exp)smallt']],format = 'e',digits = 3),
                        ', p = ', formatC(mass_exp_int_test$test$pvalues[['factor(exp)smallt']],format = 'e',digits = 3),').', sep = '')
    } else {
      main_2b = paste('Experiment 2b ',label,' is significantly lower than 2a (slope = ',
                        formatC(mass_exp_int_test$coef[['factor(exp)smallt']],format = 'e',digits = 3),
                        ', p = ', formatC(mass_exp_int_test$test$pvalues[['factor(exp)smallt']],format = 'e',digits = 3),').', sep = '')
    }
  } else {
    main_2b = paste('Experiment 2b ',label,' is not different from 2a (p = ',
                    formatC(mass_exp_int_test$test$pvalues[['factor(exp)smallt']],format = 'e',digits = 3),').',
                    sep='')
  }
  
  # 2c
  if (mass_exp_int_test$test$pvalues[['factor(exp)pilot']] < 0.05){
    if (mass_exp_int_test$coef[['factor(exp)pilot']] > 0){
      main_2c = paste('Experiment 2c ',label,' is significantly greater than 2a (slope = ',
                        formatC(mass_exp_int_test$coef[['factor(exp)pilot']],format = 'e',digits = 3),
                        ', p = ', formatC(mass_exp_int_test$test$pvalues[['factor(exp)pilot']],format = 'e',digits = 3),').', sep = '')
    } else {
      main_2c = paste('Experiment 2c ',label,' is significantly lower than 2a (slope = ',
                        formatC(mass_exp_int_test$coef[['factor(exp)pilot']],format = 'e',digits = 3),
                        ', p = ', formatC(mass_exp_int_test$test$pvalues[['factor(exp)pilot']],format = 'e',digits = 3),').', sep = '')
    } 
  } else {
    main_2c = paste('Experiment 2c ',label,' is not different from 2a (p = ',
                    formatC(mass_exp_int_test$test$pvalues[['factor(exp)pilot']],format = 'e',digits = 3),').',
                    sep='')
  }
  
  # Interaction Effects
  
  # 2b
  if (mass_exp_int_test$test$pvalues[['factor(exp)pilot']] < 0.05){
    if (mass_exp_int_test$coef[['eff_mass:factor(exp)smallt']] > 0){
      mass_exp_in_2b = paste('Experiment 2b ',label,' increases with mass more than experiment 2a (slope = ',
                        formatC(mass_exp_int_test$coef[['eff_mass:factor(exp)smallt']],format = 'e',digits = 3),
                        ', p = ', formatC(mass_exp_int_test$test$pvalues[['eff_mass:factor(exp)smallt']],format = 'e',digits = 3),').', sep = '')
    } else {
      mass_exp_in_2b = paste('Experiment 2b ',label,' decreases with mass more than experiment 2a (slope = ',
                        formatC(mass_exp_int_test$coef[['eff_mass:factor(exp)smallt']],format = 'e',digits = 3),
                        ', p = ', formatC(mass_exp_int_test$test$pvalues[['eff_mass:factor(exp)smallt']],format = 'e',digits = 3),').', sep = '')
    }
  } else {
    mass_exp_in_2b = paste('Experiment 2b ',label,' did NOT change with mass more than 2a. (p = ',
                           formatC(mass_exp_int_test$test$pvalues[['eff_mass:factor(exp)smallt']],format = 'e',digits = 3),').',
                           sep='')
  }
  
  #2c
  if (mass_exp_int_test$test$pvalues[['eff_mass:factor(exp)pilot']] < 0.05){
    if (mass_exp_int_test$coef[['eff_mass:factor(exp)pilot']] > 0 ){
      mass_exp_in_2c = paste('Experiment 2c ',label,' increases with mass more than experiment 2a (slope = ',
                        formatC(mass_exp_int_test$coef[['eff_mass:factor(exp)pilot']],format = 'e',digits = 3),
                        ', p = ', formatC(mass_exp_int_test$test$pvalues[['eff_mass:factor(exp)pilot']],format = 'e',digits = 3),').', sep = '')
    } else {
      mass_exp_in_2c = paste('Experiment 2c ',label,' decreases with mass more than experiment 2a (slope = ',
                        formatC(mass_exp_int_test$coef[['eff_mass:factor(exp)pilot']],format = 'e',digits = 3),
                        ', p = ', formatC(mass_exp_int_test$test$pvalues[['eff_mass:factor(exp)pilot']],format = 'e',digits = 3),').', sep = '')
    }
  } else {
    mass_exp_in_2c = paste('Experiment 2c ',label,' did NOT change with mass more than 2a. (p = ',
                    formatC(mass_exp_int_test$test$pvalues[['eff_mass:factor(exp)pilot']],format = 'e',digits = 3),').',
                    sep='')
  }
  
  combined_string = paste(main_mass,'\n',
                          main_2b,'\n',
                          main_2c,'\n','\n',
                          'The interesting thing with these are the interaction effects.','\n',
                          mass_exp_in_2b,'\n',
                          mass_exp_in_2c,'\n',
                          sep='\n')
  return(combined_string)
}


table_func <- function(data, variable){
  # Table generating function for the metabolic data.
  # This prints a table with mean of means and se of subject means.
  eval(parse(text = paste('data$table_var = data$',variable,sep='')))
  tab = matrix(,nrow=4,ncol=7)
  for (s in c(1:7)){
    m_count = 0
    for (mass in c(2.44,4.830,7.13,11.69)){
      m_count = m_count + 1
      avg = round(mean(filter(data,speed == s, effmass == mass)$table_var),4)
      se = round(sd(filter(data,speed == s, effmass == mass)$table_var)/sqrt(length(filter(data,speed == s, effmass == mass)$table_var)),4)
      tab[m_count,s] = paste(avg,"±",se,sep=' ')
    }
  }
  colnames(tab) = c('Speed = 1','Speed = 2','Speed = 3','Speed = 4','Speed = 5','Speed = 6','Speed = 7')
  rownames(tab) = c('2.73 kg','4.83 kg','7.13 kg','11.69 kg')
  return(tab)
}

table_func_nosd <- function(data, variable){
  # Same as before, no sd.
  eval(parse(text = paste('data$table_var = data$',variable,sep='')))
  tab = matrix(,nrow=4,ncol=7)
  for (s in c(1:7)){
    m_count = 0
    for (mass in c(2.44,4.830,7.13,11.69)){
      m_count = m_count + 1
      avg = round(mean(filter(data,speed == s, effmass == mass)$table_var, na.rm = TRUE),4)
      tab[m_count,s] = paste(avg,sep=' ')
    }
  }
  colnames(tab) = c('Speed = 1','Speed = 2','Speed = 3','Speed = 4','Speed = 5','Speed = 6','Speed = 7')
  rownames(tab) = c('2.73 kg','4.83 kg','7.13 kg','11.69 kg')
  return(tab)
}

avg_table_func_avgavg <- function(data1, data2, data3, variable){
  # Generates a table for the preferred (2a, 2b, 2c).
  # Outputs table with mean of subject means, and standard error of subject means.
  data1$variable = data1[[variable]]
  data2$variable = data2[[variable]]
  data3$variable = data3[[variable]]
  
  tempavg1 = aggregate(variable ~ condition + subj, data1, mean)
  tempavg2 = aggregate(variable ~ condition + subj, data2, mean)
  tempavg3 = aggregate(variable ~ condition + subj, data3, mean)
  
  mean1 = aggregate(variable ~ condition, tempavg1, mean)
  mean2 = aggregate(variable ~ condition, tempavg2, mean)
  mean3 = aggregate(variable ~ condition, tempavg3, mean)
  
  tempsd1 = aggregate(variable ~ condition, tempavg1, sd)
  tempsd2 = aggregate(variable ~ condition, tempavg2, sd)
  tempsd3 = aggregate(variable ~ condition, tempavg3, sd)
  
  move_dur_avg = cbind(mean1$variable, mean2$variable, mean3$variable)
  move_dur_avg = formatC(move_dur_avg,digits = 4, format = 'f')
  
  move_dur_se = cbind(tempsd1$variable, tempsd2$variable, tempsd3$variable)
  move_dur_se = formatC(move_dur_se,digits = 4, format = 'f')
  
  out_df = matrix(,nrow = 4, ncol = 3)
  for (rows in c(1:4)){
    for (cols in c(1:3)){
      out_df[rows,cols] = paste(move_dur_avg[rows,cols],'±',move_dur_se[rows,cols],sep='')
    }
  }
  out_df = cbind(c(2.5,3.8,4.7,6.1),out_df)
  colnames(out_df) = c('Effective Mass (kg)','2a','2b','2c')
  return(out_df)
}

avg_table_func_se_prop <- function(data1, data2, data3, variable){
  # Generates a table for the preferred (2a, 2b, 2c).
  # Outputs table with mean of subject means, and standard error propogated through variance.
  data1$variable = data1[[variable]]
  data2$variable = data2[[variable]]
  data3$variable = data3[[variable]]
  
  tempavg1 = aggregate(variable ~ condition + subj, data1, mean)
  tempavg2 = aggregate(variable ~ condition + subj, data2, mean)
  tempavg3 = aggregate(variable ~ condition + subj, data3, mean)
  
  tempsd1 = aggregate(variable ~ condition + subj, data1, var)
  tempsd2 = aggregate(variable ~ condition + subj, data2, var)
  tempsd3 = aggregate(variable ~ condition + subj, data3, var)
  
  mean1 = aggregate(variable ~ condition, tempavg1, mean)
  mean2 = aggregate(variable ~ condition, tempavg2, mean)
  mean3 = aggregate(variable ~ condition, tempavg3, mean)
  
  move_dur_avg = cbind(mean1$variable, mean2$variable, mean3$variable)
  move_dur_avg = formatC(move_dur_avg,digits = 4, format = 'f')
  
  sd_group1 = c()
  sd_group2 = c()
  sd_group3 = c()
  
  c_count = 1
  for (cond in c(0,3,5,8)){
    sd_group1[c_count] = sqrt(sum(filter(tempsd1, condition == cond)$variable)/(max(tempsd1$subj)^2))
    
    sd_group1[c_count] = sqrt(sum(filter(tempsd1, condition == cond)$variable)/(max(tempsd1$subj)^2))
    sd_group2[c_count] = sqrt(sum(filter(tempsd2, condition == cond)$variable)/(max(tempsd2$subj)^2))
    sd_group3[c_count] = sqrt(sum(filter(tempsd3, condition == cond)$variable)/(max(tempsd3$subj)^2))
    c_count = c_count+1
  }
  move_dur_se = cbind(sd_group1, sd_group2, sd_group3)
  move_dur_se = formatC(move_dur_se,digits = 4, format = 'f')
  
  out_df = matrix(,nrow = 4, ncol = 3)
  for (rows in c(1:4)){
    for (cols in c(1:3)){
      out_df[rows,cols] = paste(move_dur_avg[rows,cols],'±',move_dur_se[rows,cols],sep='')
    }
  }
  out_df = cbind(c(2.5,3.8,4.7,6.1),out_df)
  colnames(out_df) = c('Effective Mass (kg)','2a','2b','2c')
  return(out_df)
}

sse_prop <- function(data, variable){
  # Function to output propogated standard error.
  data$variable = data[[variable]]
  
  tempavg1 = aggregate(variable ~ condition + subj, data, mean)
  
  tempsd1 = aggregate(variable ~ condition + subj, data, var)
  
  mean1 = aggregate(variable ~ condition, tempavg1, mean)
  
  move_dur_avg = cbind(mean1$variable)
  move_dur_avg = formatC(move_dur_avg,digits = 4, format = 'f')
  
  sd_group1 = c()
  
  c_count = 1
  for (cond in c(0,3,5,8)){
    sd_group1[c_count] = sqrt(sum(filter(tempsd1, condition == cond)$variable)/(max(tempsd1$subj)^2))
    c_count = c_count+1
  }
  move_dur_se = cbind(sd_group1)
  return(move_dur_se)
}

sse_prop_met <- function(data, variable){
  # Standard error propogation for metabolics
  data$variable = data[[variable]]
  
  tempsd1 = aggregate(variable ~ speed + condition + subj, data, var)
  sd_group1 = c()
  
  c_count = 1
  prop_se = c()
  for (cond in unique(data$condition)){
    if (cond %in% c(1,2)){
      speeds = c(1,2,3,4,5,6,7)
    } else {
      speeds = c(2,3,4,5,6,7)
    }
    for (speed in speeds){
      se_group = sqrt(sum(filter(tempsd1, condition == cond, speed == speed)$variable)/(max(tempsd1$subj)^2))
      prop_se = rbind(prop_se, c(speed, cond, se_group))
      # sd_group1[c_count] = sqrt(sum(filter(tempsd1, condition == cond, speed == speed)$variable^2)/(max(tempsd1$subj)^2))
      c_count = c_count+1
    }
  }
  prop_se
  
  return(prop_se[,3])
}

# Set colors
# color1 = c(255,255,0)/255
# color2 = c(255,196,0)/255
# color3 = c(216,117,1)/255
# color4 = c(139,0,0)/255

color1 = c(255,196,0)/255
color2 = c(216,117,1)/255
color3 = c(139,0,0)/255
color4 = c(0,0,0)/255

mass_colors <- c(rgb(color1[1],color1[2],color1[3]),
              rgb(color2[1],color2[2],color2[3]),
              rgb(color3[1],color3[2],color3[3]),
              rgb(color4[1],color4[2],color4[3]))



```

```{r, echo = FALSE, message = FALSE, warning = FALSE}
# Table that listst average effective masses for experiment 2a
tab = matrix(,nrow=4,ncol=1)
dcount = 0
for (data in c('pref')){#,'smallt','pilot')){
  dcount = dcount +1
  eval(parse(text = paste('data_set = ',data,'data',sep='')))
  ccount = 0
  for (c in c(0,3,5,8)){
  ccount = ccount + 1
    tab[ccount,dcount] = paste(mean(filter(data_set,condition == c)$eff_mass2),
                               '±',
                               sd(filter(data_set,condition == c)$eff_mass2)/sqrt(12))
  }
}


```

```{r, echo = FALSE, message = FALSE, warning = FALSE}
# This isn't really used, was going to be a transfer to tibble, but I don't use that anymore.
temp_pref <- prefdata %>% group_by(subj,eff_mass) %>% summarise_each(funs(mean))

```

# Preferred Experiment

Original Pref Length = `r pref_orig_len`
Filtered Pref Length = `r length(prefdata$subj)`

Original Smallt Length = `r smallt_orig_len`
Filtered Smallt Length = `r length(smalltdata$subj)`

Original Pilot Length = `r pilot_orig_len`
Filtered Pilot Length = `r length(pilotdata$subj)`


## Across prefs
```{r, echo = FALSE}

# This code section generates plots for movement duration normalized, reaction velocity
# miss angle, and miss radial.

cont_exp = c('pref','pilot','smallt')
cont_exp_frame = aggregate(movedur ~ eff_mass + exp, prefpilot,mean)
cont_exp_frame2 = aggregate(peakvel_target ~ eff_mass + exp, prefpilot,mean)
cont_exp_frame <- cbind(cont_exp_frame,cont_exp_frame2$peakvel_target)
colnames(cont_exp_frame) = c('eff_mass','exp','movedur','peakvel_target')
count = 1
temp = c()# matrix(0L,nrow=4,ncol=3)

for (c_exp in cont_exp){
  temp = rbind(temp,cbind(c(rep(times = 4, c_exp)),
               c(2.5,3.8,4.7,6.1),
               filter(cont_exp_frame,exp==c_exp)$movedur/filter(cont_exp_frame,exp==c_exp)$movedur[1],
               filter(cont_exp_frame,exp==c_exp)$peakvel_target/filter(cont_exp_frame,exp==c_exp)$peakvel_target[1]))
  # [1:4,count] = filter(test,exp==c_exp)$movedur/filter(test,exp==c_exp)$movedur[1]
  count = count+1
}
colnames(temp) = c('exp','eff_mass','movedurnorm','peakvel_norm')
temp <- as.data.frame(temp)
temp$eff_mass <- as.numeric(as.character(temp$eff_mass))
temp$movedurnorm <- as.numeric(as.character(temp$movedurnorm))
temp$peakvel_norm <- as.numeric(as.character(temp$peakvel_norm))

Movedurnorm_by_experiment <- ggplot()+
  geom_line(data=temp,aes(x=eff_mass,
                          y=movedurnorm,
                          group=exp,
                          color=exp),
            size=3)+
  scale_x_continuous(breaks=c(sort(unique(prefpilot$eff_mass))))+
  scale_color_manual(name = "Target Type",
                     labels = c('Circle','None','Arc'),
                     values = gg_color_hue(3))+
  labs(x='Effective mass (kg)',
       y='Movement Duration\n Normalized (s)')+
  # theme_classic()
  theme(text=element_text(size=20),
        legend.text=element_text(size=15),
        legend.text.align = 0)


Reactvel_by_experiment <- all_exp_avg_plot_addmass('reaction_tanvel',prefdata,smalltdata,pilotdata,ylab = 'Reaction Velocity (s)')

# setwd(pref_plots_dir)
# if (save_plots){ggsave('Reacttime_by_experiment.pdf', plot = Reacttime_by_experiment, width=6, height=4, useDingbats = FALSE)}

# Miss Angle
a = aggregate(missangle ~ subj + eff_mass,prefdata,var)
b = aggregate(movedur ~ subj + eff_mass,prefdata,mean)
c = data.frame(cbind(a$subj,a$eff_mass,b$movedur,a$missangle))
colnames(c) = c('subj','eff_mass','movedur','missangle')
c$exp = 'pref'
miss_var_pref = c

a = aggregate(missangle ~ subj + eff_mass,smalltdata,var)
b = aggregate(movedur ~ subj + eff_mass,smalltdata,mean)
c = data.frame(cbind(a$subj,a$eff_mass,b$movedur,a$missangle))
colnames(c) = c('subj','eff_mass','movedur','missangle')
c$exp = 'smallt'
miss_var_smallt = c

a = aggregate(missangle ~ subj + eff_mass,pilotdata,var)
b = aggregate(movedur ~ subj + eff_mass,pilotdata,mean)
c = data.frame(cbind(a$subj,a$eff_mass,b$movedur,a$missangle))
colnames(c) = c('subj','eff_mass','movedur','missangle')
c$exp = 'pilot'
miss_var_pilot = c

missangle_by_experiement <- all_exp_avg_plot('missangle',miss_var_pref,miss_var_smallt,miss_var_pilot,ylab = expression(atop(Miss~Angle~Variance~(deg^2))))


# Miss Rad

a = aggregate(miss_rad ~ subj + eff_mass,prefdata,var)
b = aggregate(movedur ~ subj + eff_mass,prefdata,mean)
c = data.frame(cbind(a$subj,a$eff_mass,b$movedur,a$miss_rad))
colnames(c) = c('subj','eff_mass','movedur','miss_rad')
c$exp = 'pref'
c$miss_rad = c$miss_rad*(100^2)
miss_var_pref = c

a = aggregate(miss_rad ~ subj + eff_mass,smalltdata,var)
b = aggregate(movedur ~ subj + eff_mass,smalltdata,mean)
c = data.frame(cbind(a$subj,a$eff_mass,b$movedur,a$miss_rad))
colnames(c) = c('subj','eff_mass','movedur','miss_rad')
c$exp = 'smallt'
c$miss_rad = c$miss_rad*(100^2)
miss_var_smallt = c

a = aggregate(miss_rad ~ subj + eff_mass,pilotdata,var)
b = aggregate(movedur ~ subj + eff_mass,pilotdata,mean)
c = data.frame(cbind(a$subj,a$eff_mass,b$movedur,a$miss_rad))
colnames(c) = c('subj','eff_mass','movedur','miss_rad')
c$exp = 'pilot'
c$miss_rad = c$miss_rad*(100^2)
miss_var_pilot = c

miss_rad_by_experiement <- all_exp_avg_plot('miss_rad',miss_var_pref,miss_var_smallt,miss_var_pilot,ylab = expression(atop(Miss~Radial~Variance~(cm^2))))

```

## Movement Duration
```{r, echo = FALSE}
# Main Section for movement duration.

# Linear models
dur_lm_all = cftest(lmer(movedur ~ factor(targetnum) + eff_mass + (1|subj) + (1|exp),data=prefpilot))
dur_lm_pref = cftest(lmer(movedur ~ factor(targetnum) + eff_mass + (1|subj),data=filter(prefpilot,exp=='pref')))
dur_lm_pilot = cftest(lmer(movedur ~ factor(targetnum) + eff_mass + (1|subj),data=filter(prefpilot,exp=='pilot')))
dur_lm_smallt = cftest(lmer(movedur ~ factor(targetnum) + eff_mass + (1|subj),data=filter(prefpilot,exp=='smallt')))

dur_aov = aov(movedur ~ exp + (1|subj) ,data=aggregate(movedur ~ exp + subj,prefpilot,mean))
# dur_aov = summary(aov(movedur ~ eff_mass + exp + (1|subj) ,data=aggregate(movedur ~ eff_mass + exp + subj,prefpilot,mean)))

# P value table
dur_p_table = rbind(c('Circle',formatC(dur_lm_pref$test$coefficients[5],format = 'e', digits = 3),
                      formatC(dur_lm_pref$test$pvalues[5],format = 'e', digits = 3),
                      formatC(dur_lm_pref$test$sigma[5],format = 'e', digits = 3)),
                    c('Pilot',formatC(dur_lm_pilot$test$coefficients[5],format = 'e', digits = 3),
                      formatC(dur_lm_pilot$test$pvalues[5],format = 'e', digits = 3),
                      formatC(dur_lm_pilot$test$sigma[5],format = 'e', digits = 3)),
                    c('Arc',formatC(dur_lm_smallt$test$coefficients[5],format = 'e', digits = 3),
                      formatC(dur_lm_smallt$test$pvalues[5],format = 'e', digits = 3),
                      formatC(dur_lm_smallt$test$sigma[5],format = 'e', digits = 3)),
                    c('All',formatC(dur_lm_all$test$coefficients[5],format = 'e', digits = 3),
                      formatC(dur_lm_all$test$pvalues[5],format = 'e', digits = 3),
                      formatC(dur_lm_all$test$sigma[5],format = 'e', digits = 3)))
colnames(dur_p_table) = c('Duration','Linear Estimate','P-Value','Std Error')

kable(dur_p_table, caption = 'Movement duration linear models.')


# This section generates the average value tables.
# The first table is average of all data, with standard deviation/sqrt(n subjects)
move_pref <- aggregate(movedur ~ eff_mass,prefdata,mean)$movedur
move_pilo <- aggregate(movedur ~ eff_mass,pilotdata,mean)$movedur
move_arct <- aggregate(movedur ~ eff_mass,smalltdata,mean)$movedur

move_pref_se <- aggregate(movedur ~ eff_mass,prefdata,sd)$movedur/sqrt(12)
move_pilo_se <- aggregate(movedur ~ eff_mass,pilotdata,sd)$movedur/sqrt(12)
move_arct_se <- aggregate(movedur ~ eff_mass,smalltdata,sd)$movedur/sqrt(18)

move_dur_avg <- round(cbind(move_pref,move_arct,move_pilo),digits=3)
move_dur_se <- round(cbind(move_pref_se,move_arct_se,move_pilo_se),digits=3)
move_dur_df = matrix(,nrow = 4, ncol = 3)
for (rows in c(1:4)){
  for (cols in c(1:3)){
    move_dur_df[rows,cols] = paste(move_dur_avg[rows,cols],'±',move_dur_se[rows,cols],sep='')
  }
}

move_dur <- cbind(c(2.5,3.8,4.7,6.1),move_dur_df)
colnames(move_dur) <- c('Effective Mass (kg)','2a','2b','2c')

kable(move_dur, caption = 'Movement duration average values, NO propogated error ALL AVG  (s)')

# This table is mean of subject means, and SE is SE of subject means
kable(avg_table_func_avgavg(prefdata,smalltdata,pilotdata,'movedur'),caption = 'Movement duration average values (s). Mean = mean of subject means. SE = SE of subject means.')

# Table for mean of subject means, with propogated variance.
kable(avg_table_func_se_prop(prefdata,smalltdata,pilotdata,'movedur'),caption = 'Movement duration average values with PROPGATED ERROR (s)')
        
# one violin plot for movement duration, this isn't shown in the html.
movedur = list()
movedur[['pref']]<-vplot('movedur',prefdata)+
  labs(x='Effective Mass (kg)',y='Movement Duration (s)')+
  guides(fill=guide_legend(title="Effective\nMass (kg)"))+
  # theme_classic()
  theme(legend.position='none')+
  geom_hline(yintercept=mean(filter(prefdata,condition==0)$movedur),linetype='dashed',size=.5)
```

`r mass_exp_int_stringgen(prefpilot,'movedur','movement duration')`

```{r Movedurbyexperiment, echo = FALSE, warning = FALSE, fig.width=12, fig.height=8, fig.cap = 'Movement Duration by experiment.'}
# ```{r movedur2, echo = FALSE, warning = FALSE, fig.width=12, fig.height=8, fig.cap = 'Movement duration by experiment.'}

# Generate the figure for experiment 2a, 2b, 2c, for the metric.
Movedur_by_experiment <- all_exp_avg_plot_addmass('movedur',prefdata,smalltdata,pilotdata,ylab = 'Movement Duration (s)')

Movedur_by_experiment+theme(text = element_text(size = 18))

# Save the plot if necessary.
setwd(pref_plots_dir)
if (save_plots){
  ggsave('Movedur_by_experiment.pdf',plot=Movedur_by_experiment+theme(text = element_text(size = 18)),width=12,height=8, useDingbats = FALSE)
}

```

### Movement Duration Norm
```{r, echo = FALSE}
  dur_lm_all = cftest(lmer(movedur_norm ~ factor(targetnum) + eff_mass + (1|subj) + (1|exp),data=prefpilot))
  dur_lm_pref = cftest(lmer(movedur_norm ~ factor(targetnum) + eff_mass + (1|subj),data=filter(prefpilot,exp=='pref')))
  dur_lm_pilot = cftest(lmer(movedur_norm ~ factor(targetnum) + eff_mass + (1|subj),data=filter(prefpilot,exp=='pilot')))
  dur_lm_smallt = cftest(lmer(movedur_norm ~ factor(targetnum) + eff_mass + (1|subj),data=filter(prefpilot,exp=='smallt')))
  
  dur_p_table = rbind(c('Circle',formatC(dur_lm_pref$test$coefficients[5],format = 'e', digits = 3),
                        formatC(dur_lm_pref$test$pvalues[5],format = 'e', digits = 3),
                        formatC(dur_lm_pref$test$sigma[5],format = 'e', digits = 3)),
                      c('Pilot',formatC(dur_lm_pilot$test$coefficients[5],format = 'e', digits = 3),
                        formatC(dur_lm_pilot$test$pvalues[5],format = 'e', digits = 3),
                        formatC(dur_lm_pilot$test$sigma[5],format = 'e', digits = 3)),
                      c('Arc',formatC(dur_lm_smallt$test$coefficients[5],format = 'e', digits = 3),
                        formatC(dur_lm_smallt$test$pvalues[5],format = 'e', digits = 3),
                        formatC(dur_lm_smallt$test$sigma[5],format = 'e', digits = 3)),
                      c('All',formatC(dur_lm_all$test$coefficients[5],format = 'e', digits = 3),
                        formatC(dur_lm_all$test$pvalues[5],format = 'e', digits = 3),
                        formatC(dur_lm_all$test$sigma[5],format = 'e', digits = 3)))
  colnames(dur_p_table) = c('Duration','Linear Estimate','P-Value','Std Error')
  
  kable(dur_p_table, caption = 'Movement duration linear models.')
  
  move_pref <- aggregate(movedur_norm ~ eff_mass,prefdata,mean)$movedur_norm
  move_pilo <- aggregate(movedur_norm ~ eff_mass,pilotdata,mean)$movedur_norm
  move_arct <- aggregate(movedur_norm ~ eff_mass,smalltdata,mean)$movedur_norm
  
  move_pref_se <- aggregate(movedur_norm ~ eff_mass,prefdata,sd)$movedur_norm/sqrt(12)
  move_pilo_se <- aggregate(movedur_norm ~ eff_mass,pilotdata,sd)$movedur_norm/sqrt(12)
  move_arct_se <- aggregate(movedur_norm ~ eff_mass,smalltdata,sd)$movedur_norm/sqrt(18)
  
  move_dur_avg <- round(cbind(move_pref,move_arct,move_pilo),digits=3)
  move_dur_se <- round(cbind(move_pref_se,move_arct_se,move_pilo_se),digits=3)
  move_dur_df = matrix(,nrow = 4, ncol = 3)
  for (rows in c(1:4)){
    for (cols in c(1:3)){
      move_dur_df[rows,cols] = paste(move_dur_avg[rows,cols],'±',move_dur_se[rows,cols],sep='')
    }
  }
  
  move_dur <- cbind(c(2.5,3.8,4.7,6.1),move_dur_df)
  colnames(move_dur) <- c('Effective Mass (kg)','2a','2b','2c')
  kable(move_dur, caption = 'Movement duration average values, NO propogated error ALL AVG  (s)')
  
  kable(avg_table_func_avgavg(prefdata,smalltdata,pilotdata,'movedur_norm'),caption = 'Movement duration NORM average values (s). Mean = mean of subject means. SE = SE of subject means.')
  
  kable(avg_table_func_se_prop(prefdata,smalltdata,pilotdata,'movedur_norm'),caption = 'Movement duration NORM average values with PROPGATED ERROR (s)')
```

`r mass_exp_int_stringgen(prefpilot,'movedur_norm','movement duration')`

```{r movedur_normbyexperiment, echo = FALSE, warning = FALSE, fig.width=12, fig.height=8, fig.cap = 'Movement Duration by experiment.'}

Movedur_norm_by_experiment <- all_exp_avg_plot_addmass('movedur_norm',prefdata,smalltdata,pilotdata,ylab = 'Movement Duration Normalized (s)')
  
Movedur_norm_by_experiment+theme(text = element_text(size = 18))

setwd(pref_plots_dir)
if (save_plots){
  ggsave('movedur_norm_by_experiment.pdf',plot=Movedur_norm_by_experiment+theme(text = element_text(size = 18)),width=12,height=8, useDingbats = FALSE)
}

```


## Peak Velocity
```{r, echo = FALSE}
# PEAK VEL TARGET IS OVERWRITTEN BY RADV IN BEGINNING
  vel_lm_all = cftest(lmer(peakvel_target ~ factor(targetnum) + eff_mass +  (1|subj) + (1|exp),data=prefpilot))
  vel_lm_pref = cftest(lmer(peakvel_target ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='pref')))
  vel_lm_pilot = cftest(lmer(peakvel_target ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='pilot')))
  vel_lm_smallt = cftest(lmer(peakvel_target ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='smallt')))
  
  dur_aov = summary(aov(peakvel_target ~ exp + (1|subj) ,data=aggregate(peakvel_target ~ exp + subj,prefpilot,mean)))
  # dur_aov = summary(aov(peakvel_target ~ eff_mass + exp + (1|subj) ,data=aggregate(movedur ~ eff_mass + exp + subj,prefpilot,mean)))
  
  vel_p_table = rbind(c('Circle',formatC(vel_lm_pref$test$coefficients[5],format = 'e', digits = 3),
                        formatC(vel_lm_pref$test$pvalues[5],format = 'e', digits = 3),
                        formatC(vel_lm_pref$test$sigma[5],format = 'e', digits = 3)),
                      c('Pilot',formatC(vel_lm_pilot$test$coefficients[5],format = 'e', digits = 3),
                        formatC(vel_lm_pilot$test$pvalues[5],format = 'e', digits = 3),
                        formatC(vel_lm_pilot$test$sigma[5],format = 'e', digits = 3)),
                      c('Arc',formatC(vel_lm_smallt$test$coefficients[5],format = 'e', digits = 3),
                        formatC(vel_lm_smallt$test$pvalues[5],format = 'e', digits = 3),
                        formatC(vel_lm_smallt$test$sigma[5],format = 'e', digits = 3)),
                      c('All',formatC(vel_lm_all$test$coefficients[5],format = 'e', digits = 3),
                        formatC(vel_lm_all$test$pvalues[5],format = 'e', digits = 3),
                        formatC(vel_lm_all$test$sigma[5],format = 'e', digits = 3)))
  colnames(vel_p_table) = c('Velocity','Linear Estimate','P-Value','Std Error')
  
  kable(vel_p_table, caption = 'Peak Velocity linear models.')
  
  vel_pref <- aggregate(peakvel_target ~ eff_mass,prefdata,mean)$peakvel_target
  vel_arct <- aggregate(peakvel_target ~ eff_mass,smalltdata,mean)$peakvel_target
  vel_pilo <- aggregate(peakvel_radv ~ eff_mass,pilotdata,mean)$peakvel_radv
  
  vel_pref_se <- aggregate(peakvel_target ~ eff_mass,prefdata,mean)$peakvel_target/sqrt(12)
  vel_arct_se <- aggregate(peakvel_target ~ eff_mass,smalltdata,mean)$peakvel_target/sqrt(12)
  vel_pilo_se <- aggregate(peakvel_radv ~ eff_mass,pilotdata,mean)$peakvel_radv/sqrt(18)
  
  peak_vel_avg <- round(cbind(vel_pref,vel_arct,vel_pilo),digits=3)
  peak_vel_se <- round(cbind(vel_pref_se,vel_arct_se,vel_pilo_se),digits=3)
  peak_vel_df = matrix(,nrow = 4, ncol = 3)
  for (rows in c(1:4)){
    for (cols in c(1:3)){
      peak_vel_df[rows,cols] = paste(peak_vel_avg[rows,cols],'±',peak_vel_se[rows,cols],sep='')
    }
  }
  
  peak_vel <- cbind(c(2.5,3.8,4.7,6.1),peak_vel_df)
  colnames(peak_vel) <- c('Effective Mass (kg)','2a','2b','2c')
  kable(peak_vel, caption = 'Peak Velocity average values, NO propogated error ALL AVG  (m/s)')
  
  kable(avg_table_func_avgavg(prefdata,smalltdata,pilotdata,'peakvel_radv'),caption = 'Peak Velocity average values (m/s). Mean = mean of subject means. SE = SE of subject means.')
  
  kable(avg_table_func_se_prop(prefdata,smalltdata,pilotdata,'peakvel_radv'),caption = 'Peak Velocity average values with PROPGATED ERROR (m/s)')
  
```

`r mass_exp_int_stringgen(prefpilot,'peakvel_target','peak velocity')`

```{r Peakvelbyexperiment, echo = FALSE, warning = FALSE, fig.width=12, fig.height=8, fig.cap = 'Peak Velocity by experiment.'}

  Peakvel_by_experiment <- all_exp_avg_plot_addmass('peakvel_radv',prefdata,smalltdata,pilotdata,ylab = 'Peak Velocity (m/s)')

  Peakvel_by_experiment+theme(text = element_text(size = 18))
```

### Peak Velocity Normalized
```{r, echo = FALSE}
# PEAK VEL TARGET IS OVERWRITTEN BY RADV IN BEGINNING
  vel_lm_all = cftest(lmer(peakvel_target_norm ~ factor(targetnum) + eff_mass +  (1|subj) + (1|exp),data=prefpilot))
  vel_lm_pref = cftest(lmer(peakvel_target_norm ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='pref')))
  vel_lm_pilot = cftest(lmer(peakvel_target_norm ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='pilot')))
  vel_lm_smallt = cftest(lmer(peakvel_target_norm ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='smallt')))
  
  
  vel_p_table = rbind(c('Circle',formatC(vel_lm_pref$test$coefficients[5],format = 'e', digits = 3),
                        formatC(vel_lm_pref$test$pvalues[5],format = 'e', digits = 3),
                        formatC(vel_lm_pref$test$sigma[5],format = 'e', digits = 3)),
                      c('Pilot',formatC(vel_lm_pilot$test$coefficients[5],format = 'e', digits = 3),
                        formatC(vel_lm_pilot$test$pvalues[5],format = 'e', digits = 3),
                        formatC(vel_lm_pilot$test$sigma[5],format = 'e', digits = 3)),
                      c('Arc',formatC(vel_lm_smallt$test$coefficients[5],format = 'e', digits = 3),
                        formatC(vel_lm_smallt$test$pvalues[5],format = 'e', digits = 3),
                        formatC(vel_lm_smallt$test$sigma[5],format = 'e', digits = 3)),
                      c('All',formatC(vel_lm_all$test$coefficients[5],format = 'e', digits = 3),
                        formatC(vel_lm_all$test$pvalues[5],format = 'e', digits = 3),
                        formatC(vel_lm_all$test$sigma[5],format = 'e', digits = 3)))
  colnames(vel_p_table) = c('Velocity','Linear Estimate','P-Value','Std Error')
  
  kable(vel_p_table, caption = 'Peak Velocity linear models.')
  
  vel_pref <- aggregate(peakvel_target_norm ~ eff_mass,prefdata,mean)$peakvel_target_norm
  vel_arct <- aggregate(peakvel_target_norm ~ eff_mass,smalltdata,mean)$peakvel_target_norm
  vel_pilo <- aggregate(peakvel_target_norm ~ eff_mass,pilotdata,mean)$peakvel_target_norm
  
  vel_pref_se <- aggregate(peakvel_target_norm ~ eff_mass,prefdata,mean)$peakvel_target_norm/sqrt(12)
  vel_arct_se <- aggregate(peakvel_target_norm ~ eff_mass,smalltdata,mean)$peakvel_target_norm/sqrt(12)
  vel_pilo_se <- aggregate(peakvel_target_norm ~ eff_mass,pilotdata,mean)$peakvel_target_norm/sqrt(18)
  
  peak_vel_avg <- round(cbind(vel_pref,vel_arct,vel_pilo),digits=3)
  peak_vel_se <- round(cbind(vel_pref_se,vel_arct_se,vel_pilo_se),digits=3)
  peak_vel_df = matrix(,nrow = 4, ncol = 3)
  for (rows in c(1:4)){
    for (cols in c(1:3)){
      peak_vel_df[rows,cols] = paste(peak_vel_avg[rows,cols],'±',peak_vel_se[rows,cols],sep='')
    }
  }
  
  peak_vel <- cbind(c(2.5,3.8,4.7,6.1),peak_vel_df)
  colnames(peak_vel) <- c('Effective Mass (kg)','2a','2b','2c')
  kable(peak_vel, caption = 'Peak Velocity average values, NO propogated error ALL AVG  (m/s)')
  
  kable(avg_table_func_avgavg(prefdata,smalltdata,pilotdata,'peakvel_target_norm'),caption = 'Peak Velocity NORM average values (m/s). Mean = mean of subject means. SE = SE of subject means.')
  
  kable(avg_table_func_se_prop(prefdata,smalltdata,pilotdata,'peakvel_target_norm'),caption = 'Peak Velocity NORM average values with PROPGATED ERROR (m/s)')
  
  
```

`r mass_exp_int_stringgen(prefpilot,'peakvel_target_norm','peak velocity')`

```{r Peakvelnormbyexperiment, echo = FALSE, warning = FALSE, fig.width=12, fig.height=8, fig.cap = 'Peak Velocity by experiment.'}
Peakvel_norm_by_experiment <- all_exp_avg_plot_addmass('peakvel_target_norm',prefdata,smalltdata,pilotdata,ylab = 'Peak Velocity Normalized (m/s)')
  
Peakvel_norm_by_experiment+theme(text = element_text(size = 18))

setwd(pref_plots_dir)
if (save_plots){
  ggsave('peakvel_norm_by_experiment.pdf',plot=Peakvel_norm_by_experiment+theme(text = element_text(size = 18)),width=12,height=8, useDingbats = FALSE)
}

```

## Reaction Time

```{r, echo = FALSE}
  react_lm_all = cftest(lmer(reaction_tanv ~ factor(targetnum) + eff_mass +  (1|subj) + (1|exp),data=prefpilot))
  react_lm_pref = cftest(lmer(reaction_tanv ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='pref')))
  react_lm_pilot = cftest(lmer(reaction_tanv ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='pilot')))
  react_lm_smallt = cftest(lmer(reaction_tanv ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='smallt')))
  
  dur_aov = summary(aov(reaction_tanv ~ exp + (1|subj) ,data=aggregate(reaction_tanv ~ eff_mass + exp + subj,prefpilot,mean)))
  
  react_p_table = rbind(c('Circle',formatC(react_lm_pref$test$coefficients[5],format = 'e', digits = 3),
                        formatC(react_lm_pref$test$pvalues[5],format = 'e', digits = 3),
                        formatC(react_lm_pref$test$sigma[5],format = 'e', digits = 3)),
                      c('Pilot',formatC(react_lm_pilot$test$coefficients[5],format = 'e', digits = 3),
                        formatC(react_lm_pilot$test$pvalues[5],format = 'e', digits = 3),
                        formatC(react_lm_pilot$test$sigma[5],format = 'e', digits = 3)),
                      c('Arc',formatC(react_lm_smallt$test$coefficients[5],format = 'e', digits = 3),
                        formatC(react_lm_smallt$test$pvalues[5],format = 'e', digits = 3),
                        formatC(react_lm_smallt$test$sigma[5],format = 'e', digits = 3)),
                      c('All',formatC(react_lm_all$test$coefficients[5],format = 'e', digits = 3),
                        formatC(react_lm_all$test$pvalues[5],format = 'e', digits = 3),
                        formatC(react_lm_all$test$sigma[5],format = 'e', digits = 3)))
  colnames(react_p_table) = c('Reaction Time','Linear Estimate','P-Value','Std Error')
  kable(react_p_table, caption = 'Reaction Time linear models.')
  
  react_pref <- aggregate(reaction_tanv ~ eff_mass,prefdata,mean)$reaction_tanv
  react_arct <- aggregate(reaction_tanv ~ eff_mass,smalltdata,mean)$reaction_tanv
  react_pilo <- aggregate(reaction_tanv ~ eff_mass,pilotdata,mean)$reaction_tanv
  
  react_pref_se <- aggregate(reaction_tanv ~ eff_mass,prefdata,sd)$reaction_tanv/sqrt(12)
  react_arct_se <- aggregate(reaction_tanv ~ eff_mass,smalltdata,sd)$reaction_tanv/sqrt(12)
  react_pilo_se <- aggregate(reaction_tanv ~ eff_mass,pilotdata,sd)$reaction_tanv/sqrt(18)
  
  react_time_avg <- round(cbind(react_pref,react_arct,react_pilo),digits=3)
  react_time_se <- round(cbind(react_pref_se,react_arct_se,react_pilo_se),digits=3)
  react_time_df = matrix(,nrow = 4, ncol = 3)
  for (rows in c(1:4)){
    for (cols in c(1:3)){
      react_time_df[rows,cols] = paste(react_time_avg[rows,cols],'±',react_time_se[rows,cols],sep='')
    }
  }
  
  react_time <- cbind(c(2.5,3.8,4.7,6.1),react_time_df)
  colnames(react_time) <- c('Effective Mass (kg)','2a','2b','2c')
  kable(react_time, caption = 'Reaction time average values, NO propogated error ALL AVG (m/s)')
  
  kable(avg_table_func_avgavg(prefdata,smalltdata,pilotdata,'reaction_tanv'),caption = 'Reaction time average values (s). Mean = mean of subject means. SE = SE of subject means.')
  
  kable(avg_table_func_se_prop(prefdata,smalltdata,pilotdata,'reaction_tanv'),caption = 'Reaction time average values with PROPGATED ERROR (s)')
  
```

`r mass_exp_int_stringgen(prefpilot,'reaction_tanv','reaction_time')`

```{r Reacttimebyexperiment, echo = FALSE, warning = FALSE, fig.width=12, fig.height=8, fig.cap = 'Reaction Time by experiment.'}
Reacttime_by_experiment <- all_exp_avg_plot_addmass('reaction_tanv',prefdata,smalltdata,pilotdata,ylab = 'Reaction Time (s)')

Reacttime_by_experiment+theme(text = element_text(size = 18))
```

### Reaction Time Normalized

```{r, echo = FALSE}
react_lm_all = cftest(lmer(reaction_tanv_norm ~ factor(targetnum) + eff_mass +  (1|subj) + (1|exp),data=prefpilot))
react_lm_pref = cftest(lmer(reaction_tanv_norm ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='pref')))
react_lm_pilot = cftest(lmer(reaction_tanv_norm ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='pilot')))
react_lm_smallt = cftest(lmer(reaction_tanv_norm ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='smallt')))

react_p_table = rbind(c('Circle',formatC(react_lm_pref$test$coefficients[5],format = 'e', digits = 3),
                        formatC(react_lm_pref$test$pvalues[5],format = 'e', digits = 3),
                        formatC(react_lm_pref$test$sigma[5],format = 'e', digits = 3)),
                      c('Pilot',formatC(react_lm_pilot$test$coefficients[5],format = 'e', digits = 3),
                        formatC(react_lm_pilot$test$pvalues[5],format = 'e', digits = 3),
                        formatC(react_lm_pilot$test$sigma[5],format = 'e', digits = 3)),
                      c('Arc',formatC(react_lm_smallt$test$coefficients[5],format = 'e', digits = 3),
                        formatC(react_lm_smallt$test$pvalues[5],format = 'e', digits = 3),
                        formatC(react_lm_smallt$test$sigma[5],format = 'e', digits = 3)),
                      c('All',formatC(react_lm_all$test$coefficients[5],format = 'e', digits = 3),
                        formatC(react_lm_all$test$pvalues[5],format = 'e', digits = 3),
                        formatC(react_lm_all$test$sigma[5],format = 'e', digits = 3)))
colnames(react_p_table) = c('Reaction Time Norm','Linear Estimate','P-Value','Std Error')
kable(react_p_table, caption = 'Reaction Time linear models.')

react_pref <- aggregate(reaction_tanv_norm ~ eff_mass,prefdata,mean)$reaction_tanv_norm
react_arct <- aggregate(reaction_tanv_norm ~ eff_mass,smalltdata,mean)$reaction_tanv_norm
react_pilo <- aggregate(reaction_tanv_norm ~ eff_mass,pilotdata,mean)$reaction_tanv_norm

react_pref_se <- aggregate(reaction_tanv_norm ~ eff_mass,prefdata,sd)$reaction_tanv_norm/sqrt(12)
react_arct_se <- aggregate(reaction_tanv_norm ~ eff_mass,smalltdata,sd)$reaction_tanv_norm/sqrt(12)
react_pilo_se <- aggregate(reaction_tanv_norm ~ eff_mass,pilotdata,sd)$reaction_tanv_norm/sqrt(18)

react_time_avg <- round(cbind(react_pref,react_arct,react_pilo),digits=3)
react_time_se <- round(cbind(react_pref_se,react_arct_se,react_pilo_se),digits=3)
react_time_df = matrix(,nrow = 4, ncol = 3)
for (rows in c(1:4)){
  for (cols in c(1:3)){
    react_time_df[rows,cols] = paste(react_time_avg[rows,cols],'±',react_time_se[rows,cols],sep='')
  }
}

react_time <- cbind(c(2.5,3.8,4.7,6.1),react_time_df)
colnames(react_time) <- c('Effective Mass (kg)','2a','2b','2c')
kable(react_time, caption = 'Reaction time average values, NO propogated error ALL AVG  (m/s)')

kable(avg_table_func_avgavg(prefdata,smalltdata,pilotdata,'reaction_tanv_norm'),caption = 'Reaction time NORM average values (s). Mean = mean of subject means. SE = SE of subject means.')
  
kable(avg_table_func_se_prop(prefdata,smalltdata,pilotdata,'reaction_tanv_norm'),caption = 'Reaction time NORM average values with PROPGATED ERROR (s)')
```

`r mass_exp_int_stringgen(prefpilot,'reaction_tanv_norm','reaction_time')`

```{r Reacttimenormbyexperiment, echo = FALSE, warning = FALSE, fig.width=12, fig.height=8, fig.cap = 'Reaction Time by experiment.'}

Reacttime_norm_by_experiment <- all_exp_avg_plot_addmass('reaction_tanv_norm',prefdata,smalltdata,pilotdata,ylab = 'Reaction Time Normalized (s)')

Reacttime_norm_by_experiment+theme(text = element_text(size = 18))
```

### Reaction Velocity
```{r, echo = FALSE}
reactvel_lm_all = cftest(lmer(reaction_tanvel ~ factor(targetnum) + eff_mass +  (1|subj) + (1|exp),data=prefpilot))
reactvel_lm_pref = cftest(lmer(reaction_tanvel ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='pref')))
reactvel_lm_pilot = cftest(lmer(reaction_tanvel ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='pilot')))
reactvel_lm_smallt = cftest(lmer(reaction_tanvel ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='smallt')))

reactvelp_table = rbind(c('Circle',formatC(reactvel_lm_pref$test$coefficients[5],format = 'e', digits = 3),
                        formatC(reactvel_lm_pref$test$pvalues[5],format = 'e', digits = 3),
                        formatC(reactvel_lm_pref$test$sigma[5],format = 'e', digits = 3)),
                      c('Pilot',formatC(reactvel_lm_pilot$test$coefficients[5],format = 'e', digits = 3),
                        formatC(reactvel_lm_pilot$test$pvalues[5],format = 'e', digits = 3),
                        formatC(reactvel_lm_pilot$test$sigma[5],format = 'e', digits = 3)),
                      c('Arc',formatC(reactvel_lm_smallt$test$coefficients[5],format = 'e', digits = 3),
                        formatC(reactvel_lm_smallt$test$pvalues[5],format = 'e', digits = 3),
                        formatC(reactvel_lm_smallt$test$sigma[5],format = 'e', digits = 3)),
                      c('All',formatC(reactvel_lm_all$test$coefficients[5],format = 'e', digits = 3),
                        formatC(reactvel_lm_all$test$pvalues[5],format = 'e', digits = 3),
                        formatC(reactvel_lm_all$test$sigma[5],format = 'e', digits = 3)))
colnames(reactvelp_table) = c('Reaction Velocity','Linear Estimate','P-Value','Std Error')
kable(reactvelp_table, caption = 'Reaction Velocity linear models.')

reactvel_pref <- aggregate(reaction_tanvel ~ eff_mass,prefdata,mean)$reaction_tanvel
reactvel_arct <- aggregate(reaction_tanvel ~ eff_mass,smalltdata,mean)$reaction_tanvel
reactvel_pilo <- aggregate(reaction_tanvel ~ eff_mass,pilotdata,mean)$reaction_tanvel

reactvel_pref_se <- aggregate(reaction_tanvel ~ eff_mass,prefdata,sd)$reaction_tanvel/sqrt(12)
reactvel_arct_se <- aggregate(reaction_tanvel ~ eff_mass,smalltdata,sd)$reaction_tanvel/sqrt(12)
reactvel_pilo_se <- aggregate(reaction_tanvel ~ eff_mass,pilotdata,sd)$reaction_tanvel/sqrt(18)

reactvel_avg <- formatC(cbind(reactvel_pref,reactvel_arct,reactvel_pilo),format = 'e', digits = 3)
reactvel_se <- formatC(cbind(reactvel_pref_se,reactvel_arct_se,reactvel_pilo_se),format = 'e', digits = 3)
reactvel_df = matrix(,nrow = 4, ncol = 3)
for (rows in c(1:4)){
  for (cols in c(1:3)){
    reactvel_df[rows,cols] = paste(reactvel_avg[rows,cols],'±',reactvel_se[rows,cols],sep='')
  }
}

reactvel <- cbind(c(2.5,3.8,4.7,6.1),reactvel_df)
colnames(reactvel) <- c('Effective Mass (kg)','2a','2b','2c')
kable(reactvel, caption = 'Reaction velocity average values, NO propgated error (m/s)')

kable(avg_table_func_avgavg(prefdata,smalltdata,pilotdata,'reaction_tanvel'),caption = 'Reaction time velocity average values (m/s). Mean = mean of subject means. SE = SE of subject means.')
  
kable(avg_table_func_se_prop(prefdata,smalltdata,pilotdata,'reaction_tanvel'),caption = 'Reaction time velocity NORM average values with PROPGATED ERROR (s)')

```

`r mass_exp_int_stringgen(prefpilot,'reaction_tanvel','reaction_')`

```{r Reactvelbyexperiment, echo = FALSE, warning = FALSE, fig.width=12, fig.height=8, fig.cap = 'Reaction  by experiment.'}
Reactvel_by_experiment+theme(text = element_text(size = 18))
```

### Reaction Time Algorithm 

These next plots are made to try and show the effect of reaction time algorithms on reaction. Figure \@ref(fig:reactiontanvalgoplot1) shows the reaction time by experiment and algorithm. Figure \@ref(fig:reactiontanvelalgoplot1} shows the velocity at reaction time by the experiments and algorithms. This plot shows that my algorithm is detecting movement onset at very very low movement speeds, whereas other methods detect it at MUCH higher movement speeds.

```{r echo = FALSE, warning = FALSE, message = FALSE}
# Create plots showing the performance of the reaction time algorithms. 
# This first part shows the computed reaction times.
reaction_tanv_algo = list()
reaction_tanv_algo[['pref']] <- avg_plot2(c('reaction_tanv',
                                            'reaction_erik',
                                            'reaction_vthresh',
                                            'reaction_extrap'),
                                          prefdata,
                                          ylab='Reaction Time (s)',
                                          shape_labs = c('Mine','Erik','V Thresh','ExTrap'))

reaction_tanv_algo[['smallt']] <- avg_plot2(c('reaction_tanv',
                                              'reaction_erik',
                                              'reaction_vthresh',
                                              'reaction_extrap'),
                                            smalltdata,
                                            ylab='Reaction Time (s)',
                                            shape_labs = c('Mine','Erik','V Thresh','ExTrap'))

reaction_tanv_algo[['pilot']] <- avg_plot2(c('reaction_tanv',
                                             'reaction_erik',
                                             'reaction_vthresh',
                                             'reaction_extrap'),
                                           pilotdata,
                                           ylab='Reaction Time (s)'
                                           ,shape_labs = c('Mine','Erik','V Thresh','ExTrap'))

```

```{r reactiontanvalgoplot1, echo = FALSE, warning = FALSE, fig.width=12, fig.height=5, fig.cap = 'Reaction Time Algorithm method.'}

plot_grid(reaction_tanv_algo[['pref']]+theme(legend.position = 'none')+scale_y_continuous(breaks = seq(.17,.33,.02), limits = c(.17,.33)),
          reaction_tanv_algo[['smallt']]+theme(legend.position = 'none')+scale_y_continuous(breaks = seq(.17,.33,.02), limits = c(.17,.33)),
          reaction_tanv_algo[['pilot']]+theme(legend.position = 'none')+scale_y_continuous(breaks = seq(.17,.33,.02), limits = c(.17,.33)),
          get_legend(reaction_tanv_algo[['pref']]),
          nrow = 1,
          rel_widths = c(1,1,1,.2),
          align = 'h',
          labels = c('2a','2b','2c',''))
```

```{r echo = FALSE, warning = FALSE, message = FALSE}
# This section shows the velocity at reaction time.
reaction_tanvel_algo = list()
reaction_tanvel_algo[['pref']] <- avg_plot2(c('reaction_tanvel',
                                              'onsetErik_vel',
                                              'onsetvthresh_vel',
                                              'onsettrap_vel'),
                                            prefdata,ylab='Reaction Velocity (m/s)',
                                            shape_labs = c('Mine','Erik','V Thresh','ExTrap'))

reaction_tanvel_algo[['smallt']] <- avg_plot2(c('reaction_tanvel',
                                                'onsetErik_vel',
                                                'onsetvthresh_vel',
                                                'onsettrap_vel'),
                                              smalltdata,ylab='Reaction Velocity (m/s)',
                                              shape_labs = c('Mine','Erik','V Thresh','ExTrap'))

reaction_tanvel_algo[['pilot']] <- avg_plot2(c('reaction_tanvel',
                                               'onsetErik_vel',
                                               'onsetvthresh_vel',
                                               'onsettrap_vel'),
                                             pilotdata,ylab='Reaction Velocity (m/s)',
                                             shape_labs = c('Mine','Erik','V Thresh','ExTrap'))

```

```{r reactiontanvelalgoplot1, echo = FALSE, warning = FALSE, fig.width=12, fig.height=5, fig.cap = 'Reaction Velocity Algorithm method.'}

plot_grid(reaction_tanvel_algo[['pref']]+theme(legend.position = 'none')+scale_y_continuous(breaks = seq(0,.036,.004), limits = c(-.001,.036)),
          reaction_tanvel_algo[['smallt']]+theme(legend.position = 'none')+scale_y_continuous(breaks = seq(0,.036,.004), limits = c(-.001,.036)),
          reaction_tanvel_algo[['pilot']]+theme(legend.position = 'none')+scale_y_continuous(breaks = seq(0,.036,.004), limits = c(-.001,.036)),
          get_legend(reaction_tanvel_algo[['pref']]),
          nrow = 1,
          rel_widths = c(1,1,1,.2),
          align = 'vh',
          labels = c('2a','2b','2c',''))
```

## Reaction Time Percent

```{r, echo = FALSE}
prefpilot$reaction_tanv_perc = prefpilot$reaction_tanv/prefpilot$movedur

prefdata$reaction_tanv_perc = prefdata$reaction_tanv/prefdata$movedur
smalltdata$reaction_tanv_perc = smalltdata$reaction_tanv/smalltdata$movedur
pilotdata$reaction_tanv_perc = pilotdata$reaction_tanv/pilotdata$movedur

react_lm_all = cftest(lmer(reaction_tanv_perc ~ factor(targetnum) + eff_mass +  (1|subj) + (1|exp),data=prefpilot))
react_lm_pref = cftest(lmer(reaction_tanv_perc ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='pref')))
react_lm_pilot = cftest(lmer(reaction_tanv_perc ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='pilot')))
react_lm_smallt = cftest(lmer(reaction_tanv_perc ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='smallt')))

react_p_table = rbind(c('Circle',formatC(react_lm_pref$test$coefficients[5],format = 'e', digits = 3),
                        formatC(react_lm_pref$test$pvalues[5],format = 'e', digits = 3),
                        formatC(react_lm_pref$test$sigma[5],format = 'e', digits = 3)),
                      c('Pilot',formatC(react_lm_pilot$test$coefficients[5],format = 'e', digits = 3),
                        formatC(react_lm_pilot$test$pvalues[5],format = 'e', digits = 3),
                        formatC(react_lm_pilot$test$sigma[5],format = 'e', digits = 3)),
                      c('Arc',formatC(react_lm_smallt$test$coefficients[5],format = 'e', digits = 3),
                        formatC(react_lm_smallt$test$pvalues[5],format = 'e', digits = 3),
                        formatC(react_lm_smallt$test$sigma[5],format = 'e', digits = 3)),
                      c('All',formatC(react_lm_all$test$coefficients[5],format = 'e', digits = 3),
                        formatC(react_lm_all$test$pvalues[5],format = 'e', digits = 3),
                        formatC(react_lm_all$test$sigma[5],format = 'e', digits = 3)))
colnames(react_p_table) = c('Reaction Time %','Linear Estimate','P-Value','Std Error')
kable(react_p_table, caption = 'Reaction Time % linear models.')

react_pref <- aggregate(reaction_tanv_perc ~ eff_mass,prefdata,mean)$reaction_tanv_perc
react_arct <- aggregate(reaction_tanv_perc ~ eff_mass,smalltdata,mean)$reaction_tanv_perc
react_pilo <- aggregate(reaction_tanv_perc ~ eff_mass,pilotdata,mean)$reaction_tanv_perc

react_pref_se <- aggregate(reaction_tanv_perc ~ eff_mass,prefdata,sd)$reaction_tanv_perc/sqrt(12)
react_arct_se <- aggregate(reaction_tanv_perc ~ eff_mass,smalltdata,sd)$reaction_tanv_perc/sqrt(12)
react_pilo_se <- aggregate(reaction_tanv_perc ~ eff_mass,pilotdata,sd)$reaction_tanv_perc/sqrt(18)

react_time_avg <- round(cbind(react_pref,react_arct,react_pilo),digits=3)
react_time_se <- round(cbind(react_pref_se,react_arct_se,react_pilo_se),digits=3)
react_time_df = matrix(,nrow = 4, ncol = 3)
for (rows in c(1:4)){
  for (cols in c(1:3)){
    react_time_df[rows,cols] = paste(react_time_avg[rows,cols],'±',react_time_se[rows,cols],sep='')
  }
}

react_time <- cbind(c(2.5,3.8,4.7,6.1),react_time_df)
colnames(react_time) <- c('Effective Mass (kg)','2a','2b','2c')
kable(react_time, caption = 'Reaction % time average values, NO propogated error ALL AVG (s)')

kable(avg_table_func_avgavg(prefdata,smalltdata,pilotdata,'reaction_tanv_perc'),caption = 'Reaction Time percent average values (s). Mean = mean of subject means. SE = SE of subject means.')
  
kable(avg_table_func_se_prop(prefdata,smalltdata,pilotdata,'reaction_tanv_perc'),caption = 'Reaction time percent NORM average values with PROPGATED ERROR (s)')

```

`r mass_exp_int_stringgen(prefpilot,'reaction_tanv_perc','reaction_time')`

```{r Reacttimepercbyexperiment, echo = FALSE, warning = FALSE, fig.width=12, fig.height=8, fig.cap = 'Reaction Time by experiment.'}
Reacttime_perc_by_experiment <- all_exp_avg_plot_addmass('reaction_tanv_perc',prefdata,smalltdata,pilotdata,ylab = 'Reaction Time Perc (% of Movedur)')
Reacttime_perc_by_experiment+theme(text = element_text(size = 18))
```

## Endpoint Error
```{r, echo = FALSE}

miss_dist_lm_all = cftest(lmer(miss_dist ~ factor(targetnum) + eff_mass +  (1|subj) + (1|exp),data=prefpilot))
miss_dist_lm_pref = cftest(lmer(miss_dist ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='pref')))
miss_dist_lm_pilot = cftest(lmer(miss_dist ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='pilot')))
miss_dist_lm_smallt = cftest(lmer(miss_dist ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='smallt')))

miss_dist_p_table = rbind(c('Circle',formatC(miss_dist_lm_pref$test$coefficients[5],format = 'e', digits = 3),
                            formatC(miss_dist_lm_pref$test$pvalues[5],format = 'e', digits = 3),
                            formatC(miss_dist_lm_pref$test$sigma[5],format = 'e', digits = 3)),
                          c('Pilot',formatC(miss_dist_lm_pilot$test$coefficients[5],format = 'e', digits = 3),
                            formatC(miss_dist_lm_pilot$test$pvalues[5],format = 'e', digits = 3),
                            formatC(miss_dist_lm_pilot$test$sigma[5],format = 'e', digits = 3)),
                          c('Arc',formatC(miss_dist_lm_smallt$test$coefficients[5],format = 'e', digits = 3),
                            formatC(miss_dist_lm_smallt$test$pvalues[5],format = 'e', digits = 3),
                            formatC(miss_dist_lm_smallt$test$sigma[5],format = 'e', digits = 3)),
                          c('All',formatC(miss_dist_lm_all$test$coefficients[5],format = 'e', digits = 3),
                            formatC(miss_dist_lm_all$test$pvalues[5],format = 'e', digits = 3),
                            formatC(miss_dist_lm_all$test$sigma[5],format = 'e', digits = 3)))
colnames(miss_dist_p_table) = c('Miss Distance','Linear Estimate','P-Value','Std Error')
kable(miss_dist_p_table, caption = 'Miss Distance linear models.')

miss_dist_pref <- aggregate(miss_dist ~ eff_mass,prefdata,mean)$miss_dist*100
miss_dist_arct <- aggregate(miss_dist ~ eff_mass,smalltdata,mean)$miss_dist*100
miss_dist_pilo <- aggregate(miss_dist ~ eff_mass,pilotdata,mean)$miss_dist*100

miss_dist_pref_se <- aggregate(miss_dist ~ eff_mass,prefdata,sd)$miss_dist*100/sqrt(12)
miss_dist_arct_se <- aggregate(miss_dist ~ eff_mass,smalltdata,sd)$miss_dist*100/sqrt(12)
miss_dist_pilo_se <- aggregate(miss_dist ~ eff_mass,pilotdata,sd)$miss_dist*100/sqrt(18)

miss_dist_time_avg <- round(cbind(miss_dist_pref,miss_dist_arct,miss_dist_pilo),digits=3)
miss_dist_time_se <- round(cbind(miss_dist_pref_se,miss_dist_arct_se,miss_dist_pilo_se),digits=3)
miss_dist_time_df = matrix(,nrow = 4, ncol = 3)
for (rows in c(1:4)){
  for (cols in c(1:3)){
    miss_dist_time_df[rows,cols] = paste(miss_dist_time_avg[rows,cols],'±',miss_dist_time_se[rows,cols],sep='')
  }
}

miss_dist_time <- cbind(c(2.5,3.8,4.7,6.1),miss_dist_time_df)
colnames(miss_dist_time) <- c('Effective Mass (kg)','2a','2b','2c')
kable(miss_dist_time, caption = 'Miss Distance average values, NO propogated error ALL AVG  (cm)')

temp_pref <- prefdata
temp_pref$miss_dist = temp_pref$miss_dist*100
temp_smallt <- smalltdata
temp_smallt$miss_dist = temp_smallt$miss_dist*100
temp_pilot <- pilotdata
temp_pilot$miss_dist = temp_pilot$miss_dist*100

kable(avg_table_func_avgavg(prefdata,smalltdata,pilotdata,'miss_dist'),caption = 'Miss Distance average values (cm). Mean = mean of subject means. SE = SE of subject means.')
  
kable(avg_table_func_se_prop(temp_pref,temp_smallt,temp_pilot,'miss_dist'),caption = 'Miss Distance average values with PROPGATED ERROR (cm)')

```

`r mass_exp_int_stringgen(prefpilot,'miss_dist','endpoint error')`

```{r missdistexperiment, echo = FALSE, warning = FALSE, fig.width=12, fig.height=8, fig.cap = 'Miss Distance (cm) by experiment.'}
pilotdata[,'miss_dist'] <- pilotdata[,'miss_dist']-.1
miss_dist_by_experiment <- all_exp_avg_plot_addmass('miss_dist',
                                            prefdata,
                                            smalltdata,
                                            pilotdata,
                                            ylab = 'Miss Distance (m)')
pilotdata[,'miss_dist'] <- pilotdata[,'miss_dist']+.1
miss_dist_by_experiment+theme(text = element_text(size = 18))
```


```{r missdist_normbyexperiment, echo = FALSE, warning = FALSE, fig.width=12, fig.height=8, fig.cap = 'Movement Duration by experiment.'}

Miss_dist_norm_by_experiment <- all_exp_avg_plot_addmass('miss_dist_norm',prefdata,smalltdata,pilotdata,ylab = 'Miss Distance Normalized (m)')
  
Miss_dist_norm_by_experiment+theme(text = element_text(size = 18))

setwd(pref_plots_dir)
if (save_plots){
  ggsave('miss_dist_norm_by_experiment.pdf',plot=Miss_dist_norm_by_experiment+theme(text = element_text(size = 18)),width=12,height=8, useDingbats = FALSE)
}

```

### Endpoint Error Norm
```{r, echo = FALSE}
miss_dist_norm_lm_all = cftest(lmer(miss_dist_norm ~ factor(targetnum) + eff_mass +  (1|subj) + (1|exp),data=prefpilot))
miss_dist_norm_lm_pref = cftest(lmer(miss_dist_norm ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='pref')))
miss_dist_norm_lm_pilot = cftest(lmer(miss_dist_norm ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='pilot')))
miss_dist_norm_lm_smallt = cftest(lmer(miss_dist_norm ~ factor(targetnum) + eff_mass +  (1|subj),data=filter(prefpilot,exp=='smallt')))

miss_dist_norm_p_table = rbind(c('Circle',formatC(miss_dist_norm_lm_pref$test$coefficients[5],format = 'e', digits = 3),
                            formatC(miss_dist_norm_lm_pref$test$pvalues[5],format = 'e', digits = 3),
                            formatC(miss_dist_norm_lm_pref$test$sigma[5],format = 'e', digits = 3)),
                          c('Pilot',formatC(miss_dist_norm_lm_pilot$test$coefficients[5],format = 'e', digits = 3),
                            formatC(miss_dist_norm_lm_pilot$test$pvalues[5],format = 'e', digits = 3),
                            formatC(miss_dist_norm_lm_pilot$test$sigma[5],format = 'e', digits = 3)),
                          c('Arc',formatC(miss_dist_norm_lm_smallt$test$coefficients[5],format = 'e', digits = 3),
                            formatC(miss_dist_norm_lm_smallt$test$pvalues[5],format = 'e', digits = 3),
                            formatC(miss_dist_norm_lm_smallt$test$sigma[5],format = 'e', digits = 3)),
                          c('All',formatC(miss_dist_norm_lm_all$test$coefficients[5],format = 'e', digits = 3),
                            formatC(miss_dist_norm_lm_all$test$pvalues[5],format = 'e', digits = 3),
                            formatC(miss_dist_norm_lm_all$test$sigma[5],format = 'e', digits = 3)))
colnames(miss_dist_norm_p_table) = c('Miss Distance Norm','Linear Estimate','P-Value','Std Error')
kable(miss_dist_norm_p_table, caption = 'Miss Distance Norm linear models.')

miss_dist_norm_pref <- aggregate(miss_dist_norm ~ eff_mass,prefdata,mean)$miss_dist_norm*100
miss_dist_norm_arct <- aggregate(miss_dist_norm ~ eff_mass,smalltdata,mean)$miss_dist_norm*100
miss_dist_norm_pilo <- aggregate(miss_dist_norm ~ eff_mass,pilotdata,mean)$miss_dist_norm*100

miss_dist_norm_pref_se <- aggregate(miss_dist_norm ~ eff_mass,prefdata,sd)$miss_dist_norm*100/sqrt(12)
miss_dist_norm_arct_se <- aggregate(miss_dist_norm ~ eff_mass,smalltdata,sd)$miss_dist_norm*100/sqrt(12)
miss_dist_norm_pilo_se <- aggregate(miss_dist_norm ~ eff_mass,pilotdata,sd)$miss_dist_norm*100/sqrt(18)

miss_dist_norm_time_avg <- round(cbind(miss_dist_norm_pref,miss_dist_norm_arct,miss_dist_norm_pilo),digits=3)
miss_dist_norm_time_se <- round(cbind(miss_dist_norm_pref_se,miss_dist_norm_arct_se,miss_dist_norm_pilo_se),digits=3)
miss_dist_norm_time_df = matrix(,nrow = 4, ncol = 3)
for (rows in c(1:4)){
  for (cols in c(1:3)){
    miss_dist_norm_time_df[rows,cols] = paste(miss_dist_norm_time_avg[rows,cols],'±',miss_dist_norm_time_se[rows,cols],sep='')
  }
}

miss_dist_norm_time <- cbind(c(2.5,3.8,4.7,6.1),miss_dist_norm_time_df)
colnames(miss_dist_norm_time) <- c('Effective Mass (kg)','2a','2b','2c')
kable(miss_dist_norm_time, caption = 'Miss Distance Norm average values, NO propogated error ALL AVG (m)')


temp_pref <- prefdata
temp_pref$miss_dist_norm = temp_pref$miss_dist_norm*100
temp_smallt <- smalltdata
temp_smallt$miss_dist_norm = temp_smallt$miss_dist_norm*100
temp_pilot <- pilotdata
temp_pilot$miss_dist_norm = temp_pilot$miss_dist_norm*100

kable(avg_table_func_avgavg(prefdata,smalltdata,pilotdata,'miss_dist_norm'),caption = 'Miss Distance NORM average values (cm). Mean = mean of subject means. SE = SE of subject means.')

kable(avg_table_func_se_prop(temp_pref,temp_smallt,temp_pilot,'miss_dist_norm'),caption = 'Miss Distance NORM average values with PROPGATED ERROR (cm)')
```

`r mass_exp_int_stringgen(prefpilot,'miss_dist_norm','endpoint error')`

```{r missdistexperimentnorm, echo = FALSE, warning = FALSE, fig.width=12, fig.height=8, fig.cap = 'Miss Distance Norm (cm) by experiment.'}
Miss_dist_norm_by_experiment+theme(text = element_text(size = 18))
```


## Angular Variance
```{r, echo = FALSE}
# This is similar to previous chunks, except we need to calculate variance first.
a = aggregate(missangle ~ subj + eff_mass,prefdata,var)
b = aggregate(movedur ~ subj + eff_mass,prefdata,mean)
c = data.frame(cbind(a$subj,a$eff_mass,b$movedur,a$missangle))
colnames(c) = c('subj','eff_mass','movedur','missangle')
c$exp = 'pref'
miss_var_pref = c

a = aggregate(missangle ~ subj + eff_mass,smalltdata,var)
b = aggregate(movedur ~ subj + eff_mass,smalltdata,mean)
c = data.frame(cbind(a$subj,a$eff_mass,b$movedur,a$missangle))
colnames(c) = c('subj','eff_mass','movedur','missangle')
c$exp = 'smallt'
miss_var_smallt = c

a = aggregate(missangle ~ subj + eff_mass,pilotdata,var)
b = aggregate(movedur ~ subj + eff_mass,pilotdata,mean)
c = data.frame(cbind(a$subj,a$eff_mass,b$movedur,a$missangle))
colnames(c) = c('subj','eff_mass','movedur','missangle')
c$exp = 'pilot'
miss_var_pilot = c

add_norm_var <- function(data, variables){
  # Adds normalized values for a metric
  for (vari in variables){
    zero_vals = data[data$eff_mass == min(data$eff_mass),]
    for (k in 1:length(data$subj)){
      data[k,paste(vari,'_norm',sep='')] = data[k,vari]/zero_vals[zero_vals$subj == data[k,'subj'],vari]
    }
  }
  return(data)
}

miss_var_pref <- add_norm_var(miss_var_pref,c('missangle'))
miss_var_smallt <- add_norm_var(miss_var_smallt,c('missangle'))
miss_var_pilot <- add_norm_var(miss_var_pilot,c('missangle'))

# Combine the data sets
var_data = rbind(miss_var_pref,miss_var_smallt,miss_var_pilot)
var_data$exp = factor(var_data$exp, levels = c('pref','smallt','pilot'))

# Do linear models and tables like previous sections.
missangle_lm_all = cftest(lmer(missangle ~ eff_mass +  (1|subj) + (1|exp),data=var_data))
missangle_lm_pref = cftest(lmer(missangle ~ eff_mass +  (1|subj),data=filter(var_data,exp=='pref')))
missangle_lm_pilot = cftest(lmer(missangle ~ eff_mass +  (1|subj),data=filter(var_data,exp=='pilot')))
missangle_lm_smallt = cftest(lmer(missangle ~ eff_mass +  (1|subj),data=filter(var_data,exp=='smallt')))

missangle_p_table = rbind(c('Circle',formatC(missangle_lm_pref$test$coefficients[2],format = 'e', digits = 3),
                            formatC(missangle_lm_pref$test$pvalues[2],format = 'e', digits = 3),
                            formatC(missangle_lm_pref$test$sigma[2],format = 'e', digits = 3)),
                          c('Pilot',formatC(missangle_lm_pilot$test$coefficients[2],format = 'e', digits = 3),
                            formatC(missangle_lm_pilot$test$pvalues[2],format = 'e', digits = 3),
                            formatC(missangle_lm_pilot$test$sigma[2],format = 'e', digits = 3)),
                          c('Arc',formatC(missangle_lm_smallt$test$coefficients[2],format = 'e', digits = 3),
                            formatC(missangle_lm_smallt$test$pvalues[2],format = 'e', digits = 3),
                            formatC(missangle_lm_smallt$test$sigma[2],format = 'e', digits = 3)),
                          c('All',formatC(missangle_lm_all$test$coefficients[2],format = 'e', digits = 3),
                            formatC(missangle_lm_all$test$pvalues[2],format = 'e', digits = 3),
                            formatC(missangle_lm_all$test$sigma[2],format = 'e', digits = 3)))
colnames(missangle_p_table) = c('Miss Distance','Linear Estimate','P-Value','Std Error')
kable(missangle_p_table, caption = 'Miss Distance linear models.')

missangle_pref <- aggregate(missangle ~ eff_mass,filter(var_data,exp=='pref'),mean)$missangle
missangle_arct <- aggregate(missangle ~ eff_mass,filter(var_data,exp=='smallt'),mean)$missangle
missangle_pilo <- aggregate(missangle ~ eff_mass,filter(var_data,exp=='pilot'),mean)$missangle

missangle_pref_se <- aggregate(missangle ~ eff_mass,filter(var_data,exp=='pref'),sd)$missangle/sqrt(12)
missangle_arct_se <- aggregate(missangle ~ eff_mass,filter(var_data,exp=='smallt'),sd)$missangle/sqrt(12)
missangle_pilo_se <- aggregate(missangle ~ eff_mass,filter(var_data,exp=='pilot'),sd)$missangle/sqrt(18)

missangle_time_avg <- round(cbind(missangle_pref,missangle_arct,missangle_pilo),digits=3)
missangle_time_se <- round(cbind(missangle_pref_se,missangle_arct_se,missangle_pilo_se),digits=3)
missangle_time_df = matrix(,nrow = 4, ncol = 3)

for (rows in c(1:4)){
  for (cols in c(1:3)){
    missangle_time_df[rows,cols] = paste(missangle_time_avg[rows,cols],'±',missangle_time_se[rows,cols],sep='')
  }
}

missangle_time <- cbind(c(2.5,3.8,4.7,6.1),missangle_time_df)
colnames(missangle_time) <- c('Effective Mass (kg)','2a','2b','2c')
kable(missangle_time, caption = 'Miss Angle Variance average values (deg^2)')

```

`r mass_exp_int_stringgen(var_data,'missangle','miss angle variance')`

```{r missanglebyexperiement1, echo = FALSE, warning = FALSE, fig.width=12, fig.height=8, fig.cap = 'Miss Angle Variance (deg^2) by experiment.'}
  missangle_by_experiement+theme(text = element_text(size = 18))
```


## Radial Variance
```{r, echo = FALSE}

a = aggregate(miss_rad ~ subj + eff_mass,prefdata,var)
b = aggregate(movedur ~ subj + eff_mass,prefdata,mean)
c = data.frame(cbind(a$subj,a$eff_mass,b$movedur,a$miss_rad))
colnames(c) = c('subj','eff_mass','movedur','miss_rad')
c$exp = 'pref'
miss_var_pref = c

a = aggregate(miss_rad ~ subj + eff_mass,smalltdata,var)
b = aggregate(movedur ~ subj + eff_mass,smalltdata,mean)
c = data.frame(cbind(a$subj,a$eff_mass,b$movedur,a$miss_rad))
colnames(c) = c('subj','eff_mass','movedur','miss_rad')
c$exp = 'smallt'
miss_var_smallt = c

a = aggregate(miss_rad ~ subj + eff_mass,pilotdata,var)
b = aggregate(movedur ~ subj + eff_mass,pilotdata,mean)
c = data.frame(cbind(a$subj,a$eff_mass,b$movedur,a$miss_rad))
colnames(c) = c('subj','eff_mass','movedur','miss_rad')
c$exp = 'pilot'
miss_var_pilot = c

miss_var_pref <- add_norm_var(miss_var_pref,c('miss_rad'))
miss_var_smallt <- add_norm_var(miss_var_smallt,c('miss_rad'))
miss_var_pilot <- add_norm_var(miss_var_pilot,c('miss_rad'))

var_data = rbind(miss_var_pref,miss_var_smallt,miss_var_pilot)
var_data$miss_rad = var_data$miss_rad*(100^2)
var_data$exp = factor(var_data$exp, levels = c('pref','smallt','pilot'))

miss_rad_lm_all = cftest(lmer(miss_rad ~ eff_mass +  (1|subj) + (1|exp),data=var_data))
miss_rad_lm_pref = cftest(lmer(miss_rad ~ eff_mass +  (1|subj),data=filter(var_data,exp=='pref')))
miss_rad_lm_pilot = cftest(lmer(miss_rad ~ eff_mass +  (1|subj),data=filter(var_data,exp=='pilot')))
miss_rad_lm_smallt = cftest(lmer(miss_rad ~ eff_mass +  (1|subj),data=filter(var_data,exp=='smallt')))

miss_rad_p_table = rbind(c('Circle',formatC(miss_rad_lm_pref$test$coefficients[2],format = 'e', digits = 3),
                            formatC(miss_rad_lm_pref$test$pvalues[2],format = 'e', digits = 3),
                            formatC(miss_rad_lm_pref$test$sigma[2],format = 'e', digits = 3)),
                          c('Pilot',formatC(miss_rad_lm_pilot$test$coefficients[2],format = 'e', digits = 3),
                            formatC(miss_rad_lm_pilot$test$pvalues[2],format = 'e', digits = 3),
                            formatC(miss_rad_lm_pilot$test$sigma[2],format = 'e', digits = 3)),
                          c('Arc',formatC(miss_rad_lm_smallt$test$coefficients[2],format = 'e', digits = 3),
                            formatC(miss_rad_lm_smallt$test$pvalues[2],format = 'e', digits = 3),
                            formatC(miss_rad_lm_smallt$test$sigma[2],format = 'e', digits = 3)),
                          c('All',formatC(miss_rad_lm_all$test$coefficients[2],format = 'e', digits = 3),
                            formatC(miss_rad_lm_all$test$pvalues[2],format = 'e', digits = 3),
                            formatC(miss_rad_lm_all$test$sigma[2],format = 'e', digits = 3)))
colnames(miss_rad_p_table) = c('Miss Distance','Linear Estimate','P-Value','Std Error')
kable(miss_rad_p_table, caption = 'Miss Distance Radial Variance (cm^2) linear models.')

miss_rad_pref <- aggregate(miss_rad ~ eff_mass,filter(var_data,exp=='pref'),mean)$miss_rad
miss_rad_arct <- aggregate(miss_rad ~ eff_mass,filter(var_data,exp=='smallt'),mean)$miss_rad
miss_rad_pilo <- aggregate(miss_rad ~ eff_mass,filter(var_data,exp=='pilot'),mean)$miss_rad

miss_rad_pref_se <- aggregate(miss_rad ~ eff_mass,filter(var_data,exp=='pref'),sd)$miss_rad/sqrt(12)
miss_rad_arct_se <- aggregate(miss_rad ~ eff_mass,filter(var_data,exp=='smallt'),sd)$miss_rad/sqrt(12)
miss_rad_pilo_se <- aggregate(miss_rad ~ eff_mass,filter(var_data,exp=='pilot'),sd)$miss_rad/sqrt(18)

miss_rad_time_avg <- round(cbind(miss_rad_pref,miss_rad_arct,miss_rad_pilo),digits=4)
miss_rad_time_se <- round(cbind(miss_rad_pref_se,miss_rad_arct_se,miss_rad_pilo_se),digits=4)
miss_rad_time_df = matrix(,nrow = 4, ncol = 3)

for (rows in c(1:4)){
  for (cols in c(1:3)){
    miss_rad_time_df[rows,cols] = paste(miss_rad_time_avg[rows,cols],'±',miss_rad_time_se[rows,cols],sep='')
  }
}

miss_rad_time <- cbind(c(2.5,3.8,4.7,6.1),miss_rad_time_df)
colnames(miss_rad_time) <- c('Effective Mass (kg)','2a','2b','2c')
kable(miss_rad_time, caption = 'Miss Radial Variance average values (cm^2)')

```

`r mass_exp_int_stringgen(var_data,'miss_rad','miss radial variance')`

```{r missradbyexperiement1, echo = FALSE, warning = FALSE, fig.width=12, fig.height=8, fig.cap = 'Miss Radial Variance by experiment.'}
  miss_rad_by_experiement
```

```{r, echo = FALSE, warning = FALSE}
miss_rad = list()
miss_rad[['pref']]<-vplot('miss_rad',filter(var_data,exp=='pref'))+
  labs(x='Effective Mass (kg)',y='Miss Radial Variance (cm^2)')+
  guides(fill=guide_legend(title="Effective\nMass (kg)"))+
  # theme_classic()
  theme(legend.position='none')+
  geom_hline(yintercept=mean(filter(filter(var_data,exp=='pref'),eff_mass==2.506)$miss_rad),linetype='dashed',size=.5)

miss_rad[['pilot']]<-vplot('miss_rad',filter(var_data,exp=='pilot'))+
  labs(x='Effective Mass (kg)',y='Miss Radial Variance (cm^2)')+
  guides(fill=guide_legend(title="Effective\nMass (kg)"))+
  theme(legend.position='none')+
  # theme_classic()
  geom_hline(yintercept=mean(filter(filter(var_data,exp=='pilot'),eff_mass==2.506)$miss_rad),linetype='dashed',size=.5)

miss_rad[['smallt']]<-vplot('miss_rad',filter(var_data,exp=='smallt'))+
  labs(x='Effective Mass (kg)',y='Miss Radial Variance (cm^2)')+
  guides(fill=guide_legend(title="Effective\nMass (kg)"))+
  # theme_classic()
  theme(legend.position='none')+
  geom_hline(yintercept=mean(filter(filter(var_data,exp=='smallt'),eff_mass==2.506)$miss_rad),linetype='dashed',size=.5)


miss_rad_nv = list()
miss_rad_nv[['pref']]<-avg_plot('miss_rad',filter(var_data,exp=='pref'),ylab = 'Miss Radial Variance (cm^2)',shape = 21)+theme(legend.position = 'none')
miss_rad_nv[['pilot']]<-avg_plot('miss_rad',filter(var_data,exp=='pilot'),ylab = 'Miss Radial Variance (cm^2)',shape = 22)+theme(legend.position = 'none')
miss_rad_nv[['smallt']]<-avg_plot('miss_rad',filter(var_data,exp=='smallt'),ylab = 'Miss Radial Variance (cm^2)',shape = 24)+theme(legend.position = 'none')

miss_rad_norm_nv = list()
miss_rad_norm_nv[['pref']]<-avg_plot('miss_rad_norm',filter(var_data,exp=='pref'),ylab = 'Miss Radial Variance Norm (cm^2)',shape = 21)+theme(legend.position = 'none')
miss_rad_norm_nv[['pilot']]<-avg_plot('miss_rad_norm',filter(var_data,exp=='pilot'),ylab = 'Miss Radial Variance Norm (cm^2)',shape = 22)+theme(legend.position = 'none')
miss_rad_norm_nv[['smallt']]<-avg_plot('miss_rad_norm',filter(var_data,exp=='smallt'),ylab = 'Miss Radial Variance Norm (cm^2)',shape = 24)+theme(legend.position = 'none')

```

```{r missrad1, echo = FALSE, warning = FALSE, fig.width=12, fig.height=8, fig.cap = 'Miss Rad Variance (cm^2) broken by experiment.'}
  plot_grid(miss_rad[['pref']],
            miss_rad[['smallt']],
            miss_rad[['pilot']],
            miss_rad_nv[['pref']],
            miss_rad_nv[['smallt']],
            miss_rad_nv[['pilot']],
            nrow = 2,
            align = 'vh',
            labels = c('2a','2b','2c','','',''))
```


## Resample Plots
```{r,echo=FALSE}

resample_plot <- function(resamp_data, 
                          n_timepoint,
                          subjn, 
                          ymax, 
                          spacing){
  # This function generates the average trajectory plots.
  
  if (subjn != 0){
    resamp_data2 = list()
    for (item in names(resamp_data)){
      if (item %in% c('SpmC1.abs','SpmC.abs','SpmM.abs','SpmT.abs','SpmS.abs')){
        resamp_data2[[item]] = resamp_data[[item]][resamp_data$SpmS.abs[1,] == subjn]
      } else {
        resamp_data2[[item]] = resamp_data[[item]][resamp_data$SpmS.abs[1,] == subjn,]
      }
    }
    resamp_data = resamp_data2
    rm(resamp_data2)
  }
  
  p <- matrix(0L,ncol=4,nrow=dim(resamp_data$SpmP.abs)[2])
  v <- p
  t <- p
  c_count = 0
  for (cond in c(8,5,3,0)){
    c_count = c_count + 1
    for (k in 1:dim(resamp_data$SpmP.abs)[2]){
      p[k,c_count] = mean(na.omit(resamp_data$SpmP.abs[resamp_data$SpmC.abs==cond,k]))
      v[k,c_count] = mean(na.omit(resamp_data$SpmV.abs[resamp_data$SpmC.abs==cond,k]))
      # t[k,c_count] = mean(resample_data_abs$SpmT.abs[resample_data_abs$SpmC.abs==c,k])
    }
  }
  resamp_abs <- as.data.frame(cbind(p[1:n_timepoint,],v[1:n_timepoint,],t[1:n_timepoint,]))
  colnames(resamp_abs) <- c('p0','p3','p5','p8','v0','v3','v5','v8')
  
  # Time to Velocity (abs)
  c_count=4
  str = 'abs_vel<-ggplot(data=resamp_abs)+'
  for (cond in c(0,3,5,8)){
    # str = paste(str,'geom_line(aes(x=(1:n_timepoint),y=v',cond,'),color=\'black\',size=vel_plot_line_size+1)+',sep='')
    str = paste(str,'geom_line(aes(x=(1:n_timepoint),y=v',cond,'),color=mass_colors[',c_count,'],size=vel_plot_line_size)+',sep='')
    str = paste(str,'geom_point(aes(x=which.max(v',cond,'),y=v',cond,'[which.max(v',cond,')]),color=\'black\',size=vel_plot_point_size+1)+',sep='')
    str = paste(str,'geom_point(aes(x=which.max(v',cond,'),y=v',cond,'[which.max(v',cond,')]),color=mass_colors[',c_count,'],size=vel_plot_point_size)+',sep='')
    c_count = c_count-1
  }
  str = paste(str,'labs(x=\'Time from Target Show (s)\',y=\'Radial Velocity (m/s)\')+
              scale_x_continuous(breaks = seq(0,n_timepoint,50),
                                labels=seq(0,n_timepoint,50)/200)')
  eval(parse(text = str))
  abs_vel = abs_vel+
    scale_y_continuous(limits = c(-.01,ymax),
                       breaks = c(seq(0, ymax, spacing)),
                       labels = c(seq(0, ymax, spacing)))+
    theme(legend.position='none')+
    theme(text              = element_text(color='black'),
          axis.text         = element_text(color='black'),
          axis.ticks        = element_line(color='black'),
          plot.title        = element_text(hjust = 0.5),
          axis.line         = element_line(color='black'))
  if (ymax == 0){
    ymax = max(max(resamp_abs$v0), max(resamp_abs$v3),  max(resamp_abs$v5), max(resamp_abs$v8))
    abs_vel = abs_vel+
      scale_y_continuous(limits = c(-.01,ymax),
                         breaks = c(seq(0, ymax, spacing)),
                         labels = c(seq(0, ymax, spacing)))
    
  }
  return(abs_vel)
}

resamp_plots = list()
resamp_plots[['pref']] <- resample_plot(resample_data_pref_abs, 
                                        250, 
                                        0,
                                        0.35,
                                        0.05)

resamp_plots[['pilot']] <- resample_plot(resample_data_pilot_abs,
                                        400, 
                                        0,
                                        0.35,
                                        0.05)+scale_y_continuous(breaks = seq(-.2,0.35,0.05), limits = c(-.2, 0.35))

resamp_plots[['smallt']] <- resample_plot(resample_data_smallt_abs,
                                        300, 
                                        0,
                                        0.35,
                                        0.05)


resamp_plots_RT = list()
resamp_plots_RT[['pref']] <- resample_plot(resample_data_pref_abs,
                                        250, 
                                        0,
                                        0.35,
                                        0.05)+
  scale_y_continuous(limits = c(-.001,0.005))+
  scale_x_continuous(limits = c(0, 50),
                     breaks = c(0,10,20,30,40,50),
                     labels = c(0,0.05,0.10,0.15,0.20,0.25))

resamp_plots_RT[['pilot']] <- resample_plot(resample_data_pilot_abs,
                                        250, 
                                        0,
                                        0.35,
                                        0.05)+
  scale_y_continuous(limits = c(-.001,0.005))+
  scale_x_continuous(limits = c(0, 50),
                     breaks = c(0,10,20,30,40,50),
                     labels = c(0,0.05,0.10,0.15,0.20,0.25))

resamp_plots_RT[['smallt']] <- resample_plot(resample_data_smallt_abs,
                                        250, 
                                        0,
                                        0.35,
                                        0.05)+
  scale_y_continuous(limits = c(-.001,0.005))+
  scale_x_continuous(limits = c(0, 50),
                     breaks = c(0,10,20,30,40,50),
                     labels = c(0,0.05,0.10,0.15,0.20,0.25))


# setwd(pref_plots_dir)
# if (save_plots){
#   ggsave('resamp_plot_pref.pdf', plot = resamp_plots[['pref']], useDingbats = FALSE)
#   ggsave('resamp_plot_pilot.pdf', plot = resamp_plots[['pilot']], useDingbats = FALSE)
#   ggsave('resamp_plot_smallt.pdf', plot = resamp_plots[['smallt']], useDingbats = FALSE)
# }


```

```{r resampplots, echo = FALSE, warning = FALSE, fig.width=12, fig.height=5, fig.cap = 'Velocity trajectories by experiment.'}

#Group the plots
plot_grid(resamp_plots[['pref']],
          resamp_plots[['smallt']],
          resamp_plots[['pilot']],
          nrow = 1,
          labels = c('2a','2b','2c'))


plot_grid(resamp_plots_RT[['pref']],
          resamp_plots_RT[['smallt']],
          resamp_plots_RT[['pilot']],
          nrow = 1,
          labels = c('2a','2b','2c'))
```

### One Subject


```{r, echo=FALSE, warning = FALSE, message = FALSE}
# Create individual trajectory plots
resamp_plots_ind = list()
resamp_plots_RT_ind = list()
resamp_plots_ind[['pref']] = c()
resamp_plots_ind[['smallt']] = c()
resamp_plots_RT_ind[['pref']] = c()
resamp_plots_RT_ind[['smallt']] = c()

for (subj in 1:12){
  
  resamp_plots_ind[['pref']][[subj]] <- resample_plot(resample_data_pref_abs, 
                                                      250, 
                                                      subj,
                                                      0,
                                                      0.05)
  
  
  resamp_plots_ind[['smallt']][[subj]] <- resample_plot(resample_data_smallt_abs,
                                                    250, 
                                                    subj,
                                                    0,
                                                    0.05)
  
  
  
  resamp_plots_RT_ind[['pref']][[subj]] <- resamp_plots_ind[['pref']][[subj]]+
    scale_y_continuous(limits = c(-.001,0.005))+
    scale_x_continuous(limits = c(0, 50),
                       breaks = c(0,10,20,30,40,50),
                       labels = c(0,0.05,0.10,0.15,0.20,0.25))
  
  resamp_plots_RT_ind[['smallt']][[subj]] <- resamp_plots_ind[['smallt']][[subj]]+
    scale_y_continuous(limits = c(-.001,0.005))+
    scale_x_continuous(limits = c(0, 50),
                       breaks = c(0,10,20,30,40,50),
                       labels = c(0,0.05,0.10,0.15,0.20,0.25))
  
}

resamp_plots_ind[['pilot']] = c()
resamp_plots_RT_ind[['pilot']] = c()

for (subj in 1:18){
  resamp_plots_ind[['pilot']][[subj]] <- resample_plot(resample_data_pilot_abs,
                                                   250, 
                                                   subj,
                                                   0,
                                                   0.05)

  resamp_plots_RT_ind[['pilot']][[subj]] <- resamp_plots_ind[['pilot']][[subj]]+
    scale_y_continuous(limits = c(-.001,0.005))+
    scale_x_continuous(limits = c(0, 50),
                       breaks = c(0,10,20,30,40,50),
                       labels = c(0,0.05,0.10,0.15,0.20,0.25))
  
}

```

#### 2a

```{r, echo = FALSE, warning = FALSE, message = FALSE, fig.width = 9, fig.height = 9}

experi = 'pref'
plot_grid(resamp_plots_RT[[experi]]+labs(title = 'Group Average'),
          resamp_plots_RT_ind[[experi]][[1]]+labs(title = 'Subj = 1'),
          resamp_plots_RT_ind[[experi]][[2]]+labs(title = 'Subj = 2'),
          resamp_plots_RT_ind[[experi]][[3]]+labs(title = 'Subj = 3'),
          resamp_plots_RT_ind[[experi]][[4]]+labs(title = 'Subj = 4'),
          resamp_plots_RT_ind[[experi]][[5]]+labs(title = 'Subj = 5'),
          resamp_plots_RT_ind[[experi]][[6]]+labs(title = 'Subj = 6'),
          resamp_plots_RT_ind[[experi]][[7]]+labs(title = 'Subj = 7'),
          resamp_plots_RT_ind[[experi]][[8]]+labs(title = 'Subj = 8'))
```

#### 2b

```{r, echo = FALSE, warning = FALSE, message = FALSE, fig.width = 9, fig.height = 9}

experi = 'smallt'
plot_grid(resamp_plots_RT[[experi]]+labs(title = 'Group Average'),
          resamp_plots_RT_ind[[experi]][[1]]+labs(title = 'Subj = 1'),
          resamp_plots_RT_ind[[experi]][[2]]+labs(title = 'Subj = 2'),
          resamp_plots_RT_ind[[experi]][[3]]+labs(title = 'Subj = 3'),
          resamp_plots_RT_ind[[experi]][[4]]+labs(title = 'Subj = 4'),
          resamp_plots_RT_ind[[experi]][[5]]+labs(title = 'Subj = 5'),
          resamp_plots_RT_ind[[experi]][[6]]+labs(title = 'Subj = 6'),
          resamp_plots_RT_ind[[experi]][[7]]+labs(title = 'Subj = 7'),
          resamp_plots_RT_ind[[experi]][[8]]+labs(title = 'Subj = 8'))
```

#### 2c

```{r, echo = FALSE, warning = FALSE, message = FALSE, fig.width = 9, fig.height = 9}

experi = 'pilot'
plot_grid(resamp_plots_RT[[experi]]+labs(title = 'Group Average'),
          resamp_plots_RT_ind[[experi]][[1]]+labs(title = 'Subj = 1'),
          resamp_plots_RT_ind[[experi]][[2]]+labs(title = 'Subj = 2'),
          resamp_plots_RT_ind[[experi]][[3]]+labs(title = 'Subj = 3'),
          resamp_plots_RT_ind[[experi]][[4]]+labs(title = 'Subj = 4'),
          resamp_plots_RT_ind[[experi]][[5]]+labs(title = 'Subj = 5'),
          resamp_plots_RT_ind[[experi]][[6]]+labs(title = 'Subj = 6'),
          resamp_plots_RT_ind[[experi]][[7]]+labs(title = 'Subj = 7'),
          resamp_plots_RT_ind[[experi]][[8]]+labs(title = 'Subj = 8'),
          resamp_plots_RT_ind[[experi]][[9]]+labs(title = 'Subj = 9'),
          resamp_plots_RT_ind[[experi]][[10]]+labs(title = 'Subj = 10'),
          resamp_plots_RT_ind[[experi]][[11]]+labs(title = 'Subj = 11'),
          resamp_plots_RT_ind[[experi]][[12]]+labs(title = 'Subj = 12'))

```


## Resample Plots TANV

```{r,echo=FALSE}
# Same as the previous section, except plotting with tangential velocity.
resample_plot_TanV <- function(resamp_data, 
                          n_timepoint,
                          subjn,
                          ymax, 
                          spacing){
  # This function generates the average trajectory plots with tangential velocity..
  
  if (subjn != 0){
    resamp_data2 = list()
    for (item in names(resamp_data)){
      if (item %in% c('SpmC1.abs','SpmC.abs','SpmM.abs','SpmT.abs','SpmS.abs')){
        resamp_data2[[item]] = resamp_data[[item]][resamp_data$SpmS.abs[1,] == subjn]
      } else {
        resamp_data2[[item]] = resamp_data[[item]][resamp_data$SpmS.abs[1,] == subjn,]
      }
    }
    resamp_data = resamp_data2
    rm(resamp_data2)
  }
  
  p <- matrix(0L,ncol=4,nrow=dim(resamp_data$SpmP.abs)[2])
  v <- p
  t <- p
  c_count = 0
  for (cond in c(0,3,5,8)){
    c_count = c_count + 1
    for (k in 1:dim(resamp_data$SpmP.abs)[2]){
      # p[k,c_count] = mean(na.omit(resamp_data$SpmP.abs[resamp_data$SpmC.abs==cond,k]))
      # v[k,c_count] = mean(na.omit(resamp_data$SpmTanV.abs[resamp_data$SpmC.abs==cond,k]))
      p[k,c_count] = median(na.omit(resamp_data$SpmP.abs[resamp_data$SpmC.abs==cond,k]))
      v[k,c_count] = median(na.omit(resamp_data$SpmTanV.abs[resamp_data$SpmC.abs==cond,k]))
      # t[k,c_count] = mean(resample_data_abs$SpmT.abs[resample_data_abs$SpmC.abs==c,k])
    }
  }
  resamp_abs <- as.data.frame(cbind(p[1:n_timepoint,],v[1:n_timepoint,],t[1:n_timepoint,]))
  colnames(resamp_abs) <- c('p0','p3','p5','p8','v0','v3','v5','v8')
  
  # Time to Velocity (abs)
  c_count=4
  str = 'abs_vel<-ggplot(data=resamp_abs)+'
  for (cond in c(8,5,3,0)){
    # str = paste(str,'geom_line(aes(x=(1:n_timepoint),y=v',cond,'),color=\'black\',size=vel_plot_line_size+1)+',sep='')
    str = paste(str,'geom_line(aes(x=(1:n_timepoint),y=v',cond,'),color=mass_colors[',c_count,'],size=vel_plot_line_size)+',sep='')
    str = paste(str,'geom_point(aes(x=which.max(v',cond,'),y=v',cond,'[which.max(v',cond,')]),color=\'black\',size=vel_plot_point_size+1)+',sep='')
    str = paste(str,'geom_point(aes(x=which.max(v',cond,'),y=v',cond,'[which.max(v',cond,')]),color=mass_colors[',c_count,'],size=vel_plot_point_size)+',sep='')
    c_count = c_count-1
  }
  str = paste(str,'labs(x=\'Time from Target Show (s)\',y=\'Tangential Velocity (m/s)\')+
              scale_x_continuous(breaks = seq(0,n_timepoint,50),
                                labels=seq(0,n_timepoint,50)/200)')
  eval(parse(text = str))
  abs_vel = abs_vel+
    scale_y_continuous(limits = c(-.0001,ymax),
                       breaks = c(seq(0, ymax, spacing)),
                       labels = c(seq(0, ymax, spacing)))+
    theme(legend.position='none')+
    theme(text              = element_text(color='black'),
          axis.text         = element_text(color='black'),
          axis.ticks        = element_line(color='black'),
          plot.title        = element_text(hjust = 0.5),
          axis.line         = element_line(color='black'))
  if (ymax == 0){
    ymax = max(max(resamp_abs$v0), max(resamp_abs$v3),  max(resamp_abs$v5), max(resamp_abs$v8))
    abs_vel = abs_vel+
      scale_y_continuous(limits = c(-.0001,ymax),
                         breaks = c(seq(0, ymax, spacing)),
                         labels = c(seq(0, ymax, spacing)))
    
  }
  return(abs_vel)
}

resamp_plots_TanV = list()
resamp_plots_TanV[['pref']] <- resample_plot_TanV(resample_data_pref_abs, 
                                        250, 
                                        0,
                                        0.35,
                                        0.05)

resamp_plots_TanV[['pilot']] <- resample_plot_TanV(resample_data_pilot_abs,
                                         250, 
                                         0,
                                         0.35,
                                         0.05)

resamp_plots_TanV[['smallt']] <- resample_plot_TanV(resample_data_smallt_abs,
                                          250, 
                                          0,
                                          0.35,
                                          0.05)


resamp_plots_TanV_RT = list()
resamp_plots_TanV_RT[['pref']] <- resample_plot_TanV(resample_data_pref_abs,
                                           250, 
                                           0,
                                           0.35,
                                           0.05)+
  scale_y_continuous(limits = c(-.001,0.005))+
  scale_x_continuous(limits = c(10, 40),
                     breaks = c(10,20,30,40),
                     labels = c(0.05,0.10,0.15,0.20))

resamp_plots_TanV_RT[['pilot']] <- resample_plot_TanV(resample_data_pilot_abs,
                                            250, 
                                            0,
                                            0.35,
                                            0.05)+
  scale_y_continuous(limits = c(-.001,0.005))+
  scale_x_continuous(limits = c(20, 50),
                     breaks = c(20,30,40,50),
                     labels = c(0.10,0.15,0.20,0.25))

resamp_plots_TanV_RT[['smallt']] <- resample_plot_TanV(resample_data_smallt_abs,
                                             250, 
                                             0,
                                             0.35,
                                             0.05)+
  scale_y_continuous(limits = c(-.001,0.005))+
  scale_x_continuous(limits = c(20, 50),
                     breaks = c(20,30,40,50),
                     labels = c(0.10,0.15,0.20,0.25))


# setwd(pref_plots_dir)
# if (save_plots){
#   ggsave('resamp_plot_pref.pdf', plot = resamp_plots_TanV[['pref']], useDingbats = FALSE)
#   ggsave('resamp_plot_pilot.pdf', plot = resamp_plots_TanV[['pilot']], useDingbats = FALSE)
#   ggsave('resamp_plot_smallt.pdf', plot = resamp_plots_TanV[['smallt']], useDingbats = FALSE)
# }


```

```{r resampplotstanv, echo = FALSE, warning = FALSE, fig.width=12, fig.height=5, fig.cap = 'Velocity trajectories by experiment.'}

plot_grid(resamp_plots_TanV[['pref']],
          resamp_plots_TanV[['smallt']],
          resamp_plots_TanV[['pilot']],
          nrow = 1,
          labels = c('2a','2b','2c'))


plot_grid(resamp_plots_TanV_RT[['pref']],
          resamp_plots_TanV_RT[['smallt']],
          resamp_plots_TanV_RT[['pilot']],
          nrow = 1,
          labels = c('2a','2b','2c'))
```

### One Subject

```{r, echo=FALSE, warning = FALSE, message = FALSE}

resamp_plots_TanV_ind = list()
resamp_plots_TanV_RT_ind = list()
resamp_plots_TanV_ind[['pref']] = c()
resamp_plots_TanV_ind[['smallt']] = c()
resamp_plots_TanV_RT_ind[['pref']] = c()
resamp_plots_TanV_RT_ind[['smallt']] = c()

for (subj in 1:12){
  
  resamp_plots_TanV_ind[['pref']][[subj]] <- resample_plot_TanV(resample_data_pref_abs, 
                                                      250, 
                                                      subj,
                                                      0,
                                                      0.05)
  
  
  resamp_plots_TanV_ind[['smallt']][[subj]] <- resample_plot_TanV(resample_data_smallt_abs,
                                                        250, 
                                                        subj,
                                                        0,
                                                        0.05)
  
  
  
  resamp_plots_TanV_RT_ind[['pref']][[subj]] <- resamp_plots_TanV_ind[['pref']][[subj]]+
    scale_y_continuous(limits = c(-.001,0.005))+
  scale_x_continuous(limits = c(0, 50),
                     breaks = c(0,10,20,30,40,50),
                     labels = c(0,0.05,0.10,0.15,0.20,0.25))
  
  resamp_plots_TanV_RT_ind[['smallt']][[subj]] <- resamp_plots_TanV_ind[['smallt']][[subj]]+
    scale_y_continuous(limits = c(-.001,0.005))+
  scale_x_continuous(limits = c(0, 50),
                     breaks = c(0,10,20,30,40,50),
                     labels = c(0,0.05,0.10,0.15,0.20,0.25))
  
}

resamp_plots_TanV_ind[['pilot']] = c()
resamp_plots_TanV_RT_ind[['pilot']] = c()

for (subj in 1:18){
  resamp_plots_TanV_ind[['pilot']][[subj]] <- resample_plot_TanV(resample_data_pilot_abs,
                                                       250, 
                                                       subj,
                                                       0,
                                                       0.05)
  
  resamp_plots_TanV_RT_ind[['pilot']][[subj]] <- resamp_plots_TanV_ind[['pilot']][[subj]]+
    scale_y_continuous(limits = c(-.001,0.005))+
  scale_x_continuous(limits = c(0, 50),
                     breaks = c(0,10,20,30,40,50),
                     labels = c(0,0.05,0.10,0.15,0.20,0.25))
  
}

```

#### 2a

```{r, echo = FALSE, warning = FALSE, message = FALSE, fig.width = 9, fig.height = 9}

experi = 'pref'
plot_grid(resamp_plots_TanV_RT[[experi]]+labs(title = 'Group Average'),
          resamp_plots_TanV_RT_ind[[experi]][[1]]+labs(title = 'Subj = 1'),
          resamp_plots_TanV_RT_ind[[experi]][[2]]+labs(title = 'Subj = 2'),
          resamp_plots_TanV_RT_ind[[experi]][[3]]+labs(title = 'Subj = 3'),
          resamp_plots_TanV_RT_ind[[experi]][[4]]+labs(title = 'Subj = 4'),
          resamp_plots_TanV_RT_ind[[experi]][[5]]+labs(title = 'Subj = 5'),
          resamp_plots_TanV_RT_ind[[experi]][[6]]+labs(title = 'Subj = 6'),
          resamp_plots_TanV_RT_ind[[experi]][[7]]+labs(title = 'Subj = 7'),
          resamp_plots_TanV_RT_ind[[experi]][[8]]+labs(title = 'Subj = 8'))
```

#### 2b

```{r, echo = FALSE, warning = FALSE, message = FALSE, fig.width = 9, fig.height = 9}

experi = 'smallt'
plot_grid(resamp_plots_TanV_RT[[experi]]+labs(title = 'Group Average'),
          resamp_plots_TanV_RT_ind[[experi]][[1]]+labs(title = 'Subj = 1'),
          resamp_plots_TanV_RT_ind[[experi]][[2]]+labs(title = 'Subj = 2'),
          resamp_plots_TanV_RT_ind[[experi]][[3]]+labs(title = 'Subj = 3'),
          resamp_plots_TanV_RT_ind[[experi]][[4]]+labs(title = 'Subj = 4'),
          resamp_plots_TanV_RT_ind[[experi]][[5]]+labs(title = 'Subj = 5'),
          resamp_plots_TanV_RT_ind[[experi]][[6]]+labs(title = 'Subj = 6'),
          resamp_plots_TanV_RT_ind[[experi]][[7]]+labs(title = 'Subj = 7'),
          resamp_plots_TanV_RT_ind[[experi]][[8]]+labs(title = 'Subj = 8'))
```

#### 2c

```{r, echo = FALSE, warning = FALSE, message = FALSE, fig.width = 9, fig.height = 9}

experi = 'pilot'
plot_grid(resamp_plots_TanV_RT[[experi]]+labs(title = 'Group Average'),
          resamp_plots_TanV_RT_ind[[experi]][[1]]+labs(title = 'Subj = 1'),
          resamp_plots_TanV_RT_ind[[experi]][[2]]+labs(title = 'Subj = 2'),
          resamp_plots_TanV_RT_ind[[experi]][[3]]+labs(title = 'Subj = 3'),
          resamp_plots_TanV_RT_ind[[experi]][[4]]+labs(title = 'Subj = 4'),
          resamp_plots_TanV_RT_ind[[experi]][[5]]+labs(title = 'Subj = 5'),
          resamp_plots_TanV_RT_ind[[experi]][[6]]+labs(title = 'Subj = 6'),
          resamp_plots_TanV_RT_ind[[experi]][[7]]+labs(title = 'Subj = 7'),
          resamp_plots_TanV_RT_ind[[experi]][[8]]+labs(title = 'Subj = 8'),
          resamp_plots_TanV_RT_ind[[experi]][[9]]+labs(title = 'Subj = 9'),
          resamp_plots_TanV_RT_ind[[experi]][[10]]+labs(title = 'Subj = 10'),
          resamp_plots_TanV_RT_ind[[experi]][[11]]+labs(title = 'Subj = 11'),
          resamp_plots_TanV_RT_ind[[experi]][[12]]+labs(title = 'Subj = 12'))

```

## Resamp Compared
```{r, echo = FALSE, warning = FALSE, message = FALSE}
# Compare radial velocity to tangential velocity

plot_grid(resamp_plots[['pref']],resamp_plots_TanV[['pref']],
          resamp_plots[['smallt']],resamp_plots_TanV[['smallt']],
          resamp_plots[['pilot']],resamp_plots_TanV[['pilot']],
          nrow = 3,
          labels = c('2a','','2b','','2c',''))
```

Even though the preferred looks the same, just turns out the two velocity profiles are REALLY REALLY similar, but slightly different. This is shown in the following plot, that is zoomed into the peak velocities. 
```{r, echo = FALSE, warning = FALSE, message = FALSE}
# Zoomed in.
plot_grid(resamp_plots[['pref']]+scale_x_continuous(limits = c(120,130)),
          resamp_plots_TanV[['pref']]+scale_x_continuous(limits = c(120,130)))
```

```{r, echo = FALSE, warning = FALSE, message = FALSE}
# Only show right at reaction time.
plot_grid(resamp_plots_RT[['pref']],resamp_plots_TanV_RT[['pref']],
          resamp_plots_RT[['smallt']],resamp_plots_TanV_RT[['smallt']],
          resamp_plots_RT[['pilot']],resamp_plots_TanV_RT[['pilot']],
          nrow = 3,
          labels = c('2a','','2b','','2c',''))


```

## Preferred Experiment Grouped Plots

### Grouped
```{r,echo=FALSE,warning = FALSE, message = FALSE}
# This section groups all the preferred plots and saves it.
# The comments below are older version of the plot.

# resamp_group <- plot_grid(NULL,NULL,NULL,
#                           resamp_plots[['pref']],
#                           resamp_plots[['smallt']],
#                           resamp_plots[['pilot']],
#                           nrow = 2,
#                           ncol = 3,
#                           align = 'vh',
#                           rel_heights = c(.5,5),
#                           labels = c('Average Velocity Traces','','','A','B','C'))
# 
# pref_group <- plot_grid(NULL, NULL, NULL,
#                         Movedur_by_experiment+theme(legend.position = 'none'),
#                         Peakvel_by_experiment+theme(legend.position = 'none'),
#                         Reacttime_by_experiment+theme(legend.position = 'none'),
#                         NULL, NULL, NULL,
#                         Movedur_norm_by_experiment+theme(legend.position = 'none'),
#                         Peakvel_norm_by_experiment+theme(legend.position = 'none'),
#                         Reacttime_norm_by_experiment+theme(legend.position = 'none'),
#                         nrow=4,
#                         ncol = 3,
#                         align = 'vh',
#                         labels = c('Absolute','','','D','E','F','Normalized','','','G','H','I'),
#                         rel_heights = c(.5,5,.5,5))
# 
# pref_grouped <- plot_grid(resamp_group, 
#                           get_legend(Movedur_by_experiment+theme(legend.position = 'right')),
#                           pref_group,
#                           get_legend(Movedur_norm_by_experiment),
#                           ncol = 2,
#                           nrow = 2,
#                           rel_heights = c(1,2),
#                           rel_widths = c(1,.1))
# pref_grouped
# 
# setwd(pref_plots_dir)
# if (save_plots){
#   ggsave('Pref_results_grouped.pdf',plot=pref_grouped,width=10/.9,height=10, useDingbats = FALSE)
# }


resamp_group <- plot_grid(NULL,NULL,NULL,
                          resamp_plots[['pref']],
                          resamp_plots[['smallt']],
                          resamp_plots[['pilot']],
                          nrow = 2,
                          ncol = 3,
                          align = 'vh',
                          rel_heights = c(.5,5),
                          labels = c('Average Velocity Traces','','','A','B','C'))

resamp_group_RT <- plot_grid(NULL,NULL,NULL,
                          resamp_plots_TanV_RT[['pref']],
                          resamp_plots_TanV_RT[['smallt']],
                          resamp_plots_TanV_RT[['pilot']],
                          nrow = 2,
                          ncol = 3,
                          align = 'vh',
                          rel_heights = c(.5,5),
                          labels = c('Velocity Traces at RT','','','A','B','C'))

pref_group <- plot_grid(NULL, NULL, NULL,
                        Movedur_by_experiment+theme(legend.position = 'none'),
                        Peakvel_by_experiment+theme(legend.position = 'none'),
                        Reacttime_by_experiment+theme(legend.position = 'none'),
                        NULL, NULL, NULL,
                        Movedur_norm_by_experiment+theme(legend.position = 'none'),
                        Peakvel_norm_by_experiment+theme(legend.position = 'none'),
                        Reacttime_norm_by_experiment+theme(legend.position = 'none'),
                        nrow=4,
                        ncol = 3,
                        align = 'vh',
                        labels = c('Absolute','','','D','E','F','Normalized','','','G','H','I'),
                        rel_heights = c(.5,5,.5,5))

pref_grouped <- plot_grid(plot_grid(resamp_group,resamp_group_RT,nrow = 2),
                          get_legend(movedur[['pref']]+theme(legend.position = 'right')),
                          pref_group,
                          get_legend(Movedur_by_experiment),
                          ncol = 2,
                          nrow = 2,
                          rel_heights = c(2,2),
                          rel_widths = c(1,.1))

theme_set(theme_cowplot(font_size=12))

setwd(pref_plots_dir)
if (save_plots){
  ggsave('Pref_results_grouped.pdf',plot=pref_grouped,width=9/.9,height=12, useDingbats = FALSE)
}

```

```{r, echo = FALSE, warning = FALSE, message = FALSE, fig.width = 9/.9, fig.height = 12}

pref_grouped

```

# Metabolics Experiment
```{r, include = FALSE, warning=FALSE}
# This adds subject masses, net cost/gross cost, and factorizes some variables.
# =========================================================================

index = 1:8
values = c(125,156.199,194.7,129.8,173.8,159.7,136.4,127.6)
metdata$subjmass <- values[match(metdata$subj,index)]
mpdata$subjmass <- values[match(mpdata$subj,index)]

metdata_factor = metdata
metdata_factor$condition <- as.factor(metdata_factor$condition)

mpdata$netcost <- mpdata$movedur * mpdata$metpowernet
mpdata$grosscost <- mpdata$movedur * mpdata$metpowergross

mpdata <- filter(mpdata,metpowernet>0)
mpdata_factor <- mpdata
mpdata_factor$condition <- as.factor(mpdata_factor$condition)

# Create a table of effective masses.
tab = matrix(,nrow=4,ncol=1)
dcount = 0
for (data in c('pref')){#,'smallt','pilot')){
  dcount = dcount +1
  data_set = metdata
  ccount = 0
  for (c in c(1,2,3,4)){
  ccount = ccount + 1
    tab[ccount,dcount] = paste(mean(filter(data_set,condition == c)$eff_mass2),
                               '±',
                               sd(filter(data_set,condition == c)$eff_mass2)/sqrt(12))
  }
}

```

We filtered the metabolic data and removed any trial where the miss distance at endpoint was greater than 10 cm, the movement duration was less than 0.2 seconds, or the reaction time was greater than 0.50 s.This removed `r met_length-length(metdata$movedur)` out of `r met_length` original data points.

### Speed on speed
```{r, echo = FALSE, warning = FALSE, message = FALSE}
# See if speed was affected within each speed condition by mass, and output the stat output.
# The stat outputs aren't cleaned.
anova(lm(movedur ~ speed + eff_mass2 + (1|subj),data=metdata_factor))

cftest(lmer(movedur ~ speed + eff_mass2 + (1|subj),data=metdata_factor))

# Plot Movement duration by speed condition
byspeeddata <- summarySE(metdata, measurevar="movedur", groupvars=c("speed","eff_mass"))
g<-ggplot(byspeeddata, 
          aes(x=speed, y=movedur, colour=factor(eff_mass), group = factor(eff_mass))) +
  geom_errorbar(aes(ymin=movedur-se,ymax=movedur+se), width=.2, size = 1) + 
  geom_line(size = 1) + 
  geom_point(size = 4)+
  scale_color_manual(values = mass_colors)+
  # theme_classic()
  labs(x='Speed Condition', y = 'Movement Duration (s)', color = 'Effective\nMass (kg)')
g
```


## MP Gross
```{r, echo = FALSE, warning=FALSE}
# Stats on gross metabolic power. Prints anova, and lme on non transformed.
MP_gross_anova = anova(lm(metpowergross ~ movedur + effmass2 + movedur*effmass2 + (1|subject),mpdata))
MP_gross_lme = cftest(lmer(log(metpowergross) ~ log(movedur) + effmass2 + (1|subject),mpdata))
# Show linear model on log transformed metabolic power.
cftest(lmer(log(metpowergross) ~ log(movedur) + effmass2 + (1|subject),mpdata))

# Fit effort model to metabolic power gross with subject mass multipied by a.
MPGross_model_m=nls(metpowergross ~ a1*subjmass^a5 + 100*a2*(effmass2^a3)/(movedur^a4),
                    data=mpdata,
                    start=list(a1=50,a2=1,a3=3,a4=4,a5=1))
modelsum_mpgross_m = summary(MPGross_model_m)

a_m=coef(MPGross_model_m)[1]
b_m=coef(MPGross_model_m)[2]
c_m=coef(MPGross_model_m)[3]
d_m=coef(MPGross_model_m)[4]
e_m=coef(MPGross_model_m)[5]

# Fit effort model with added effective mass multiplied by a.
MPGross_model_effm=nls(metpowergross ~ a1*effmass2^a5 + a2*(effmass2^a3)/(movedur^a4), data=mpdata,start=list(a1=1,a2=1,a3=1,a4=1,a5=1))
modelsum_mpgross_effm = summary(MPGross_model_effm)
a_effm=coef(modelsum_mpgross_effm)[1]
b_effm=coef(modelsum_mpgross_effm)[2]
c_effm=coef(modelsum_mpgross_effm)[3]
d_effm=coef(modelsum_mpgross_effm)[4]
e_effm=coef(modelsum_mpgross_effm)[5]

# Fit the classic effort model.
# The 100 is there to allow the model to fit.
MPGross_model=nls(metpowergross ~ a1 + 100*a2*(effmass2^a3)/(movedur^a4),
                  data=mpdata,start=list(a1=100,a2=.1,a3=1,a4=1))
modelsum_mpgross = summary(MPGross_model)
a_mpgross=coef(MPGross_model)[1]
b_mpgross=coef(MPGross_model)[2]*100
c_mpgross=coef(MPGross_model)[3]
d_mpgross=coef(MPGross_model)[4]

# This was doing bootstrapping tests, but nls does bootstrapping by default (999 runs).
# n_runs = 500
# coefs = matrix(0,n_runs,4)
# for (k in 1:n_runs){
#   testsubj = sample(x=1:8,size=8,replace = TRUE)
#   testdata = c()
#   for (j in testsubj){
#     testdata=rbind(testdata,filter(mpdata,subject==j))
#   }
#   coefs[k,] = coef(nls(metpowergross ~ a1 + 100*a2*(effmass2^a3)/(movedur^a4),
#                        data=testdata,start=list(a1=100,a2=.1,a3=1,a4=1)))
#   if (k %% 100 == 0){
#     print(k)
#   }
# }
# a <- nlsBoot(MPGross_model,niter=n_runs)
a$estiboot

# Make functions for plotting.
fun.1 <- function(t) a_mpgross+b_mpgross*(2.506^c_mpgross)/(t^d_mpgross)
fun.2 <- function(t) a_mpgross+b_mpgross*(4.83^c_mpgross)/(t^d_mpgross)
fun.3 <- function(t) a_mpgross+b_mpgross*(7.13^c_mpgross)/(t^d_mpgross)
fun.4 <- function(t) a_mpgross+b_mpgross*(11.69^c_mpgross)/(t^d_mpgross)

# Aggregate the dataset for plotting.
# Mean is just total mean.
# SE is total SD/sqrt(n subj).
# This plotting method could be changed, but this is how Alaa wanted it previously.
pdata = cbind(aggregate(movedur ~ speed + effmass,mpdata_factor,mean),
              aggregate(movedur ~ speed + effmass,mpdata_factor,sd)$movedur/sqrt(8),
              aggregate(metpowergross ~ speed + effmass,mpdata_factor,mean)$metpowergross,
              aggregate(metpowergross ~ speed + effmass,mpdata_factor,sd)$metpowergross/sqrt(8))
colnames(pdata) = c('speed','effmass','movedur','movedurse','metpowergross','metpowergrossse')

MPGross <- ggplot(mpdata_factor,
                  aes(x=movedur,
                      y=metpowergross,
                      color = factor(effmass)))+
  # geom_point(size=3)+
  # stat_function(fun=fun.1,size=met_line_size+.5,color='black')+
  # stat_function(fun=fun.2,size=met_line_size+.5,color='black')+ 
  # stat_function(fun=fun.3,size=met_line_size+.5,color='black')+ 
  # stat_function(fun=fun.4,size=met_line_size+.5,color='black')+
  stat_function(fun=fun.1,size=met_line_size,color=rgb(color1[1],color1[2],color1[3]))+
  stat_function(fun=fun.2,size=met_line_size,color=rgb(color2[1],color2[2],color2[3]))+ 
  stat_function(fun=fun.3,size=met_line_size,color=rgb(color3[1],color3[2],color3[3]))+ 
  stat_function(fun=fun.4,size=met_line_size,color=rgb(color4[1],color4[2],color4[3]))+
  # geom_errorbar(data = pdata,
  #               aes(x=movedur,
  #                   ymin=metpowergross-metpowergrossse-.5,
  #                   ymax=metpowergross+metpowergrossse+.5),
  #               color = 'black',
  #               width = 0,
  #               size = met_errorbar_size+.5)+
  # geom_errorbarh(data=pdata,
  #              aes(xmin=movedur-movedurse-.001,
  #                  xmax=movedur+movedurse+.001,
  #                  y=metpowergross),
  #                  color='black',
  #              height = 0,
  #              size = met_errorbar_size+.5)+
  geom_errorbar(data = pdata,
                aes(x=movedur,
                    ymin=metpowergross-metpowergrossse,
                    ymax=metpowergross+metpowergrossse,
                color = factor(effmass)),
                width = 0,
                size = met_errorbar_size)+
  geom_errorbarh(data=pdata,
               aes(xmin=movedur-movedurse,
                   xmax=movedur+movedurse,
                   y=metpowergross,
                   color=factor(effmass)),
               height = 0,
               size = met_errorbar_size)+
  geom_hline(yintercept = a_mpgross,
             linetype = 'dashed',
             color = 'black')+
  geom_hline(yintercept = a_mpgross,
             linetype = 'dashed',
             color = 'black')+
  geom_hline(yintercept = mean(mpdata_rest),
             linetype = 'dashed',
             color = 'black')+
  annotate('text',
            x = 0.5,
            y = mean(mpdata_rest)+7,
            label = 'Resting Rate',
           hjust = 0)+
  annotate('text',
           x = 0.5,
           y = a_mpgross+7,
           label = 'Resting Rate + a',
           hjust = 0)+#expression(atop(Resting~Rate+a)))+
  scale_color_manual(values = c(mass_colors))+
  labs(x='Movement Duration (s)',
       y='Gross Metabolic Power (W)',
       color='Effective\nMass (kg)')+
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'),
        legend.position   = 'right')+
  xlim(.5,1.5)+
  ylim(0,250)

if (save_plots){
  setwd(met_plots_dir)
  ggsave('MPGross_by_movedur_met.pdf',plot=MPGross,height = 6, width = 8, useDingbats = FALSE, path = met_plots_dir)
}

```

```{r mpowergrosstab1, echo = FALSE, warning = FALSE}
# Print tables for mp gross.
mpower_gross_tab = table_func(mpdata_factor, 'metpowergross')
kable(mpower_gross_tab, caption = 'Gross Metabolic power plus/minus standard error for the metabolic experiment')

```

```{r MPGross1, echo = FALSE, warning = FALSE, fig.width=9, fig.height=6, fig.cap = 'Gross metabolic power.'}
# Show plot
  MPGross
```

Parameter estimates are showing as mean +- standard error. The columns are for without the subject mass coefficient, and with a mass coefficient on the effort model. Subj Mass Coef is the subject mass exponent.

The no_mass_coef model is as follows:
$$ \dot{e} = a+\frac{bm^c}{T_m^d} $$


The Subject mass model times a1 is as follows:
$$ \dot{e} = a*Body Mass^{f}+\frac{bm^c}{T_m^d} $$


The effective mass model times a1 is as follows:
$$ \dot{e} = a*Effective\, Mass^{f}+\frac{bm^c}{T_m^d} $$


```{r mpgrosscoeffs, echo = FALSE, warning = FALSE}
# Table showing fitted parameter estimates for the effort models.
# Also shows SSE, AIC, and BIC.
temp=data.frame(no_mass_coef = c(paste(round(coef(MPGross_model)[1],4),'±',round(coef(modelsum_mpgross)[1,2],4),sep=''),
                                 paste(round(100*coef(MPGross_model)[2],4),'±',round(100*coef(modelsum_mpgross)[2,2],4),sep=''),
                                 paste(round(coef(MPGross_model)[3],4),'±',round(coef(modelsum_mpgross)[3,2],4),sep=''),
                                 paste(round(coef(MPGross_model)[4],4),'±',round(coef(modelsum_mpgross)[4,2],4),sep=''),
                                 'null',
                                 sum(resid(MPGross_model)^2),
                                 round(AIC(MPGross_model),4),
                                 round(BIC(MPGross_model),4)),
                mass_coef = c(paste(round(coef(MPGross_model_m)[1],4),'±',round(coef(modelsum_mpgross_m)[1,2],4),sep=''),
                              paste(round(100*coef(MPGross_model_m)[2],4),'±',round(100*coef(modelsum_mpgross_m)[2,2],4),sep=''),
                              paste(round(coef(MPGross_model_m)[3],4),'±',round(coef(modelsum_mpgross_m)[3,2],4),sep=''),
                              paste(round(coef(MPGross_model_m)[4],4),'±',round(coef(modelsum_mpgross_m)[4,2],4),sep=''),
                              paste(round(coef(MPGross_model_m)[5],4),'±',round(coef(modelsum_mpgross_m)[5,2],4),sep=''),
                              sum(resid(MPGross_model_m)^2),
                              round(AIC(MPGross_model_m),4),
                              round(BIC(MPGross_model_m),4)),
                eff_mass_coef = c(paste(round(a_effm,4),'±',round(modelsum_mpgross_effm$coefficients[1,2],4),sep=''),
                                  paste(round(b_effm,4),'±',round(modelsum_mpgross_effm$coefficients[2,2],4),sep=''),
                                  paste(round(c_effm,4),'±',round(modelsum_mpgross_effm$coefficients[3,2],4),sep=''),
                                  paste(round(d_effm,4),'±',round(modelsum_mpgross_effm$coefficients[4,2],4),sep=''),
                                  paste(round(e_effm,4),'±',round(modelsum_mpgross_effm$coefficients[5,2],4),sep=''),
                                  sum(resid(MPGross_model_effm)^2),
                                  round(AIC(MPGross_model_effm),4),
                                  round(BIC(MPGross_model_effm),4)))
colnames(temp) = c('a only','a*subject mass','a*effective mass')
rownames(temp) = c('a','b','c','d','f','SSE','AIC','BIC')
kable(temp, caption = 'Gross metabolic power coefficients.')

```

## MP net
```{r, echo = FALSE, warning=FALSE}
# Do the same things with metabolic power net.

mpdata$logmovedur = log(mpdata$movedur)
mpdata$logmetpower = log(mpdata$metpowernet)

MPnet_anova = anova(lm(metpowernet ~ movedur + effmass2 + movedur*effmass2 + (1|subject),mpdata))

MPnet_lmer = cftest(lmer(log(metpowernet) ~ log(movedur) + effmass2 + (1|subject),mpdata))
cftest(lmer(log(metpowernet) ~ log(movedur) + effmass2 + (1|subject),mpdata))

# MPower Net
MPNet_model_m=nls(metpowernet ~ a1*subjmass^a5 + a2*(effmass2^a3)/(movedur^a4), data=mpdata,start=list(a1=1,a2=1,a3=1,a4=1,a5=1))
modelsum_m = summary(MPNet_model_m)
a_m=coef(modelsum_m)[1]
b_m=coef(modelsum_m)[2]
c_m=coef(modelsum_m)[3]
d_m=coef(modelsum_m)[4]
e_m=coef(modelsum_m)[5]

MPNet_model_effm=nls(metpowernet ~ a1*effmass2^a5 + a2*(effmass2^a3)/(movedur^a4), data=mpdata,start=list(a1=1,a2=1,a3=1,a4=1,a5=1))
modelsum_mpnet_effm = summary(MPNet_model_effm)
a_effm=coef(modelsum_mpnet_effm)[1]
b_effm=coef(modelsum_mpnet_effm)[2]
c_effm=coef(modelsum_mpnet_effm)[3]
d_effm=coef(modelsum_mpnet_effm)[4]
e_effm=coef(modelsum_mpnet_effm)[5]

MPNet_model=nls(metpowernet ~ a1 + a2*(effmass2^a3)/(movedur^a4), data=mpdata,start=list(a1=1,a2=1,a3=1,a4=1))
modelsum_mpnet = summary(MPNet_model)

# plot(nlsResiduals(MPNet_model))

# a_mpnet=coef(MPNet_model)[1]
# a_mpnet=coef(MPNet_model)[1]
# b_mpnet=coef(MPNet_model)[2]
# c_mpnet=coef(MPNet_model)[3]
# d_mpnet=coef(MPNet_model)[4]

a_mpnet=coef(MPGross_model)[1]-mean(mpdata_rest)
b_mpnet=coef(MPNet_model)[2]
c_mpnet=coef(MPNet_model)[3]
d_mpnet=coef(MPNet_model)[4]

fun.1 <- function(t) a_mpnet+b_mpnet*(2.506^c_mpnet)/(t^d_mpnet)
fun.2 <- function(t) a_mpnet+b_mpnet*(4.83^c_mpnet)/(t^d_mpnet)
fun.3 <- function(t) a_mpnet+b_mpnet*(7.13^c_mpnet)/(t^d_mpnet)
fun.4 <- function(t) a_mpnet+b_mpnet*(11.69^c_mpnet)/(t^d_mpnet)

pdata = cbind(aggregate(movedur ~ speed + effmass,mpdata,mean),
              aggregate(movedur ~ speed + effmass,mpdata,sd)$movedur/sqrt(8),
              aggregate(metpowernet ~ speed + effmass,mpdata,mean)$metpowernet,
              aggregate(metpowernet ~ speed + effmass,mpdata,sd)$metpowernet/sqrt(8))
colnames(pdata) = c('speed','effmass','movedur','movedurse','metpowernet','metpowernetse')

MPNet <- ggplot(mpdata,
                aes(x=movedur,y=metpowernet,color = factor(effmass)))+
  # geom_point(size=3)+
  geom_errorbar(data = pdata,
                aes(x=movedur,
                    ymin=metpowernet-metpowernetse,
                    ymax=metpowernet+metpowernetse,
                    color = factor(effmass)),
                width = 0,
                size = met_errorbar_size)+
  geom_errorbarh(data=pdata,
               aes(xmin=movedur-movedurse,
                   xmax=movedur+movedurse,
                   y=metpowernet,
                   color=factor(effmass)),
               height = 0,
                size = met_errorbar_size)+
  geom_hline(yintercept = a_mpnet,
             linetype = 'dashed',
             color = 'black')+
  stat_function(fun=fun.1,size=met_line_size,color=rgb(color1[1],color1[2],color1[3]))+
  stat_function(fun=fun.2,size=met_line_size,color=rgb(color2[1],color2[2],color2[3]))+ 
  stat_function(fun=fun.3,size=met_line_size,color=rgb(color3[1],color3[2],color3[3]))+ 
  stat_function(fun=fun.4,size=met_line_size,color=rgb(color4[1],color4[2],color4[3]))+
  scale_color_manual(values = mass_colors)+
  # theme_classic()
  labs(x='Movement Duration (s)',
       y='Net Metabolic Power Net (W)',
       color='Effective\nMass (kg)')+
  theme(legend.position   = 'right',
        text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))+
  ylim(0,200)

setwd(met_plots_dir)
if (save_plots){ggsave('MPNet_by_movedur.pdf',plot = MPNet,height = 6, width = 8, useDingbats = FALSE)}

```

```{r mpowernettab1, echo = FALSE, warning = FALSE}

mpower_net_tab = table_func(mpdata_factor, 'metpowernet')
kable(mpower_net_tab, caption = 'Net Metabolic power plus/minus standard error for the metabolic experiment')

```

```{r MPNet1, echo = FALSE, warning = FALSE, fig.width=9, fig.height=6, fig.cap = 'Net metabolic power.'}
  MPNet
```

Parameter estimates are showing as mean +- standard error. The columns are for without the subject mass coefficient, and with a mass coefficient on the effort model. Subj Mass Coef is the subject mass exponent.

The no_mass_coef model is as follows:
$$ \dot{e} = a+\frac{bm^c}{T_m^d} $$

The Subject mass model times a1 is as follows:
$$ \dot{e} = a*Body Mass^{f}+\frac{bm^c}{T_m^d} $$

The effective mass model times a1 is as follows:
$$ \dot{e} = a*Effective\, Mass^{f}+\frac{bm^c}{T_m^d} $$

```{r mpnetcoeffs, echo = FALSE, warning = FALSE}
temp=data.frame(no_mass_coef = c(paste(round(a_mpnet,4),'±',round(modelsum_mpnet$coefficients[1,2],4),sep=''),
                                 paste(round(b_mpnet,4),'±',round(modelsum_mpnet$coefficients[2,2],4),sep=''),
                                 paste(round(c_mpnet,4),'±',round(modelsum_mpnet$coefficients[3,2],4),sep=''),
                                 paste(round(d_mpnet,4),'±',round(modelsum_mpnet$coefficients[4,2],4),sep=''),
                                 'null',
                                 sum(resid(MPNet_model)^2),
                                 round(AIC(MPNet_model),4),
                                 round(BIC(MPNet_model),4)),
                mass_coef = c(paste(round(a_m,4),'±',round(modelsum_m$coefficients[1,2],4),sep=''),
                              paste(round(b_m,4),'±',round(modelsum_m$coefficients[2,2],4),sep=''),
                              paste(round(c_m,4),'±',round(modelsum_m$coefficients[3,2],4),sep=''),
                              paste(round(d_m,4),'±',round(modelsum_m$coefficients[4,2],4),sep=''),
                              paste(round(e_m,4),'±',round(modelsum_m$coefficients[5,2],4),sep=''),
                              sum(resid(MPNet_model_m)^2),
                              round(AIC(MPNet_model_m),4),
                              round(BIC(MPNet_model_m),4)),
                eff_mass_coef = c(paste(round(a_effm,4),'±',round(modelsum_mpnet_effm$coefficients[1,2],4),sep=''),
                                  paste(round(b_effm,4),'±',round(modelsum_mpnet_effm$coefficients[2,2],4),sep=''),
                                  paste(round(c_effm,4),'±',round(modelsum_mpnet_effm$coefficients[3,2],4),sep=''),
                                  paste(round(d_effm,4),'±',round(modelsum_mpnet_effm$coefficients[4,2],4),sep=''),
                                  paste(round(e_effm,4),'±',round(modelsum_mpnet_effm$coefficients[5,2],4),sep=''),
                                  sum(resid(MPNet_model_effm)^2),
                                  round(AIC(MPNet_model_effm),4),
                                  round(BIC(MPNet_model_effm),4)))
colnames(temp) = c('a only','a*subject mass','a*effective mass')
rownames(temp) = c('a','b','c','d','f','SSE','AIC','BIC')
kable(temp, caption = 'Net metabolic power coefficients.')
```


## MCost Gross
```{r, echo = FALSE, warning=FALSE}
# Plot metabolic cost.

# a1=nls(grosscost ~ a1*movedur + a2*(effmass^a3)/(movedur^a4), data=mpdata,start=list(a1=1,a2=1,a3=1,a4=1))
# modelsum = summary(a1)
# a=coef(a1)[1]
# b=coef(a1)[2]
# c=coef(a1)[3]
# d=coef(a1)[4]

# Create functions for metabolic cost
fun.1 <- function(t) a_mpgross*t+b_mpgross*(2.506^c_mpgross)/(t^(d_mpgross-1))
fun.2 <- function(t) a_mpgross*t+b_mpgross*(4.83^c_mpgross)/(t^(d_mpgross-1))
fun.3 <- function(t) a_mpgross*t+b_mpgross*(7.13^c_mpgross)/(t^(d_mpgross-1))
fun.4 <- function(t) a_mpgross*t+b_mpgross*(11.69^c_mpgross)/(t^(d_mpgross-1))

# Find the minimal cost durations
MCostmin_dur = c(optimize(fun.1,interval=c(0,2))$minimum,
                 optimize(fun.2,interval=c(0,2))$minimum,
                 optimize(fun.3,interval=c(0,2))$minimum,
                 optimize(fun.4,interval=c(0,4))$minimum)
MCostmin_obj = c(optimize(fun.1,interval=c(0,2))$objective,
                 optimize(fun.2,interval=c(0,2))$objective,
                 optimize(fun.3,interval=c(0,2))$objective,
                 optimize(fun.4,interval=c(0,4))$objective)

temp = cbind(c(2.44,4.830,7.13,11.69), MCostmin_dur ,MCostmin_obj)
colnames(temp) = c('effmass','MCostmin_dur','MCostmin_obj')

mcost_slope = lm(MCostmin_dur ~ effmass,data=data.frame(temp))

# Create plotting data
pdata = cbind(aggregate(movedur ~ speed + effmass,mpdata_factor,mean),
              aggregate(movedur ~ speed + effmass,mpdata_factor,sd)$movedur/sqrt(8),
              aggregate(grosscost ~ speed + effmass,mpdata_factor,mean)$grosscost,
              aggregate(grosscost ~ speed + effmass,mpdata_factor,sd)$grosscost/sqrt(8))
colnames(pdata) = c('speed','effmass','movedur','movedurse','grosscost','grosscostse')

# Plot
MCGross <- ggplot(data=mpdata_factor)+
  # stat_function(aes(x=movedur),
  #               fun=fun.1,size=met_line_size+.5,color='black')+
  # stat_function(aes(x=movedur),
  #               fun=fun.2,size=met_line_size+.5,color='black')+
  # stat_function(aes(x=movedur),
  #               fun=fun.3,size=met_line_size+.5,color='black')+
  # stat_function(aes(x=movedur),
  #               fun=fun.4,size=met_line_size+.5,color='black')+
  stat_function(aes(x=movedur),
  fun=fun.1,size=met_line_size,color=rgb(color1[1],color1[2],color1[3]))+
  stat_function(aes(x=movedur),
                fun=fun.2,size=met_line_size,color=rgb(color2[1],color2[2],color2[3]))+
  stat_function(aes(x=movedur),
                fun=fun.3,size=met_line_size,color=rgb(color3[1],color3[2],color3[3]))+
  stat_function(aes(x=movedur),
                fun=fun.4,size=met_line_size,color=rgb(color4[1],color4[2],color4[3]))+
  # geom_errorbar(data = pdata,
  #               aes(x=movedur,
  #                   ymin=grosscost-grosscostse-.1,
  #                   ymax=grosscost+grosscostse+.1),
  #               color = 'black',
  #               width = 0,
  #               size = met_errorbar_size+.5)+
  # geom_errorbarh(data=pdata,
  #                aes(xmin=movedur-movedurse-.001,
  #                    xmax=movedur+movedurse+.001,
  #                    y=grosscost),
  #                color='black',
  #                height = 0,
  #                size = met_errorbar_size+.5)+
  geom_errorbar(data = pdata,
                aes(x=movedur,
                    ymin=grosscost-grosscostse,
                    ymax=grosscost+grosscostse,
                    color = factor(effmass)),
                width = 0,
                size = met_errorbar_size)+
  geom_errorbarh(data=pdata,
                 aes(xmin=movedur-movedurse,
                     xmax=movedur+movedurse,
                     y=grosscost,
                     color=factor(effmass)),
                 height = 0,
                 size = met_errorbar_size)+
  geom_point(data=data.frame(temp),
             aes(x=MCostmin_dur,
                 y=MCostmin_obj,
                 fill = 'black', stroke = 3),
             size = met_costmin_size,
             pch  = 21)+
  geom_point(data=data.frame(temp),
             aes(x=MCostmin_dur,
                 y=MCostmin_obj,
                 color = factor(effmass)),
             size = met_costmin_size+1)+
  # scale_fill_manual(values=mass_colors, aesthetics = 'fill')+
  # scale_color_manual(values = 'black')+
  scale_color_manual(values = mass_colors)+
  labs(x='Movement Duration (s)',
       y='Gross Metabolic Cost (J)',
       color='Effective\nMass (kg)')+
  guides(fill =  'none')+
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))+
  xlim(.45,1.5)+
  ylim(65,180)

if (save_plots){
  setwd(met_plots_dir)
  ggsave('MCostGross_by_movedur_met.pdf',plot=MCGross,height = 6, width = 8, useDingbats = FALSE, path = met_plots_dir)
}

preffun.1 <- function(t) a_mpgross*t+b_mpgross*(2.506^c_mpgross)/(t^(d_mpgross-1))
preffun.2 <- function(t) a_mpgross*t+b_mpgross*(3.959^c_mpgross)/(t^(d_mpgross-1))
preffun.3 <- function(t) a_mpgross*t+b_mpgross*(4.894^c_mpgross)/(t^(d_mpgross-1))
preffun.4 <- function(t) a_mpgross*t+b_mpgross*(6.282^c_mpgross)/(t^(d_mpgross-1))

# Create table of optimal durations
# MCostmin_dur = c(optimize(preffun.1,interval=c(0,2))$minimum,optimize(preffun.2,interval=c(0,2))$minimum,optimize(preffun.3,interval=c(0,2))$minimum,optimize(preffun.4,interval=c(0,4))$minimum)
# MCostmin_obj = c(optimize(preffun.1,interval=c(0,2))$objective,optimize(preffun.2,interval=c(0,2))$objective,optimize(preffun.3,interval=c(0,2))$objective,optimize(preffun.4,interval=c(0,4))$objective)
# temppref = cbind(c(2.506,3.959,4.894,5.282),MCostmin_obj,MCostmin_dur,aggregate(movedur ~ eff_mass,prefdata,mean)$movedur)
# colnames(temppref) = c('effmass','MCostmin_obj','MCostgross_min_dur','pref_avg_dur')

```

```{r mcostcosttab1, echo = FALSE, warning = FALSE}

# Make table of metabolic cost by speed and mass.
mcost_cost_tab = table_func(mpdata_factor, 'grosscost')
kable(mcost_cost_tab, caption = 'Gross Metabolic Cost plus/minus standard error for the metabolic experiment')

```

```{r MCGross1, echo = FALSE, warning = FALSE, fig.width=9, fig.height=6, fig.cap = 'Gross metabolic cost.'}
  MCGross+
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))
```

<!-- The minimum values and durations are -->

```{r, echo = FALSE, warning=FALSE}
  # kable(temp)
```
The linear slope of the metabolic minimum is `r mcost_slope$coefficients[2]`.

The optimal movement durations using the preferred masses are shown below along with the average movement durations.

```{r mcostgrossdur, echo = FALSE, warning=FALSE}
# Table of optimal durations from metabolic experiment
# Added by Robbie (10/14/2022)
colnames(temp) = c('Effective Mass (kg)', 'Minimum Cost Duration (s)', 'Minimum Cost (J)')
kable(temp, caption = 'Optimal durations for gross metabolic cost from metabolics exp.')

# Table of optimal durations, with minimum cost, and preferred duration.
colnames(temppref) = c('Effective Mass (kg)','Minimum Cost (J)','Minimum Cost Duration (s)','Preferred Duraiton (s)')
kable(temppref, caption = 'Optimal durations for gross metabolic cost from pref. exp. 2a')
```

## MCost Net

```{r, echo = FALSE, warning=FALSE}
# Do the same thing as metabolic cost gross.
fun.1 <- function(t) a_mpnet*t+b_mpnet*(2.506^c_mpnet)/(t^(d_mpnet-1))
fun.2 <- function(t) a_mpnet*t+b_mpnet*(4.83^c_mpnet)/(t^(d_mpnet-1))
fun.3 <- function(t) a_mpnet*t+b_mpnet*(7.13^c_mpnet)/(t^(d_mpnet-1))
fun.4 <- function(t) a_mpnet*t+b_mpnet*(11.69^c_mpnet)/(t^(d_mpnet-1))

MCostmin_dur = c(optimize(fun.1,interval=c(0,2))$minimum,optimize(fun.2,interval=c(0,2))$minimum,optimize(fun.3,interval=c(0,2))$minimum,optimize(fun.4,interval=c(0,4))$minimum)
MCostmin_obj = c(optimize(fun.1,interval=c(0,2))$objective,optimize(fun.2,interval=c(0,2))$objective,optimize(fun.3,interval=c(0,2))$objective,optimize(fun.4,interval=c(0,4))$objective)
temp = cbind(c(2.44,4.830,7.13,11.69),MCostmin_dur,MCostmin_obj)
colnames(temp) = c('effmass','MCostmin_dur','MCostmin_obj')

pdata = cbind(aggregate(movedur ~ speed + effmass,mpdata_factor,mean),
              aggregate(movedur ~ speed + effmass,mpdata_factor,sd)$movedur/sqrt(8),
              aggregate(netcost ~ speed + effmass,mpdata_factor,mean)$netcost,
              aggregate(netcost ~ speed + effmass,mpdata_factor,sd)$netcost/sqrt(8))
colnames(pdata) = c('speed','effmass','movedur','movedurse','netcost','netcostse')

MCNet <- ggplot(data=mpdata_factor)+
  stat_function(aes(x=movedur),
                fun=fun.1,
                size=met_line_size,
                color=rgb(color1[1],color1[2],color1[3]))+
  stat_function(aes(x=movedur),
                fun=fun.2,size=met_line_size,color=rgb(color2[1],color2[2],color2[3]))+
  stat_function(aes(x=movedur),
                fun=fun.3,size=met_line_size,color=rgb(color3[1],color3[2],color3[3]))+
  stat_function(aes(x=movedur),
                fun=fun.4,size=met_line_size,color=rgb(color4[1],color4[2],color4[3]))+
  geom_errorbar(data = pdata,
                aes(x=movedur,
                    ymin=netcost-netcostse,
                    ymax=netcost+netcostse,
                    color = factor(effmass)),
                width = 0,
                size = met_errorbar_size)+
  geom_errorbarh(data=pdata,
                 aes(xmin=movedur-movedurse,
                     xmax=movedur+movedurse,
                     y=netcost,
                     color=factor(effmass)),
                 height = 0,
                 size = met_errorbar_size)+
  geom_point(data=data.frame(temp),
             aes(x=MCostmin_dur,
                 y=MCostmin_obj,
                 fill = 'black', stroke = 3),
             size = met_costmin_size,
             pch  = 21)+
  geom_point(data=data.frame(temp),
             aes(x=MCostmin_dur,
                 y=MCostmin_obj,
                 color = factor(effmass)),
             size = met_costmin_size+1)+
  scale_color_manual(values = mass_colors)+
  labs(x='Movement Duration (s)',
       y='Net Metabolic Cost (J)',
       color='Effective\nMass (kg)')+
  guides(fill =  'none')+
  theme(legend.position  = 'right',
        text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))+
  xlim(.45,1.5)+
  ylim(0,120)

setwd(met_plots_dir)
if (save_plots){
  ggsave('MCostNet_by_movedur.pdf',plot=MCNet,height = 6, width = 8, useDingbats = FALSE, path = met_plots_dir)
}

preffun.1 <- function(t) a_mpnet*t+b_mpnet*(2.506^c_mpnet)/(t^(d_mpnet-1))
preffun.2 <- function(t) a_mpnet*t+b_mpnet*(3.959^c_mpnet)/(t^(d_mpnet-1))
preffun.3 <- function(t) a_mpnet*t+b_mpnet*(4.894^c_mpnet)/(t^(d_mpnet-1))
preffun.4 <- function(t) a_mpnet*t+b_mpnet*(6.282^c_mpnet)/(t^(d_mpnet-1))

MCostmin_dur = c(optimize(preffun.1,interval=c(0,2))$minimum,optimize(preffun.2,interval=c(0,2))$minimum,optimize(preffun.3,interval=c(0,2))$minimum,optimize(preffun.4,interval=c(0,4))$minimum)
MCostmin_obj = c(optimize(preffun.1,interval=c(0,2))$objective,optimize(preffun.2,interval=c(0,2))$objective,optimize(preffun.3,interval=c(0,2))$objective,optimize(preffun.4,interval=c(0,4))$objective)
temppref = cbind(c(2.506,3.959,4.894,6.282),MCostmin_obj,MCostmin_dur,aggregate(movedur ~ eff_mass,prefdata,mean)$movedur)
colnames(temppref) = c('effmass','MCostmin_obj','MCostnet_min_dur','pref_avg_dur')

```


```{r mcostcostnettab1, echo = FALSE, warning = FALSE}

mcost_cost_net_tab = table_func(mpdata_factor, 'netcost')
kable(mcost_cost_net_tab, caption = 'Net Metabolic Cost plus/minus standard error for the metabolic experiment')

```

```{r MCNet1, echo = FALSE, warning = FALSE, fig.width=9, fig.height=6, fig.cap = 'Net metabolic cost.'}
  MCNet+
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))
```

<!-- The minimum values and durations are  -->

<!-- ```{r, echo = FALSE, warning=FALSE} -->
<!-- colnames(temp) = c('Effective Mass (kg)','Minimum Cost Duration','Minimum Cost') -->
<!-- kable(temp) -->
<!-- ``` -->

The optimal movement durations using the preferred masses are shown below along with the average movement durations.

```{r mcostnetdur, echo = FALSE, warning=FALSE}
colnames(temppref) = c('Effective Mass (kg)','Minimum Cost (J)','Minimum Cost Duration (s)','Preferred Duraiton (s)')
kable(temppref, caption = 'Minimum Cost durations for net metabolic cost.')
```


## Table of Movement Durations
```{r mcostdurtab1, echo = FALSE, warning = FALSE}

# pdata = cbind(aggregate(movedur ~ speed + effmass,mpdata_factor,mean),
#             aggregate(movedur ~ speed + effmass,mpdata_factor,sd)$movedur/sqrt(8),
#             aggregate(grosscost ~ speed + effmass,mpdata_factor,mean)$grosscost,
#             aggregate(grosscost ~ speed + effmass,mpdata_factor,sd)$grosscost/sqrt(8))
# 
# colnames(pdata) = c('Speed Condition','Effective Mass (kg)','Movement Duraiton (s)','Duration Standard Error','Gross Metabolic Cost (J)','Gross Metabolic Cost SE')

mcost_dur_tab = table_func(mpdata_factor, 'movedur')
kable(mcost_dur_tab, caption = 'Movement Duration plus/minus standard error for the metabolic experiment')
```



## Endpoint Error
```{r missdisttab1, echo = FALSE, warning = FALSE, message=FALSE}
# Do a similar stats and plotting to the preferred experiments.

#Stats
cftest(lmer(log(miss_dist) ~ log(movedur) + eff_mass2 + (1|subj),data=metdata))

miss_dist_tab = table_func(metdata, 'miss_dist')
kable(miss_dist_tab, caption = 'Endpoitn Error plus/minus standard error for the metabolic experiment')

# Create data frame for plotting
variable = 'miss_dist' # Choose variable
string = paste('
               pdata = cbind(aggregate(movedur ~ speed + eff_mass,metdata,mean),
               aggregate(movedur ~ speed + eff_mass,metdata,sd)$movedur/sqrt(8),
               aggregate(',variable,' ~ speed + eff_mass,metdata,mean)$',variable,',
               aggregate(',variable,' ~ speed + eff_mass,metdata,sd)$',variable,'/sqrt(8))
               colnames(pdata) = c(\'speed\',\'eff_mass\',\'movedur\',\'movedurse\',\'yvar\',\'yvarse\')',sep='')

eval(parse(text = string))
pdata$yvar = pdata$yvar*100
pdata$yvarse = pdata$yvarse*100

# Right now the standard error is propagated error.
# You may want to change this to standard error of subject means.
pdata$yvarse = sse_prop_met(metdata, variable) # This is changing the yvarse
pdata$yvarse = pdata$yvarse*100
pdata$movedurse = sse_prop_met(metdata, 'movedur')

# Plotting
miss_dist_grouped_met <- ggplot()+
    geom_smooth(data = pdata,
                aes(x=movedur,
                    y=yvar,
                    color = factor(eff_mass)),
                se=FALSE,size=met_line_size,span=3, method = 'loess')+
  geom_errorbar(data = pdata,
                aes(x=movedur,
                    ymin=yvar-yvarse,
                    ymax=yvar+yvarse,
                    color = factor(eff_mass)),
                width = 0,
                size = met_errorbar_size)+
  geom_errorbarh(data=pdata,
                 aes(xmin=movedur-movedurse,
                     xmax=movedur+movedurse,
                     y=yvar,
                     color=factor(eff_mass)),
                 height = 0,
                 size = met_errorbar_size)+
  scale_color_manual(values = mass_colors)+
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))+
  labs(x='Movement Duration (s)',
       y='Endpoint Error (cm)',
       color='Effective\nMass (kg)')+
  xlim(c(.45,1.5))




# ggplot()+
#   geom_point(data=cbind(aggregate(miss_dist ~ subj+speed+eff_mass,
#                               filter(metdata,odd_trial==1,movedur<1.5,miss_dist<.1),mean),
#                           movedur=aggregate(movedur ~ subj+speed+eff_mass,
#                               filter(metdata,odd_trial==1,movedur<1.5,miss_dist<.1),mean)$movedur),
#                aes(x=movedur,y=abs(miss_dist),color=factor(eff_mass)))+
#   geom_smooth(method = lm, formula = y~exp(-x),
#                 data=filter(metdata,odd_trial==1,movedur<1.5,miss_dist<.1),
#                 aes(x=movedur,
#                     y=abs(miss_dist),
#                     color=factor(eff_mass)))+
#   scale_color_manual(values=mass_colors)+
#   labs(x='Movement Duration (s)',y='Miss Dist')


```

```{r missdistgroupedmet1, echo = FALSE, warning = FALSE, fig.width=9, fig.height=6, fig.cap = 'Endpoint Error.'}
  miss_dist_grouped_met
```

## Angle Variance
```{r anglevartab1, echo = FALSE, warning = FALSE, message=FALSE}

table_var_func <- function(data){
  # Create a function for the variance metrics in the metabolic data.
  tab = matrix(,nrow=4,ncol=7)
  for (s in c(1:7)){
    m_count = 0
    for (mass in c(2.44, 4.83, 7.13, 11.69)){
      m_count = m_count + 1
      avg = round(filter(data,speed == s, eff_mass == mass)$yvar,4)
      se = round(filter(data,speed == s, eff_mass == mass)$yvarse,4)
      tab[m_count,s] = paste(avg,"±,",se,sep='')
    }
  }
  colnames(tab) = c('Speed = 1','Speed = 2','Speed = 3','Speed = 4','Speed = 5','Speed = 6','Speed = 7')
  rownames(tab) = c('2.73 kg','4.83 kg','7.13 kg','11.69 kg')
  return(tab)
}


# Miss Angle Grouped VARIANCE
# Aggregate the data by variance.
a = aggregate(missangle ~ subj + eff_mass + speed ,metdata,var)
b = aggregate(movedur ~ subj + eff_mass+ speed ,metdata,mean)
c = data.frame(cbind(a$subj,a$eff_mass,b$movedur,a$missangle))
colnames(c) = c('subj','eff_mass','movedur','missangle')
cftest(lmer(log(missangle) ~ log(movedur) + eff_mass + (1|subj),data=c))

# Show table
anglevar_tab = table_var_func(pdata)
kable(anglevar_tab, caption = 'Miss Angle Variance plus/minus standard error for the metabolic experiment')

variable = 'missangle'

# Create data for plotting
string1 = paste('
              pdata = cbind(aggregate(movedur ~ subj + speed + eff_mass,metdata,mean),
              aggregate(movedur ~ subj + speed + eff_mass,metdata,sd)$movedur/sqrt(8),
              aggregate(',variable,' ~ subj + speed + eff_mass,metdata,sd)$',variable,'/sqrt(8),
              aggregate(',variable,' ~ subj + speed + eff_mass,metdata,sd)$',variable,'/sqrt(8))

              colnames(pdata) = c(\'subj\',\'speed\',\'eff_mass\',\'movedur\',\'movedurse\',\'yvar\',\'yvarse\')',sep='')

eval(parse(text = string1))
string2 = paste('
              pdata = cbind(aggregate(movedur ~ speed + eff_mass,metdata,mean),
              aggregate(movedur ~ speed + eff_mass,metdata,sd)$movedur/sqrt(8),
              aggregate(yvar ~ speed + eff_mass,pdata,mean)$yvar,
              aggregate(yvar ~ speed + eff_mass,pdata,sd)$yvar/sqrt(8))
              colnames(pdata) = c(\'speed\',\'eff_mass\',\'movedur\',\'movedurse\',\'yvar\',\'yvarse\')',sep='')
eval(parse(text = string2))

# Plot
miss_anglevar_grouped_met<-ggplot()+
  # geom_smooth(data = pdata,
  #             aes(x=movedur,
  #                 y=yvar,
  #                 group = factor(eff_mass)),
  #             color = 'black',
  #             se=FALSE,size=met_line_size+.5,span=3, method = 'loess')+
  geom_smooth(data = pdata,
              aes(x=movedur,
                  y=yvar,
                  color = factor(eff_mass)),
              se=FALSE,size=met_line_size,span=3, method = 'loess')+
  # geom_errorbar(data = pdata,
  #               aes(x=movedur,
  #                   ymin=yvar-yvarse-.001,
  #                   ymax=yvar+yvarse+.001),
  #               color = 'black',
  #               width = 0,
  #               size = met_errorbar_size+.5)+
  # geom_errorbarh(data=pdata,
  #                aes(xmin=movedur-movedurse-.002,
  #                    xmax=movedur+movedurse+.002,
  #                    y=yvar),
  #                color='black',
  #                height = 0,
  #                size = met_errorbar_size+.5)+
  geom_errorbar(data = pdata,
                aes(x=movedur,
                    ymin=yvar-yvarse,
                    ymax=yvar+yvarse,
                    color = factor(eff_mass)),
                width = 0,
                size = met_errorbar_size)+
  geom_errorbarh(data=pdata,
                 aes(xmin=movedur-movedurse,
                     xmax=movedur+movedurse,
                     y=yvar,
                     color=factor(eff_mass)),
                 height = 0,
                 size = met_errorbar_size)+
  scale_color_manual(values = mass_colors)+
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))+
  xlim(.45,1.5)+
  labs(x='Movement Duration (s)',
       y=expression(atop(Miss~Angle,Variance~(deg^2))),
       color='Effective\nMass (kg)')+
  theme(legend.position = 'right')

```

```{r missanglevargroupedmet1, echo = FALSE, warning = FALSE, fig.width=9, fig.height=6, fig.cap = 'Angular miss variance.'}
  miss_anglevar_grouped_met
```


## Radial Endpoint Variance
```{r radendvartab1, echo = FALSE, warning = FALSE, message=FALSE}
# Do same thing as angular variance.
variable = 'miss_rad'
string1 = paste('
                pdata = cbind(aggregate(movedur ~ subj + speed + eff_mass,metdata,mean),
                aggregate(movedur ~ subj + speed + eff_mass,metdata,sd)$movedur/sqrt(8),
                aggregate(',variable,' ~ subj + speed + eff_mass,metdata,sd)$',variable,'/sqrt(8),
                aggregate(',variable,' ~ subj + speed + eff_mass,metdata,sd)$',variable,'/sqrt(8))
                
                colnames(pdata) = c(\'subj\',\'speed\',\'eff_mass\',\'movedur\',\'movedurse\',\'yvar\',\'yvarse\')',sep='')

eval(parse(text = string1))
string2 = paste('
                pdata = cbind(aggregate(movedur ~ speed + eff_mass,metdata,mean),
                aggregate(movedur ~ speed + eff_mass,metdata,sd)$movedur/sqrt(8),
                aggregate(yvar ~ speed + eff_mass,pdata,mean)$yvar,
                aggregate(yvar ~ speed + eff_mass,pdata,var)$yvar/sqrt(8))
                colnames(pdata) = c(\'speed\',\'eff_mass\',\'movedur\',\'movedurse\',\'yvar\',\'yvarse\')',sep='')

eval(parse(text = string2))
pdata$yvar = pdata$yvar *100
pdata$yvarse = pdata$yvarse *100^3

a = aggregate(miss_rad ~ subj + eff_mass + speed ,metdata,var)
b = aggregate(movedur ~ subj + eff_mass+ speed ,metdata,mean)
c = data.frame(cbind(a$subj,a$eff_mass,b$movedur,a$miss_rad))
colnames(c) = c('subj','eff_mass','movedur','miss_rad')

cftest(lmer(log(miss_rad) ~ log(movedur) + eff_mass + (1|subj),data=c))

rad_endvar_tab = table_var_func(pdata)
kable(rad_endvar_tab, caption = 'Radial Endpoint Variance plus/minus standard error for the metabolic experiment')

radial_endpointvar_grouped_met<-ggplot()+
  # geom_smooth(data = pdata,
  #             aes(x=movedur,
  #                 y=yvar,
  #                 group = factor(eff_mass)),
  #             color = 'black',
  #             se=FALSE,size=met_line_size+.5,span=3, method = 'loess')+
  geom_smooth(data = pdata,
              aes(x=movedur,
                  y=yvar,
                  color = factor(eff_mass)),
              se=FALSE,size=met_line_size,span=3, method = 'loess')+
  # geom_errorbar(data = pdata,
  #               aes(x=movedur,
  #                   ymin=yvar-yvarse-.0005,
  #                   ymax=yvar+yvarse+.0005),
  #               color = 'black',
  #               width = 0,
  #               size = met_errorbar_size+.5)+
  # geom_errorbarh(data=pdata,
  #                aes(xmin=movedur-movedurse-.002,
  #                    xmax=movedur+movedurse+.002,
  #                    y=yvar),
  #                color = 'black',
  #                height = 0,
  #                size = met_errorbar_size+.5)+
  geom_errorbar(data = pdata,
                aes(x=movedur,
                    ymin=yvar-yvarse,
                    ymax=yvar+yvarse,
                    color = factor(eff_mass)),
                width = 0,
                size = met_errorbar_size)+
  geom_errorbarh(data=pdata,
                 aes(xmin=movedur-movedurse,
                     xmax=movedur+movedurse,
                     y=yvar,
                     color=factor(eff_mass)),
                 height = 0,
                 size = met_errorbar_size)+
  scale_color_manual(values = mass_colors)+
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))+
  xlim(.45,1.5)+
  labs(x='Movement Duration (s)',
       y=expression(atop(Radial~Endpoint,Variance~(cm^2))),
       color='Effective\nMass (kg)')+
  theme(legend.position = 'right')

```

```{r radialendpointvargroupedmet1, echo = FALSE, warning = FALSE, fig.width=9, fig.height=6, fig.cap = 'Radial miss variance.'}
  radial_endpointvar_grouped_met
```

## Reaction Time
```{r reacttimetab1, echo = FALSE, warning = FALSE, message=FALSE}

# Do similar stuff on reaction time in metabolics data as preferred data.
cftest(lmer(reaction_tanv ~ log(movedur) + eff_mass2+ (1|subj),data=metdata))
cftest(lmer(reaction_tanv ~ movedur + eff_mass2+ (1|subj),data=metdata))

react_time_tab = table_func(metdata, 'reaction_tanv')
kable(react_time_tab, caption = 'Reaction time plus/minus standard error for the metabolic experiment')

variable = 'reaction_tanv'
string = paste('
pdata = cbind(aggregate(movedur ~ speed + eff_mass,metdata,mean),
              aggregate(movedur ~ speed + eff_mass,metdata,sd)$movedur/sqrt(8),
              aggregate(',variable,' ~ speed + eff_mass,metdata,mean)$',variable,',
              aggregate(',variable,' ~ speed + eff_mass,metdata,var)$',variable,'/sqrt(8))
colnames(pdata) = c(\'speed\',\'eff_mass\',\'movedur\',\'movedurse\',\'yvar\',\'yvarse\')',sep='')

eval(parse(text = string))

pdata$yvarse = sse_prop_met(metdata, variable)
pdata$movedurse = sse_prop_met(metdata, 'movedur')

reaction_bydur_met <- ggplot()+
  geom_smooth(data = pdata,
              aes(x=movedur,
                  y=yvar,
                  color = factor(eff_mass)),
              se=FALSE,size=met_line_size,span=3, method = 'loess')+
  geom_errorbar(data = pdata,
                aes(x=movedur,
                    ymin=yvar-yvarse,
                    ymax=yvar+yvarse,
                    color = factor(eff_mass)),
                width = 0,
                size = met_errorbar_size)+
  geom_errorbarh(data=pdata,
                 aes(xmin=movedur-movedurse,
                     xmax=movedur+movedurse,
                     y=yvar,
                     color=factor(eff_mass)),
                 height = 0,
                 size = met_errorbar_size)+
  scale_color_manual(values = mass_colors)+
  labs(x='Movement Duration (s)',
       y='Reaction Time (s)',
       # title='Metabolic Experiment Reaction time',
       color='Effective\nMass (kg)')+
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))+
  xlim(c(.45,1.5))

```

```{r reactionbydurmet1, echo = FALSE, warning = FALSE, fig.width=9, fig.height=6, fig.cap = 'Reaction time in metabolic experiment.'}
  reaction_bydur_met
```

### Reaction Time %
```{r reacttimetabperc, echo = FALSE, warning = FALSE, message=FALSE}

metdata$reaction_tanv_perc = metdata$reaction_tanv/metdata$movedur
metdata$total_dur = metdata$reaction_tanv+metdata$movedur

cftest(lmer(reaction_tanv_perc ~ log(movedur) + eff_mass2+ (1|subj),data=metdata))
cftest(lmer(reaction_tanv_perc ~ movedur + eff_mass2+ (1|subj),data=metdata))

react_time_tab = table_func(metdata, 'reaction_tanv_perc')
kable(react_time_tab, caption = 'Reaction time plus/minus standard error for the metabolic experiment')

variable = 'reaction_tanv_perc'
string = paste('
pdata = cbind(aggregate(total_dur ~ speed + eff_mass,metdata,mean),
              aggregate(total_dur ~ speed + eff_mass,metdata,sd)$total_dur/sqrt(8),
              aggregate(',variable,' ~ speed + eff_mass,metdata,mean)$',variable,',
              aggregate(',variable,' ~ speed + eff_mass,metdata,sd)$',variable,'/sqrt(8))
colnames(pdata) = c(\'speed\',\'eff_mass\',\'total_dur\',\'movedurse\',\'yvar\',\'yvarse\')',sep='')

eval(parse(text = string))

# Change mvoement duration to total duration? Reaction+movement

reaction_perc_bydur_met <- ggplot()+
  # geom_smooth(data = pdata,
  #             aes(x=total_dur,
  #                 y=yvar,
  #                 group = factor(eff_mass)),
  #             color = 'black',
  #             se=FALSE,size=met_line_size+0.5,span=3, method = 'loess')+
  geom_smooth(data = pdata,
              aes(x=total_dur,
                  y=yvar,
                  color = factor(eff_mass)),
              se=FALSE,size=met_line_size,span=3, method = 'loess')+
  # geom_errorbar(data = pdata,
  #               aes(x=total_dur,
  #                   ymin=yvar-yvarse-.0001,
  #                   ymax=yvar+yvarse+.0001),
  #               color = 'black',
  #               width = 0,
  #               size = met_errorbar_size+.5)+
  # geom_errorbarh(data=pdata,
  #                aes(xmin=total_dur-movedurse-.001,
  #                    xmax=total_dur+movedurse+.001,
  #                    y=yvar),
  #                color='black',
  #                height = 0,
  #                size = met_errorbar_size+.5)+
  geom_errorbar(data = pdata,
                aes(x=total_dur,
                    ymin=yvar-yvarse,
                    ymax=yvar+yvarse,
                    color = factor(eff_mass)),
                width = 0,
                size = met_errorbar_size)+
  geom_errorbarh(data=pdata,
                 aes(xmin=total_dur-movedurse,
                     xmax=total_dur+movedurse,
                     y=yvar,
                     color=factor(eff_mass)),
                 height = 0,
                 size = met_errorbar_size)+
  scale_color_manual(values = mass_colors)+
  labs(x='Total Duration (s)',
       y='Reaction Time % (s)',
       title='Rxn %, rxn/(rxn+mvt)',
       color='Effective\nMass (kg)')+
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))+
  xlim(c(.45,1.5))

```

```{r reactionpercbydurmet, echo = FALSE, warning = FALSE, fig.width=9, fig.height=6, fig.cap = 'Reaction time in metabolic experiment.'}
reaction_perc_bydur_met
```


## Metabolic results plot

```{r, echo = FALSE, warning = FALSE, message=FALSE}
# Group all the metabolic results plots.
theme_set(theme_cowplot(font_size=12))
mass_met_legend <- get_legend(reaction_bydur_met+
                                theme(legend.position='right')+
                                guides(color=guide_legend(title="Effective\nMass (kg)")))

plots_to_fix = c('MPNet',
                 'MCNet',
                 'MPGross',
                 'MCGross',
                 'miss_dist_grouped_met',
                 'miss_anglevar_grouped_met',
                 'radial_endpointvar_grouped_met',
                 'reaction_bydur_met')

for (plot in plots_to_fix){
  string = paste(plot,'<-',plot,'+
  # theme_classic()
  theme(text              = element_text(color=\'black\'),
        axis.text         = element_text(color=\'black\'),
        axis.ticks        = element_line(color=\'black\'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color=\'black\'),
        legend.position   = \'none\')',sep = '')
  eval(parse(text = string))
}

# met_results <- plot_grid(MPGross,
#                          MCGross,
#                          MPNet,
#                          MCNet,
#                          miss_dist_grouped_met,
#                          # miss_angle_grouped_met,
#                          miss_anglevar_grouped_met,
#                          # radial_endpoint_grouped_met,
#                          radial_endpointvar_grouped_met,
#                          reaction_bydur_met+labs(title=''),
#                          nrow=4,
#                          labels = 'AUTO',#c('A','B','C','D','E','F','G','H','I'),
#                          hjust=-1,
#                          align = 'vh')

# met_results <- plot_grid(plot_grid(NULL, MPGross, NULL,
#                                    nrow = 1, labels = c('','A',''),rel_widths = c(.1,.8,.1)), 
#                          plot_grid(MCGross,
#                                    MCNet,
#                                    miss_dist_grouped_met,
#                                    miss_anglevar_grouped_met,
#                                    radial_endpointvar_grouped_met,
#                                    reaction_bydur_met,
#                                    nrow = 3, labels = c('B','C','D','E','F'), align = 'vh'),
#                          nrow = 2,
#                          align = 'vh',
#                          rel_heights = c(2,4))

met_results <- plot_grid(MPGross+theme(text = element_text(size=7.76)),
                         MCGross+theme(text = element_text(size=7.76)),
                         miss_dist_grouped_met+theme(text = element_text(size=7.76)),
                         miss_anglevar_grouped_met+theme(text = element_text(size=7.76)),
                         radial_endpointvar_grouped_met+theme(text = element_text(size=7.76)),
                         reaction_bydur_met+theme(text = element_text(size=7.76)),
                         nrow = 3, 
                         labels = c('A','B','C','D','E','F'),
                         align = 'vh')

met_results <- plot_grid(met_results,
                         mass_met_legend,
                         nrow=1,
                         rel_widths = c(.85,.15))

theme_set(theme_cowplot(font_size=7.76))
setwd(met_plots_dir)
if (save_plots){ggsave('Met_results_r.pdf',plot=met_results,width=6,height=7, device=cairo_pdf)}
```

```{r metresults1, echo = FALSE, warning = FALSE, fig.width=12, fig.height=10, fig.cap = 'Metabolic experiment results.'}
  met_results
```

# Effort models

```{r, echo = FALSE, warning = FALSE}
# This code chunk fits the torque effort models.

#================  Sum of Torque ==========================
# Adding Column for estimated eff_mass to preferred experiment.
eff_mass = c()
for (i in 1:length(torque2_data$subject)){
  eff_mass[i] = eff_masses_meta[torque2_data$c[i],torque2_data$subj[i]]
}

torque2_data$effmass2 <- eff_mass

values <- c(2.44,4.830,7.13,11.69)
index <- c(1,2,3,4)
torque2_data$effmass <- values[match(torque2_data$c,index)]
torque2_data$distance <- .1
torque2_data$sum_t2_rate <- torque2_data$sum_t2/torque2_data$movedur

torque2_data2 = aggregate(sum_t2 ~ c + s + subj, torque2_data, mean)
torque2_data2$effmass = aggregate(effmass ~ s + c + subj, torque2_data, mean)$effmass
torque2_data2$movedur = aggregate(movedur ~ s + c + subj, torque2_data, mean)$movedur
torque2_data2$sum_t2_rate <- torque2_data2$sum_t2/torque2_data2$movedur

# Create the torque2 data.
c = c()
s = c()
subj = c()
effmass = c()
movedur = c()
sum_t2 = c()
for (cond in c(1,2,3,4)){
  for (subject in c(1,2,3,4,5,6,7,8)){
    for (speed in c(1,2,3,4,5,6,7)){
      if (!length(filter(torque2_data,subj == subject, s == speed, c == cond)$c) == 0){
        c = c(c, aggregate(c ~ s + c + subj, filter(torque2_data,subj == subject, s == speed, c == cond), mean)$c) 
        s = c(s, aggregate(s ~ s + c + subj, filter(torque2_data,subj == subject, s == speed, c == cond), mean)$s) 
        subj = c(subj, aggregate(subj ~ s + c + subj, filter(torque2_data,subj == subject, s == speed, c == cond), mean)$subj) 
        effmass = c(effmass, aggregate(effmass ~ s + c + subj, filter(torque2_data,subj == subject, s == speed, c == cond), mean)$effmass) 
        movedur = c(movedur, aggregate(movedur ~ s + c + subj, filter(torque2_data,subj == subject, s == speed, c == cond), mean)$movedur) 
        sum_t2 = c(sum_t2, aggregate(sum_t2 ~ s + c + subj, filter(torque2_data,subj == subject, s == speed, c == cond), mean)$sum_t2) 
      }
    }
  }
}
test_t2_df = as.data.frame(cbind(c, s, subj, effmass, movedur, sum_t2))
test_t2_df$sum_t2_rate = test_t2_df$sum_t2/test_t2_df$movedur
torque2_data = test_t2_df
# torque2_data = torque2_data2

a = 0

# Fit torque 2 model.
torque2_model=nls(sum_t2_rate ~ a + a1*(effmass^a2)/(movedur^a3),
                  data=torque2_data,
                  start=list(a1=.01,a2=2,a3=1))
modelsum_torque2 = summary(torque2_model)

b_torque=coef(torque2_model)[1]
c_torque=coef(torque2_model)[2]
d_torque=coef(torque2_model)[3]

fun.1 <- function(t) b_torque*(2.506^c_torque)/(t^(d_torque))
fun.2 <- function(t) b_torque*(4.830^c_torque)/(t^(d_torque))
fun.3 <- function(t) b_torque*(7.130^c_torque)/(t^(d_torque))
fun.4 <- function(t) b_torque*(11.69^c_torque)/(t^(d_torque))


pdata = cbind(aggregate(movedur ~ s + c,torque2_data,mean),
              aggregate(movedur ~ s + c,torque2_data,sd)$movedur/sqrt(8),
              aggregate(sum_t2_rate ~ s + c,torque2_data,mean)$sum_t2_rate,
              aggregate(sum_t2_rate ~ s + c,torque2_data,sd)$sum_t2_rate/sqrt(8))
colnames(pdata) = c('speed','effmass','movedur','movedurse','sum_t2_rate','sum_t2_ratese')

# Plot the torque2 model, doesn't show up in html.
torque_plot <- ggplot(torque2_data,
            aes(x=movedur,
                y=sum_t2_rate,
                color = factor(effmass)))+
  geom_errorbar(data = pdata,
                aes(x=movedur,
                    ymin=sum_t2_rate-sum_t2_ratese,
                    ymax=sum_t2_rate+sum_t2_ratese,
                    color = factor(effmass)),
                width = 0,
                size = met_errorbar_size+1)+
  geom_errorbarh(data=pdata,
                 aes(xmin=movedur-movedurse,
                     xmax=movedur+movedurse,
                     y=sum_t2_rate,
                     color=factor(effmass)),
                 height = 0,
                 size = met_errorbar_size+1)+
  # geom_point(data = torque2_data,
  #                  aes(x=movedur,
  #                      y=sum_t2_rate,
  #                      fill = factor(effmass)),
  #                  shape=21,
  #                  color='black',
  #                  size=3)+
  scale_fill_manual(values=mass_colors)+
  scale_color_manual(values=mass_colors)+
  # theme_classic()
  stat_function(fun=fun.1,color=rgb(color1[1],color1[2],color1[3]),size=met_errorbar_size)+
  stat_function(fun=fun.2,color=rgb(color2[1],color2[2],color2[3]),size=met_errorbar_size)+
  stat_function(fun=fun.3,color=rgb(color3[1],color3[2],color3[3]),size=met_errorbar_size)+
  stat_function(fun=fun.4,color=rgb(color4[1],color4[2],color4[3]),size=met_errorbar_size)+
  labs(x = 'Movement Duration (s)',
       y = bquote(Torque^2~"Rate"~(Nm)^2~"/s"),
       color = 'Effective\nMass (kg)')+
  guides(fill=guide_legend(title="Effective\nMass (kg)"))
# g


#================ MIN JERK Sum of Torque ==========================
# Do the same with minjerk torque.
# First uses the numbers alaa wants. Then fits a model.
mpdata$torque_mj = 0.8*(mpdata$effmass^2)/(mpdata$movedur^3)

a = 0
b_torque_mj = 0.8
c_torque_mj = 2
d_torque_mj = 3

torque2_mj_data$sum_t2_rate <- torque2_mj_data$sum_t2/torque2_mj_data$movedur

# torque2_mj_data2 = aggregate(sum_t2_rate ~ movedur + added_mass, torque2_mj_data, mean)
# torque2_mj_data2$effmass = aggregate(effmass ~ movedur + added_mass, torque2_mj_data, mean)$effmass
# torque2_mj_data = torque2_mj_data2
torque2_mj_data = filter(torque2_mj_data, movedur < 1.5)
torque2_mj_data2 = aggregate(sum_t2 ~ movedur + added_mass, torque2_mj_data, mean)
torque2_mj_data2$effmass = aggregate(effmass ~ movedur + added_mass, torque2_mj_data, mean)$effmass
torque2_mj_data2$sum_t2_rate <- torque2_mj_data2$sum_t2/torque2_mj_data2$movedur
torque2_mj_data = torque2_mj_data2

# New fitted model.
torque2_mj_model=nls(sum_t2_rate ~ a1*(effmass^a2)/(movedur^a3),
                  data=torque2_mj_data,
                  start=list(a1=1,a2=2,a3=5),
                  control = list(maxiter = 500))
modelsum_torque_mj = summary(torque2_mj_model)

a = 0
b_torque_mj=coef(torque2_mj_model)[1]
c_torque_mj=coef(torque2_mj_model)[2]
d_torque_mj=coef(torque2_mj_model)[3]

fun.1 <- function(t) b_torque_mj*(2.506^c_torque_mj)/(t^(d_torque_mj))
fun.2 <- function(t) b_torque_mj*(4.830^c_torque_mj)/(t^(d_torque_mj))
fun.3 <- function(t) b_torque_mj*(7.130^c_torque_mj)/(t^(d_torque_mj))
fun.4 <- function(t) b_torque_mj*(11.69^c_torque_mj)/(t^(d_torque_mj))
fun.5 <- function(t) b_torque_mj*(20^c_torque_mj)/(t^(d_torque_mj))

torque_mj_plot <- 
  plot_grid(ggplot(torque2_mj_data2,
            aes(x=movedur,
                y=sum_t2_rate))+
  geom_point(data = torque2_mj_data2,
                   aes(x=movedur,
                       y=sum_t2_rate,
                       fill = effmass),
                   shape=21,
                   color='black',
                   size=3)+
  stat_function(fun=fun.1,size=2,color=rgb(color1[1],color1[2],color1[3]))+
  stat_function(fun=fun.2,size=2,color=rgb(color2[1],color2[2],color2[3]))+
  stat_function(fun=fun.3,size=2,color=rgb(color3[1],color3[2],color3[3]))+
  stat_function(fun=fun.4,size=2,color=rgb(color4[1],color4[2],color4[3]))+
  stat_function(fun=fun.5,size=2,color='black')+
  # theme_classic()
  labs(x = 'Movement Duration (s)',
       y = bquote(Torque^2~"Rate"~(Nm)^2~"/s"),
       color = 'Effective\nMass (kg)')+
  guides(color=guide_legend(title="Effective\nMass (kg)"))+
  theme(legend.position = 'none'),
  get_legend(torque_plot),
  rel_widths = c(.85,.15))


```

We compute 4 effort models here. Gross metabolics, net metabolics, and sum of torque squared (experimentally calculated and calcualted from minimum jerk). Net and gross metabolics have been addressed before, here we add sum of torque squared.

Sum of torque squared is calcualted from the data and simulated minimum jerk profiles and then fit to an effort model like net metabolic and gross metabolic power but without the a parameter.

$$ \dot{e} = \frac{bm^c}{T_m^d} $$

The parameters fit for the effort models are shown in table \@ref(tab:effort_prarms).

## Torque Squared

```{r torqueplot1, echo = FALSE, warning = FALSE, message = FALSE, fig.cap = 'Sum of torque squared fits from the data'}
torque_plot
```

## Effort model parameters

This table shows a summary of all the parameters that were fitted in the effort models. SSE, AIC, and BIC can be found in their respective sections.
```{r effortprarms, echo = FALSE, warning = FALSE, message = FALSE}
# Shows parameter fits for mp net, mp gross, torque, and torque minimum jerk.
a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
tab1 = cbind(c(paste(round(a0,4),'±',round(a0_se,4),sep=''),
               paste(round(coef(MPNet_model)[1],4),'±',round(coef(modelsum_mpnet)[1,2],4),sep=' '),
               paste(round(coef(MPNet_model)[2],4),'±',round(coef(modelsum_mpnet)[2,2],4),sep=' '),
               paste(round(coef(MPNet_model)[3],4),'±',round(coef(modelsum_mpnet)[3,2],4),sep=' '),
               paste(round(coef(MPNet_model)[4],4),'±',round(coef(modelsum_mpnet)[4,2],4),sep=' '),
               sum(resid(MPNet_model)^2),
               AIC(MPNet_model),
               BIC(MPNet_model)),
            c(paste(round(a0,4),'±',round(a0_se,4),sep=''),
              paste(round(coef(MPGross_model)[1],4),'±',round(coef(modelsum_mpgross)[1,2],4),sep=' '),
              paste(round(coef(MPGross_model)[2]*100,4),'±',round(100*coef(modelsum_mpgross)[2,2],4),sep=' '),
              paste(round(coef(MPGross_model)[3],4),'±',round(coef(modelsum_mpgross)[3,2],4),sep=' '),
              paste(round(coef(MPGross_model)[4],4),'±',round(coef(modelsum_mpgross)[4,2],4),sep=' '),
              sum(resid(MPGross_model)^2),
              AIC(MPGross_model),
              BIC(MPGross_model)),
            c(0,0,
              paste(round(coef(modelsum_torque2)[1,1],4),'±',round(coef(modelsum_torque2)[1,2],4),sep=' '),
              paste(round(coef(modelsum_torque2)[2,1],4),'±',round(coef(modelsum_torque2)[2,2],4),sep=' '),
              paste(round(coef(modelsum_torque2)[3,1],4),'±',round(coef(modelsum_torque2)[3,2],4),sep=' '),
              sum(resid(modelsum_torque2)^2),
              AIC(torque2_model),
              BIC(torque2_model)),
            c(0,0,
              paste(round(coef(modelsum_torque_mj)[1,1],4),'±',round(coef(modelsum_torque_mj)[1,2],4),sep=' '),
              paste(round(coef(modelsum_torque_mj)[2,1],4),'±',round(coef(modelsum_torque_mj)[2,2],4),sep=' '),
              paste(round(coef(modelsum_torque_mj)[3,1],4),'±',round(coef(modelsum_torque_mj)[3,2],4),sep=' '),
              sum(resid(modelsum_torque_mj)^2),
              AIC(torque2_mj_model),
              BIC(torque2_mj_model)))
rownames(tab1) = c('a0','a','b','c','d','SSE','AIC','BIC')
colnames(tab1) = c('Net Metabolics', 'Gross Metabolics','Torque$^2$','Torque$^2$ minjerk')

```

```{r effortmodtab, echo = FALSE, warning = FALSE, message = FALSE}

  kable(tab1, caption = 'Parameters fit in the effort models.')

```


### Torque squared models with offset not forced to 0

Sum of torque squared is calculated from the data and simulated minimum jerk profiles and then fit to an effort model like net metabolic and gross metabolic power. In these we allowed $a$ to be fit to see if it would predict a 0 offset.

$$ \dot{e} = a+\frac{bm^c}{T_m^d} $$
```{r, echo = FALSE, warning = FALSE, message = FALSE}

torque2_model_a1=nls(sum_t2_rate ~ a1 + a2*(effmass^a3)/(movedur^a4),
                  data=torque2_data,
                  start=list(a1=1,a2=1,a3=1, a4=0),
                  control = list(iter = 50))
modelsum_torque2_a1 = summary(torque2_model_a1)

torque2_mj_model_a1=nls(sum_t2_rate ~ a1 + a2*(effmass^a3)/(movedur^a4),
                  data=torque2_mj_data,
                  start=list(a1=1,a2=2,a3=5, a4=0),
                  control = list(maxiter = 500))
modelsum_torque_mj_a1 = summary(torque2_mj_model_a1)

```

This table shows the confident intervals on the torque with $a$ model. The probability of $a$ ($a_1$) being greater than 0 is `r dnorm(0, coef(modelsum_torque2)[1,1] , coef(modelsum_torque2)[1,2])`.

```{r, echo = FALSE, warning = FALSE, message = FALSE}
kable(confint(torque2_model_a1), caption = 'Confidence intervals for torque squared model.')
```


# Probablity Modeling

The probability function for the 2a is:
$$ ln\left(\frac{P_i}{1-P_i}\right) = \beta_0 + \beta_1 x_1 $$
Which leads to
$$ P(Success|T) = \frac{1}{1+e^{-(\beta_0) - (\beta_1)T}} $$
Mass is removed from this probability as according to the model it is insignificant. Duration and mass also conditions here, so we only use duration.
I leave it $\beta_1$ because that is more similar to the glm with mass from experiment 1.

We then use this function to first fit an inverse logit to experiment 2a and 2b. We then use the criteria for success and fit the same inverse logit function but using the data from experiment 1.

## Probability of sucess in just 2a and 2b without 1
```{r, echo = FALSE}

pref_p_glm  = glm(success ~ movedur,
                 data=prefdata,
                 family=binomial(link="logit"))
prefdata$p_success = inv.logit(predict(pref_p_glm))

smallt_p_glm  = glm(success ~ movedur,
                    data=smalltdata,
                    family=binomial(link="logit"))
smalltdata$p_success = inv.logit(predict(smallt_p_glm))

```

The following table shows the beta coefficients for the inverse logit function only predicting from experiment 2a and 2b.

```{r betacoeffsprefsmallt, echo = FALSE, warning = FALSE}

tab = cbind(c(paste(round(coef(pref_p_glm)[1],4),'±',round(coef(summary(pref_p_glm))[1,2],3),sep=' '),
              paste(round(coef(pref_p_glm)[2],4),'±',round(coef(summary(pref_p_glm))[2,2],3),sep=' ')),
            c(paste(round(coef(smallt_p_glm)[1],4),'±',round(coef(summary(smallt_p_glm))[1,2],3),sep=' '),
              paste(round(coef(smallt_p_glm)[2],4),'±',round(coef(summary(smallt_p_glm))[2,2],3),sep=' ')))
rownames(tab) = c('$\\beta_0$','$\\beta_1$')
colnames(tab) = c('2a','2b')
kable(tab, caption = 'Beta coefficient for the inverse logit function to predict probability of success.')
```

Using these functions we can then predict the probability of success as a fraction of success given the data and using the logit model.
The following table shows this for experiment 2a and 2b.
```{r echo = FALSE, warning = FALSE}

pref_probs = inv.logit(predict(pref_p_glm,
                               newdata = aggregate(movedur~eff_mass,prefdata,mean)))

smallt_probs = inv.logit(predict(smallt_p_glm,newdata = aggregate(movedur~eff_mass,smalltdata,mean)))

success_tab = cbind(aggregate(success ~ eff_mass, prefdata,mean)$success,
                    pref_probs,
                    aggregate(success ~ eff_mass, smalltdata,mean)$success,
                    smallt_probs)
colnames(success_tab) = c('2a','Predicted 2a','2b','Predicted 2b')
rownames(success_tab) = unique(prefdata$eff_mass)
success_tab = round(success_tab,4)

kable(success_tab, caption = 'Success probabilities for experiment 2a and 2b. Also predicted from glm fitted using data from 2a and 2b')

```
We can also estimate the probability on the standard deviation of the miss distance.

```{r echo = FALSE, warning = FALSE}

pref_mean_err = aggregate(miss_dist ~ eff_mass,prefdata,mean)$miss_dist
pref_sd_err = aggregate(miss_dist ~ eff_mass,prefdata,sd)$miss_dist

# pnorm(0.014, mean= pref_mean_err, s = pref_sd_err,lower.tail=TRUE)

smallt_mean_err_ang = aggregate(missangle ~ eff_mass,smalltdata,mean)$missangle
smallt_sd_err_ang = aggregate(missangle ~ eff_mass,smalltdata,sd)$missangle

smallt_mean_err_rad = aggregate(maxex ~ eff_mass,smalltdata,mean)$missangle
smallt_sd_err_rad = aggregate(maxex ~ eff_mass,smalltdata,sd)$missangle


success_tab = cbind(aggregate(success ~ eff_mass, prefdata,mean)$success,
                    pnorm(0.014, mean= pref_mean_err, s = pref_sd_err,lower.tail=TRUE),
                    aggregate(success ~ eff_mass, smalltdata,mean)$success,
                    pnorm(0.014, mean= pref_mean_err, s = pref_sd_err,lower.tail=TRUE))
colnames(success_tab) = c('2a','Predicted 2a','2b','Predicted 2b')
rownames(success_tab) = unique(prefdata$eff_mass)
success_tab = round(success_tab,4)

kable(success_tab, caption = 'Success probabilities for experiment 2a and 2b. Also predicted from glm fitted using data from 2a and 2b. 2b Is off cause i havn\'t done the joint probability yet.')

```

### 2a and 2b GLM probability plots

```{r, echo = FALSE, warning = FALSE}
# This code chunk creates the probability plots. This is fitting a glm to
# Experiment 2a and 2b data.
# x axis is movement duration and y would be probability of success.
exp_succ2a = cbind(aggregate(movedur ~ eff_mass + subj,prefdata,mean),
                   aggregate(success ~ eff_mass + subj,prefdata,mean)$success,
                   rep('2a',4))
colnames(exp_succ2a) = c('eff_mass','subj','movedur','p_success','exp')
exp_succ2b = cbind(aggregate(movedur ~ eff_mass + subj,smalltdata,mean),
                   aggregate(success ~ eff_mass + subj,smalltdata,mean)$success,
                   rep('2b',4))
colnames(exp_succ2b) = c('eff_mass','subj','movedur','p_success','exp')
exp_succ = rbind(exp_succ2a,exp_succ2b)

exp_succ = rbind(cbind(aggregate(movedur ~ eff_mass, filter(exp_succ,exp=='2a'),mean),
                       aggregate(movedur ~ eff_mass, filter(exp_succ,exp=='2a'),sd)$movedur/sqrt(length(unique(exp_succ2a$subj))),
                       aggregate(p_success ~ eff_mass, filter(exp_succ,exp=='2a'),mean)$p_success,
                       aggregate(p_success ~ eff_mass, filter(exp_succ,exp=='2a'),sd)$p_success/sqrt(length(unique(exp_succ2a$subj))),
                       rep('2a',4)) %>% 
                   `colnames<-`(c("eff_mass","movedur","movedurse","p_success","p_success_se","exp")),
                 cbind(aggregate(movedur ~ eff_mass, filter(exp_succ,exp=='2b'),mean),
                       aggregate(movedur ~ eff_mass, filter(exp_succ,exp=='2b'),sd)$movedur/sqrt(length(unique(exp_succ2b$subj))),
                       aggregate(p_success ~ eff_mass, filter(exp_succ,exp=='2b'),mean)$p_success,
                       aggregate(p_success ~ eff_mass, filter(exp_succ,exp=='2b'),sd)$p_success/sqrt(length(unique(exp_succ2b$subj))),
                       rep('2b',4)) %>% 
                   `colnames<-`(c("eff_mass","movedur","movedurse","p_success","p_success_se","exp")))

masses = unique(prefdata$eff_mass)
fun.1 <- function(t) 1/(1+exp(-coef(pref_p_glm)[1]-coef(pref_p_glm)[2]*t))

fun.5 <- function(t) 1/(1+exp(-coef(smallt_p_glm)[1]-coef(smallt_p_glm)[2]*t))

sim_success = as.data.frame(cbind(c(rep(2.46,1000),rep(4.83,1000),rep(7.13,1000),rep(11.69,1000)),
                            c(seq(0,2,length.out=1000),seq(0,2,length.out=1000),seq(0,2,length.out=1000),seq(0,2,length.out=1000))))
colnames(sim_success) = c('eff_mass','movedur')

line_types = c('line_pref' = 'solid','line_smallt' = 'dashed')
p_alpha_2a_2b_glm <- ggplot(data=sim_success,
       aes(x=movedur))+
  stat_function(fun=fun.1,size=1,color='black')+
  stat_function(fun=fun.5,size=1,linetype='dashed',color='black')+
  geom_errorbar(data = exp_succ,
                aes(x     = movedur,
                    ymin  = p_success-p_success_se,
                    ymax  = p_success+p_success_se,
                    color = factor(eff_mass)),
                width = 0,
                size  = met_errorbar_size + 2)+
  geom_errorbarh(data = exp_succ,
                 aes(xmin  = movedur-movedurse,
                     xmax  = movedur+movedurse,
                     y     = p_success,
                     color = factor(eff_mass)),
                 height = 0,
                 size   = met_errorbar_size + 2)+
  scale_color_manual(labels = masses,
                     values = mass_colors)+
  scale_fill_manual(values = mass_colors,
                    labels = unique(metdata$eff_mass))+
  scale_linetype_manual(name = 'Smooth',
                        values = line_types)+
  scale_shape_manual(values = c(21,22),
                     labels = c('2a','2b'))+
  guides(color = guide_legend(title="Effective\nMass (kg)"),
         linetype = guide_legend(title = 'Target Type'),
         shape = guide_legend(title = 'Target Type'),
         fill =  'none',
         size = 'none')+
  labs(x='Movement Duration (s)',y='Probability of\nSuccess')+
  # theme_classic()
  theme(text              = element_text(size=20,color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        legend.text       = element_text(size=15),
        legend.text.align = 0,
        legend.position   = 'right',
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))+
  scale_y_continuous(expand = c(0, 0), limits = c(0, 1.05))


```

The plot below shows the fits of the glm's fitted to only data from experiment 2a and 2b. Unfortunately, these glm's don't seem to have the same behavior as data fitted to experiment 1 of dropping off to 0 at faster speeds. This is probably due to the lack of really fast or really slow trials so it just predicts a flat line essentially.

```{r PAlpha2a2bGlmFig, echo=FALSE, warning = FALSE,  fig.width=8, fig.height=7, fig.cap = 'Probability of success with glm fitted to experiment 2a and 2b data.'}

p_alpha_2a_2b_glm

```

## Probability of success using experiment 1

$$ P(Success|T) = \frac{1}{1+e^{-(\beta_0) - (\beta_1)T - (\beta_2)m}} $$

```{r, echo = FALSE}
# This is similar to the previous chunk, except it fits the data to experiment 1.
# Using the criteria from 2a/2b we can estimate sucess by movement speed and mass.

metdata$success_2a = abs(metdata$miss_dist)<.014
met_p_glm  = glm(success_2a ~ movedur+eff_mass,
                 data=metdata,
                 family=binomial(link="logit"))
metdata$p_success_2a = inv.logit(predict(met_p_glm))

metdata$success_2b = abs(metdata$maxex)<.110 & abs(metdata$missangle)<7
met_smallt_p_glm  = glm(success_2b ~ movedur+eff_mass,
                    data=metdata,
                    family=binomial(link="logit"))
metdata$p_success_2b = inv.logit(predict(met_smallt_p_glm))

# # This is here if I want to change the probabilities
# prefdata$success = abs(prefdata$miss_dist)<.014
# exp_succ2a = cbind(aggregate(movedur ~ eff_mass + subj,prefdata,mean),
#                    aggregate(success ~ eff_mass + subj,prefdata,mean)$success,
#                    rep('2a',4))
# colnames(exp_succ2a) = c('eff_mass','subj','movedur','p_success','exp')
# smalltdata$success = abs(smalltdata$maxex)<.112 & abs(smalltdata$missangle)<7
# exp_succ2b = cbind(aggregate(movedur ~ eff_mass + subj,smalltdata,mean),
#                    aggregate(success ~ eff_mass + subj,smalltdata,mean)$success,
#                    rep('2b',4))
# colnames(exp_succ2b) = c('eff_mass','subj','movedur','p_success','exp')
# exp_succ = rbind(exp_succ2a,exp_succ2b)
# 
# exp_succ = rbind(cbind(aggregate(movedur ~ eff_mass, filter(exp_succ,exp=='2a'),mean),
#                        aggregate(movedur ~ eff_mass, filter(exp_succ,exp=='2a'),sd)$movedur/sqrt(length(unique(exp_succ2a$subj))),
#                        aggregate(p_success ~ eff_mass, filter(exp_succ,exp=='2a'),mean)$p_success,
#                        aggregate(p_success ~ eff_mass, filter(exp_succ,exp=='2a'),sd)$p_success/sqrt(length(unique(exp_succ2a$subj))),
#                        rep('2a',4)) %>% 
#                    `colnames<-`(c("eff_mass","movedur","movedurse","p_success","p_success_se","exp")),
#                  cbind(aggregate(movedur ~ eff_mass, filter(exp_succ,exp=='2b'),mean),
#                        aggregate(movedur ~ eff_mass, filter(exp_succ,exp=='2b'),sd)$movedur/sqrt(length(unique(exp_succ2b$subj))),
#                        aggregate(p_success ~ eff_mass, filter(exp_succ,exp=='2b'),mean)$p_success,
#                        aggregate(p_success ~ eff_mass, filter(exp_succ,exp=='2b'),sd)$p_success/sqrt(length(unique(exp_succ2b$subj))),
#                        rep('2b',4)) %>% 
#                    `colnames<-`(c("eff_mass","movedur","movedurse","p_success","p_success_se","exp")))

# cftest(lmer(p_success_met ~ log(movedur) + eff_mass + (1|subj), metdata))
# cftest(lmer(log(p_success_met) ~ log(movedur) + eff_mass + (1|subj), metdata))
# aov(log(p_success_met) ~ log(movedur) + eff_mass + (1|subj), metdata)
# plot(TukeyHSD(aov(log(p_success_met) ~ factor(speed) + factor(eff_mass) + (1|subj), metdata),whcih=eff_mass))

variable = 'p_success_2a'
variable2 = 'p_success_2b'
string = paste('
               pdata = cbind(aggregate(movedur ~ speed + condition,metdata,mean),
               aggregate(movedur ~ speed + condition,metdata,sd)$movedur/sqrt(8),
               aggregate(',variable,' ~ speed + condition,metdata,mean)$',variable,',
               aggregate(',variable,' ~ speed + condition,metdata,sd)$',variable,'/sqrt(8))
               colnames(pdata) = c(\'speed\',\'condition\',\'movedur\',\'movedurse\',\'yvar\',\'yvarse\')',sep='')
eval(parse(text = string))
names = colnames(pdata)
pdata$prob_meth = 'metabolics'
colnames(pdata) = c(names,'exp')

variable = 'p_success_2b'
string = paste('
               pdata2 = cbind(aggregate(movedur ~ speed + condition,metdata,mean),
               aggregate(movedur ~ speed + condition,metdata,sd)$movedur/sqrt(8),
               aggregate(',variable,' ~ speed + condition,metdata,mean)$',variable,',
               aggregate(',variable,' ~ speed + condition,metdata,sd)$',variable,'/sqrt(8))
               colnames(pdata2) = c(\'speed\',\'condition\',\'movedur\',\'movedurse\',\'yvar\',\'yvarse\')',sep='')
eval(parse(text = string))
names = colnames(pdata2)
pdata2$prob_meth = 'smallt'
colnames(pdata2) = c(names,'exp')

pdata = rbind(pdata,pdata2)

fun.1 <- function(t) 1/(1+exp(-coef(met_p_glm)[1]-coef(met_p_glm)[3]*2.44-coef(met_p_glm)[2]*t))
fun.2 <- function(t) 1/(1+exp(-coef(met_p_glm)[1]-coef(met_p_glm)[3]*4.83-coef(met_p_glm)[2]*t))
fun.3 <- function(t) 1/(1+exp(-coef(met_p_glm)[1]-coef(met_p_glm)[3]*7.13-coef(met_p_glm)[2]*t))
fun.4 <- function(t) 1/(1+exp(-coef(met_p_glm)[1]-coef(met_p_glm)[3]*11.69-coef(met_p_glm)[2]*t))

fun.5 <- function(t) 1/(1+exp(-coef(met_smallt_p_glm)[1]-coef(met_smallt_p_glm)[3]*2.44-coef(met_smallt_p_glm)[2]*t))
fun.6 <- function(t) 1/(1+exp(-coef(met_smallt_p_glm)[1]-coef(met_smallt_p_glm)[3]*4.83-coef(met_smallt_p_glm)[2]*t))
fun.7 <- function(t) 1/(1+exp(-coef(met_smallt_p_glm)[1]-coef(met_smallt_p_glm)[3]*7.13-coef(met_smallt_p_glm)[2]*t))
fun.8 <- function(t) 1/(1+exp(-coef(met_smallt_p_glm)[1]-coef(met_smallt_p_glm)[3]*11.69-coef(met_smallt_p_glm)[2]*t))

# line_types = c('line_pref' = 'solid','line_smallt' = 'dashed')
# p_alpha_plot_cont <- ggplot(data=metdata,
#        aes(x=movedur))+
#    geom_rect(xmin = min(aggregate(movedur~eff_mass,prefdata,mean)$movedur),
#              xmax = max(aggregate(movedur~eff_mass,prefdata,mean)$movedur),
#              ymin = 0,
#              ymax = 2,
#              fill = alpha("grey",0),
#              color = 'Black')+
#    geom_rect(xmin = min(aggregate(movedur~eff_mass,smalltdata,mean)$movedur),
#              xmax = max(aggregate(movedur~eff_mass,smalltdata,mean)$movedur),
#              ymin = 0,
#              ymax = 2,
#              fill = alpha("grey",0),
#              color = 'Red')+
#   stat_function(fun=fun.1,size=1,color=rgb(color1[1],color1[2],color1[3]))+
#   stat_function(fun=fun.2,size=1,color=rgb(color2[1],color2[2],color2[3]))+
#   stat_function(fun=fun.3,size=1,color=rgb(color3[1],color3[2],color3[3]))+
#   stat_function(fun=fun.4,size=1,color=rgb(color4[1],color4[2],color4[3]))+
#   stat_function(fun=fun.5,size=1,linetype='dashed',color=rgb(color1[1],color1[2],color1[3]))+
#   stat_function(fun=fun.6,size=1,linetype='dashed',color=rgb(color2[1],color2[2],color2[3]))+
#   stat_function(fun=fun.7,size=1,linetype='dashed',color=rgb(color3[1],color3[2],color3[3]))+
#   stat_function(fun=fun.8,size=1,linetype='dashed',color=rgb(color4[1],color4[2],color4[3]))+
#   geom_point(data = pdata,
#              aes(x = movedur,
#                  y = yvar,
#                  color = factor(condition)),
#              size = 3)+
#   geom_point(data = pdata,
#              aes(x = movedur,
#                  y = yvar,
#                  fill = factor(condition),
#                  shape = exp),
#              size = 4)+
#   scale_color_manual(labels = unique(metdata$eff_mass),
#                      values = mass_colors)+
#   scale_fill_manual(values = mass_colors, 
#                     labels = unique(metdata$eff_mass))+
#   scale_linetype_manual(name = 'Smooth', 
#                         values = line_types)+
#   scale_shape_manual(values = c(21,22),
#                      labels = c('2a','2b'))+
#   guides(color = guide_legend(title="Effective\nMass (kg)"),
#          linetype = guide_legend(title = 'Target Type'),
#          shape = guide_legend(title = 'Target Type'),
#          fill =  'none',
#          size = 'none')+
#   labs(x='Movement Duration (s)',y='Probability of\nSuccess')+
#   # theme_classic()
#   theme(text              = element_text(size=20,color='black'),
#         axis.text         = element_text(color='black'),
#         axis.ticks        = element_line(color='black'),
#         legend.text       = element_text(size=15),
#         legend.text.align = 0,
#         legend.position   = 'right',
#         plot.title        = element_text(hjust = 0.5),
#         axis.line         = element_line(color='black'))+
#   scale_y_continuous(expand = c(0, 0), limits = c(0, 1.05))
# 
# setwd(pref_plots_dir)
# if (save_plots){ggsave(filename='p_alpha_plot_cont.pdf',plot=p_alpha_plot_cont,height=6,width=9,useDingbats=FALSE)}

sim_success = as.data.frame(cbind(c(rep(2.46,1000),rep(4.83,1000),rep(7.13,1000),rep(11.69,1000)),
                            c(seq(0,2,length.out=1000),seq(0,2,length.out=1000),seq(0,2,length.out=1000),seq(0,2,length.out=1000))))
colnames(sim_success) = c('eff_mass','movedur')

line_types = c('line_pref' = 'solid','line_smallt' = 'dashed')
p_alpha_plot_cont2 <- ggplot(data=sim_success,
       aes(x=movedur))+
   geom_rect(xmin = min(aggregate(movedur~eff_mass,prefdata,mean)$movedur),
             xmax = max(aggregate(movedur~eff_mass,prefdata,mean)$movedur),
             ymin = 0,
             ymax = 2,
             fill = alpha("grey",0),
             color = 'Black')+
   geom_rect(xmin = min(aggregate(movedur~eff_mass,smalltdata,mean)$movedur),
             xmax = max(aggregate(movedur~eff_mass,smalltdata,mean)$movedur),
             ymin = 0,
             ymax = 2,
             fill = alpha("grey",0),
             color = 'Red')+
  stat_function(fun=fun.1,size=met_line_size+2,color='black')+
  stat_function(fun=fun.2,size=met_line_size+2,color='black')+
  stat_function(fun=fun.3,size=met_line_size+2,color='black')+
  stat_function(fun=fun.4,size=met_line_size+2,color='black')+
  stat_function(fun=fun.5,size=met_line_size+2,linetype='dashed',color='black')+
  stat_function(fun=fun.6,size=met_line_size+2,linetype='dashed',color='black')+
  stat_function(fun=fun.7,size=met_line_size+2,linetype='dashed',color='black')+
  stat_function(fun=fun.8,size=met_line_size+2,linetype='dashed',color='black')+
  stat_function(fun=fun.1,size=met_line_size+1,color=rgb(color1[1],color1[2],color1[3]))+
  stat_function(fun=fun.2,size=met_line_size+1,color=rgb(color2[1],color2[2],color2[3]))+
  stat_function(fun=fun.3,size=met_line_size+1,color=rgb(color3[1],color3[2],color3[3]))+
  stat_function(fun=fun.4,size=met_line_size+1,color=rgb(color4[1],color4[2],color4[3]))+
  stat_function(fun=fun.5,size=met_line_size+1,linetype='dashed',color=rgb(color1[1],color1[2],color1[3]))+
  stat_function(fun=fun.6,size=met_line_size+1,linetype='dashed',color=rgb(color2[1],color2[2],color2[3]))+
  stat_function(fun=fun.7,size=met_line_size+1,linetype='dashed',color=rgb(color3[1],color3[2],color3[3]))+
  stat_function(fun=fun.8,size=met_line_size+1,linetype='dashed',color=rgb(color4[1],color4[2],color4[3]))+
  geom_point(data = pdata,
             aes(x = movedur,
                 y = yvar,
                 color = factor(condition)),
             size = 5)+
  geom_point(data = pdata,
             aes(x = movedur,
                 y = yvar,
                 fill = factor(condition),
                 shape = exp),
             size = 6)+
  scale_color_manual(labels = unique(metdata$eff_mass),
                     values = mass_colors)+
  scale_fill_manual(values = mass_colors, 
                    labels = unique(metdata$eff_mass))+
  scale_linetype_manual(name = 'Smooth', 
                        values = line_types)+
  scale_shape_manual(values = c(21,22),
                     labels = c('2a','2b'))+
  guides(color = guide_legend(title="Effective\nMass (kg)"),
         linetype = guide_legend(title = 'Target Type'),
         shape = guide_legend(title = 'Target Type'),
         fill =  'none')+
  labs(x='Movement Duration (s)',y='Probability of\nSuccess')+
  # theme_classic()
  theme(text              = element_text(size=20,color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        legend.text       = element_text(size=15),
        legend.text.align = 0,
        legend.position   = 'right',
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))+
  scale_y_continuous(expand = c(0, 0), limits = c(0, 1.05))

setwd(pref_plots_dir)
if (save_plots){ggsave(filename='p_alpha_plot_cont2.pdf',plot=p_alpha_plot_cont2,height=6,width=9,useDingbats=FALSE)}

masses = unique(prefdata$eff_mass)
fun.1 <- function(t) 1/(1+exp(-coef(met_p_glm)[1]-coef(met_p_glm)[3]*masses[1]-coef(met_p_glm)[2]*t))
fun.2 <- function(t) 1/(1+exp(-coef(met_p_glm)[1]-coef(met_p_glm)[3]*masses[2]-coef(met_p_glm)[2]*t))
fun.3 <- function(t) 1/(1+exp(-coef(met_p_glm)[1]-coef(met_p_glm)[3]*masses[3]-coef(met_p_glm)[2]*t))
fun.4 <- function(t) 1/(1+exp(-coef(met_p_glm)[1]-coef(met_p_glm)[3]*masses[4]-coef(met_p_glm)[2]*t))

fun.5 <- function(t) 1/(1+exp(-coef(met_smallt_p_glm)[1]-coef(met_smallt_p_glm)[3]*masses[1]-coef(met_smallt_p_glm)[2]*t))
fun.6 <- function(t) 1/(1+exp(-coef(met_smallt_p_glm)[1]-coef(met_smallt_p_glm)[3]*masses[2]-coef(met_smallt_p_glm)[2]*t))
fun.7 <- function(t) 1/(1+exp(-coef(met_smallt_p_glm)[1]-coef(met_smallt_p_glm)[3]*masses[3]-coef(met_smallt_p_glm)[2]*t))
fun.8 <- function(t) 1/(1+exp(-coef(met_smallt_p_glm)[1]-coef(met_smallt_p_glm)[3]*masses[4]-coef(met_smallt_p_glm)[2]*t))

line_types = c('line_pref' = 'solid','line_smallt' = 'dashed')
p_alpha_plot_cont <- ggplot(data=metdata,
       aes(x=movedur))+
  stat_function(fun=fun.1,size=met_line_size+2,color='black')+
  stat_function(fun=fun.2,size=met_line_size+2,color='black')+
  stat_function(fun=fun.3,size=met_line_size+2,color='black')+
  stat_function(fun=fun.4,size=met_line_size+2,color='black')+
  stat_function(fun=fun.5,size=met_line_size+2,linetype='dashed',color='black')+
  stat_function(fun=fun.6,size=met_line_size+2,linetype='dashed',color='black')+
  stat_function(fun=fun.7,size=met_line_size+2,linetype='dashed',color='black')+
  stat_function(fun=fun.8,size=met_line_size+2,linetype='dashed',color='black')+
  stat_function(fun=fun.1,size=met_line_size+1,color=rgb(color1[1],color1[2],color1[3]))+
  stat_function(fun=fun.2,size=met_line_size+1,color=rgb(color2[1],color2[2],color2[3]))+
  stat_function(fun=fun.3,size=met_line_size+1,color=rgb(color3[1],color3[2],color3[3]))+
  stat_function(fun=fun.4,size=met_line_size+1,color=rgb(color4[1],color4[2],color4[3]))+
  stat_function(fun=fun.5,size=met_line_size+1,linetype='dashed',color=rgb(color1[1],color1[2],color1[3]))+
  stat_function(fun=fun.6,size=met_line_size+1,linetype='dashed',color=rgb(color2[1],color2[2],color2[3]))+
  stat_function(fun=fun.7,size=met_line_size+1,linetype='dashed',color=rgb(color3[1],color3[2],color3[3]))+
  stat_function(fun=fun.8,size=met_line_size+1,linetype='dashed',color=rgb(color4[1],color4[2],color4[3]))+
  # geom_errorbar(data = pdata,
  #               aes(x=movedur,
  #                   ymin=yvar-yvarse,
  #                   ymax=yvar+yvarse,
  #                   color = factor(condition)),
  #               width = 0,
  #               size = met_errorbar_size)+
  # geom_errorbarh(data=pdata,
  #                aes(xmin=movedur-movedurse,
  #                    xmax=movedur+movedurse,
  #                    y=yvar,
  #                    color=factor(condition)),
  #                height = 0,
  #                size = met_errorbar_size)+
  geom_errorbar(data = exp_succ,
                aes(x     = movedur,
                    ymin  = p_success-p_success_se-.001,
                    ymax  = p_success+p_success_se+.001),
                color = 'black',
                width = 0,
                size  = met_errorbar_size + 2)+
  geom_errorbarh(data = exp_succ,
                 aes(xmin  = movedur-movedurse-.001,
                     xmax  = movedur+movedurse+.001,
                color = 'black',
                     y     = p_success),
                 height = 0,
                 size   = met_errorbar_size + 2)+
  geom_errorbar(data = exp_succ,
                aes(x     = movedur,
                    ymin  = p_success-p_success_se,
                    ymax  = p_success+p_success_se,
                    color = factor(eff_mass)),
                width = 0,
                size  = met_errorbar_size + 1)+
  geom_errorbarh(data = exp_succ,
                 aes(xmin  = movedur-movedurse,
                     xmax  = movedur+movedurse,
                     y     = p_success,
                     color = factor(eff_mass)),
                 height = 0,
                 size   = met_errorbar_size + 1)+
  # geom_point(data = exp_succ,
  #            aes(x = movedur,
  #                y = p_success),
  #            size = 4)+
  scale_color_manual(labels = c(masses,'null'),
                     values = c(mass_colors,'black'))+
  scale_fill_manual(values = mass_colors,
                    labels = unique(metdata$eff_mass))+
  scale_linetype_manual(name = 'Smooth',
                        values = line_types)+
  scale_shape_manual(values = c(21,22),
                     labels = c('2a','2b'))+
  guides(color = guide_legend(title="Effective\nMass (kg)"),
         linetype = guide_legend(title = 'Target Type'),
         shape = guide_legend(title = 'Target Type'),
         fill =  'none',
         size = 'none')+
  labs(x='Movement Duration (s)',y='Probability of\nSuccess')+
  # theme_classic()
  theme(text              = element_text(size=20,color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        legend.text       = element_text(size=15),
        legend.text.align = 0,
        legend.position   = 'right',
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))+
  scale_y_continuous(expand = c(0, 0), limits = c(0, 1.05))


```


This table shows the beta coefficients when using an inverse logit on experiment 1 trying to predict 2a and 2b.

```{r betacoeffs, echo = FALSE, warning = FALSE}
# This section creates a table to report the beta values for this fit.
tab = cbind(c(paste(round(coef(met_p_glm)[1],4),'±',round(coef(summary(met_p_glm))[1,2],3),sep=' '),
              paste(round(coef(met_p_glm)[2],4),'±',round(coef(summary(met_p_glm))[2,2],3),sep=' '),
              paste(round(coef(met_p_glm)[3],4),'±',round(coef(summary(met_p_glm))[3,2],3),sep=' ')),
            c(paste(round(coef(met_smallt_p_glm)[1],4),'±',round(coef(summary(met_smallt_p_glm))[1,2],3),sep=' '),
              paste(round(coef(met_smallt_p_glm)[2],4),'±',round(coef(summary(met_smallt_p_glm))[2,2],3),sep=' '),
              paste(round(coef(met_smallt_p_glm)[3],4),'±',round(coef(summary(met_smallt_p_glm))[3,2],3),sep=' ')))
rownames(tab) = c('$\\beta_0$','$\\beta_1$','$\\beta_2$')
colnames(tab) = c('2a','2b')
kable(tab, caption = 'Beta coefficient for the inverse logit function to predict probability of success.')
```

This plot only includes movement durations that are seen in the metabolic experiment. The black vertical bars show the range of durations for the 2a preferred exerpiement. The red vertical bars show the range of durations for the smallt target.

```{r palphaplotcont1, echo = FALSE, warning = FALSE, fig.width=9, fig.height=6, fig.cap = 'Probability of success given movement duration and mass. The black vertical bars show the range of durations for the 2a preferred exerpiement. The red vertical bars show the range of durations for the smallt target.'}
  p_alpha_plot_cont
```

This plot includes low and high movement durations to show that the functions converge to 0 and 1 probability respectively.

```{r palphaplotcont2, echo = FALSE, warning = FALSE, fig.width=9, fig.height=6, fig.cap = 'Probability of success given movement duration and mass. The black vertical bars show the range of durations for the 2a preferred exerpiement. The red vertical bars show the range of durations for the smallt target.'}
  p_alpha_plot_cont2
```

This next table shows the movement durations for experiment 2a and 2b, the probability of success from the experiment, along with the probability of success from the logistic regression. The last row is the mean probability.

```{r echo = FALSE, warning = FALSE}
# This chunk produces a table of experimental probabilities and predicted
# probabilities of sucess.
pref_probs = inv.logit(predict(met_p_glm,newdata = aggregate(movedur~eff_mass,prefdata,mean)))

smallt_probs = inv.logit(predict(met_smallt_p_glm,newdata = aggregate(movedur~eff_mass,smalltdata,mean)))

movedur_probs = cbind(c(aggregate(movedur~eff_mass,prefdata,mean)$movedur,
                        NaN),
                      c(aggregate(success ~ eff_mass, prefdata,mean)$success,
                        mean(aggregate(success ~ eff_mass, prefdata,mean)$success)),
                      c(pref_probs,
                        mean(pref_probs)),
                      c(aggregate(movedur~eff_mass,smalltdata,mean)$movedur,
                        NaN),
                      c(aggregate(success ~ eff_mass, smalltdata,mean)$success,
                        mean(aggregate(success ~ eff_mass, smalltdata,mean)$success)),
                      c(smallt_probs,
                        mean(smallt_probs)))

movedur_probs = round(movedur_probs,4)
rownames(movedur_probs) = c('2.506 ','3.959 ','4.894 ','6.282 ','Mean')
colnames(movedur_probs) = c('2a Movedur','2a Exp Prob','2a Pred Prob','2b Movedur','2b Exp Prob','2b Pred Prob')
```

```{r movement_duration_probs1, echo = FALSE, warning = FALSE, tab.cap = 'Probability of success for 2a/2b fitted from data in experiment 1.'}
kable(movedur_probs)
```

### Success at metabolically optimal
The table (\@ref{tab:optdurprob}) shows the metabolically optimal (gross) durations with the predicted probabilities from the glm using experiment 1 and 2a.

```{r optdurprob, echo = FALSE, warning = FALSE, message = FALSE}
# This geneates a table of the probability of sucess at the metabolically optimal
# speeds.
a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]

fun.1 <- function(t) a*t+b*(2.506^c)/(t^(d-1))
fun.2 <- function(t) a*t+b*(3.959^c)/(t^(d-1))
fun.3 <- function(t) a*t+b*(4.894^c)/(t^(d-1))
fun.4 <- function(t) a*t+b*(6.282^c)/(t^(d-1))

met_gross_dur = c(optimize(fun.1,interval=c(0,2))$minimum,
                  optimize(fun.2,interval=c(0,2))$minimum,
                  optimize(fun.3,interval=c(0,2))$minimum,
                  optimize(fun.4,interval=c(0,4))$minimum)


kable(data.frame('Effective Mass' = unique(metdata$eff_mass),
                 'Duration' = met_gross_dur,
                 'Success Prob' = inv.logit(predict(met_p_glm,data.frame(movedur= met_gross_dur,eff_mass=unique(metdata$eff_mass))))),
      caption = 'Success probabilites from experiment 2a/1 at the metabolically optimal duraitons.')
```

## Predicting movedur off of probability

```{r, echo = FALSE}
# This code chunk finds the probability of success at the movement durations seen
# in 2a/2b.

# mvttimes_pref = aggregate(movedur~condition,prefdata,mean)$movedur
# mvttimes_smallt = aggregate(movedur~condition,smalltdata,mean)$movedur
mvttimes_pref = aggregate(movedur ~ condition, aggregate(movedur ~ condition + subj, prefdata,mean),mean)$movedur
mvttimes_smallt = aggregate(movedur ~ condition, aggregate(movedur ~ condition + subj, smalltdata,mean),mean)$movedur

# colnames(prob_dur) = c('movedur','mass')
# print(paste('Preferred Experiment, P_thresh = ',p_thresh,sep=''))
prob_dur_opt <- function(p_thresh,mvttimes,exp_glm){
  prob_dur = c()
  for (mass in unique(prefdata$eff_mass)){
    probs = inv.logit(predict(exp_glm,data.frame(movedur=seq(.3,1.5,.001),eff_mass=mass)))
    dur_count = 1
    for (dur in seq(.3,1.5,.001)){
      if (probs[dur_count]>p_thresh){
        # print(paste('Movdur = ',dur,'. Mass = ',mass,sep=''))
        prob_dur = rbind(prob_dur,dur)
        break
      } else{
        dur_count = dur_count+1
      }
    }
  }
  return(sum((prob_dur-mvttimes)^2))
  # return(prob_dur)
}

prob_dur_func <- function(p_thresh,exp_glm){
  prob_dur = c()
  for (mass in unique(prefdata$eff_mass)){
    probs = inv.logit(predict(exp_glm,data.frame(movedur=seq(.3,1.5,.001),eff_mass=mass)))
    dur_count = 1
    for (dur in seq(.3,1.5,.001)){
      if (probs[dur_count]>p_thresh){
        # print(paste('Movdur = ',dur,'. Mass = ',mass,sep=''))
        prob_dur = rbind(prob_dur,dur)
        break
      } else{
        dur_count = dur_count+1
      }
    }
  }
  return(prob_dur)
}

prob_dur_p_thresh = optimize(prob_dur_opt,
                mvttimes = mvttimes_pref,
                exp_glm = met_p_glm,
                interval = c(.1,.999999))
prob_dur_pref <- prob_dur_func(prob_dur_p_thresh$minimum,
                               exp_glm = met_p_glm)

pref_tab = cbind(c('2.506','3.959','4.894','6.282'),prob_dur_pref,round(mvttimes_pref,3))
colnames(pref_tab) = c('Effective Mass (kg)','Predicted Duration','Preferred Duration')
rownames(pref_tab) = c('','','','')

prob_dur_p_thresh_smallt = optimize(prob_dur_opt,
                mvttimes = mvttimes_smallt,
                exp_glm = met_smallt_p_glm,
                interval = c(.1,.999999))
prob_dur_smallt <- prob_dur_func(prob_dur_p_thresh_smallt$minimum,
                                 exp_glm = met_smallt_p_glm)

smallt_tab = cbind(c('2.506','3.959','4.894','6.282'),prob_dur_smallt,round(mvttimes_smallt,3))
colnames(smallt_tab) = c('Effective Mass (kg)','Predicted Duration','Preferred Duration')
rownames(smallt_tab) = c('','','','')

accuracy_SSE_pref = sum((as.numeric(pref_tab[,2])-as.numeric(aggregate(movedur~eff_mass,prefdata,mean)$movedur))^2)
accuracy_SSE_smallt = sum((as.numeric(pref_tab[,2])-as.numeric(aggregate(movedur~eff_mass,smalltdata,mean)$movedur))^2)

```

The probability of reward that minimizes the error of predicted movement durations for the 2a experiment is `r round(prob_dur_p_thresh$minimum,4)`. The table below shows the predicted movement durations and the expected movement durations. The SSE of this prediction is `r accuracy_SSE_pref`.

```{r prefprobtab1, echo = FALSE}
  kable(pref_tab, caption = paste('Predicted movement durations for the 2a given probability of: ',round(prob_dur_p_thresh$minimum,4),sep=''))
```

The probability of reward that minimizes the error of predicted movement durations for the 2a experiment is `r round(prob_dur_p_thresh_smallt$minimum,4)`. The table below shows hte predicted movement durations and the expected movement durations. The SSE of this prediction is `r accuracy_SSE_smallt`.

```{r smalltprobtab1, echo = FALSE}
  kable(smallt_tab, caption = paste('Predicted movement durations for the 2b given probability of: ',round(prob_dur_p_thresh_smallt$minimum,4),sep=''))
```

# Utility Modeling

## Individual Utility
This plot below shows individual subjects and their utility fits. This uses gross metabolics as the effort term.

```{r, echo = FALSE}
# This chunk optimizes our classic utility for each subject, and then produces a
# and reports the average a value in the plot.

a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]

# There are a lot of 'fun_optim_prx', this finds the alpha value that minimizes
# the SSE of movement duration and predicted duration maximizing utility by
# changing alpha.
fun_optim_prx <- function(alpha,masses,mvttimes,p_alpha,rxtimes){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = p_alpha[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.1,5,0.01)
    ut = rep(0,length(times))
    for (t in times){
      ut[count] = (alpha*p-a0*rt-(a*t+b*(m^c)/(t^(d-1))))/(rt+t)
      count = count+1
    }
    dur[k] = times[which.max(ut)]
  }
  err = (mvttimes-dur)^2
  return(sum(err))
}

fun_dur_prx <- function(alpha,masses,mvttimes,p_alpha,rxtimes){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = p_alpha[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.2,5,0.01)
    ut = rep(0,length(times))
    for (t in times){
      ut[count] = (alpha*p-a0*rt-(a*t+b*(m^c)/(t^(d-1))))/(rt+t)
      count = count+1
    }
    dur[k] = times[which.max(ut)]
  }
  return(dur)
}

alphas = c()
modeled <- data.frame(subj=integer(),condition=factor(),eff_mass=double(),movedur=double(),model=factor())
for (subjn in 1:max(prefdata$subj)){
  masses   = eff_masses_pref[,subjn]
  mvttimes = aggregate(movedur~condition,filter(prefdata,subj==subjn),mean)$movedur
  rxtimes = aggregate(reaction_tanv~condition,filter(prefdata,subj==subjn),mean)$reaction_tanv
  p_alpha_pref = inv.logit(predict(met_p_glm,data.frame(movedur=mvttimes,eff_mass=masses)))
  
  test = optimize(fun_optim_prx,
                  masses   = masses,
                  mvttimes = mvttimes,
                  p_alpha  = p_alpha_pref,
                  rxtimes  = rxtimes,
                  interval = c(-1000,1000))
  dur  = as.numeric(fun_dur_prx(test$minimum,
                                masses   = masses,
                                mvttimes = mvttimes,
                                p_alpha  = p_alpha_pref,
                                rxtimes  = rxtimes))
  
  alphas = c(alphas,test$minimum)
  
  modeled = rbind(modeled,cbind(rep(subjn,4),
                                c(1,2,3,4),
                                c(masses),
                                c(mvttimes),
                                c(0,0,0,0)),
                          cbind(rep(subjn,4),
                                c(1,2,3,4),
                                c(masses),
                                c(dur),
                                c(1,1,1,1)))
}
colnames(modeled) = c('subj','condition','eff_mass','movedur','model')
utility_ind <- ggplot()+
  geom_line(data=modeled,
            aes(x=eff_mass,
                y=movedur,
                color=factor(subj),
                linetype=factor(model)),
            size=2)+
  labs(x        = 'Effective Mass (kg)',
       y        = 'Movement Duration (s)', 
       color    = 'Subject',
       linetype = 'Solid=Data\nDashed=Model',
       title    = 'Utility Modeling by Subject')+
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))

# if (save_plots){
#   setwd(pref_plots_dir)
#   ggsave(filename='utility_ind.pdf',plot=utility_ind,height=6,width=9,useDingbats=FALSE)
#   write.csv(modeled,'Modeled_alpha.csv')
# }

```

The average fitted $\alpha$ value was `r round(mean(alphas),4)`.

```{r utilityind1, echo = FALSE, warning = FALSE, fig.width=9, fig.height=6, fig.cap = 'Utility fits by subject.'}
  utility_ind
```


## Utility Code
```{r, echo = FALSE}
# This code chunk is large.
# It computes the alpha values and durations predicted by maximizing utility.
# Specific models are deliminated by ========= MODEL ==========
# All of these fit here are fit using one experiment only.
# A later section fits experiment 2a/2b at the same time.

# This starts by fitting experiment 2a only, then 2b/2c for
# Net cost
# Gross Cost
# Utility 1
# Then utility 1/2/3/4 for experiment 2a/2b/2c.

# pref_glm_use = pref_p_glm
pref_glm_use = met_p_glm

# smallt_glm_use = smallt_p_glm
smallt_glm_use = met_smallt_p_glm

############ Modeling All the different Models

fun_optim_prx <- function(alpha,masses,mvttimes,p_alpha,rxtimes){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = p_alpha[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.1,5,0.01)
    ut = rep(0,length(times))
    for (t in times){
      ut[count] = (alpha*p-a0*rt-(a*t+b*(m^c)/(t^(d-1))))/(rt+t)
      count = count+1
    }
    dur[k] = times[which.max(ut)]
  }
  err = (mvttimes-dur)^2
  return(sum(err))
}

fun_dur_prx <- function(alpha,masses,mvttimes,p_alpha,rxtimes){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = p_alpha[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.2,5,0.01)
    ut = rep(0,length(times))
    for (t in times){
      ut[count] = (alpha*p-a0*rt-(a*t+b*(m^c)/(t^(d-1))))/(rt+t)
      count = count+1
    }
    dur[k] = times[which.max(ut)]
  }
  return(dur)
}

#================  Net Metabolics ==========================
# Mimizing net metabolics.
a=coef(MPNet_model)[1]
b=coef(MPNet_model)[2]
c=coef(MPNet_model)[3]
d=coef(MPNet_model)[4]

fun.1 <- function(t) a*t+b*(2.506^c)/(t^(d-1))
fun.2 <- function(t) a*t+b*(3.959^c)/(t^(d-1))
fun.3 <- function(t) a*t+b*(4.894^c)/(t^(d-1))
fun.4 <- function(t) a*t+b*(6.282^c)/(t^(d-1))

met_net_dur = c(optimize(fun.1,interval=c(0,2))$minimum,
                optimize(fun.2,interval=c(0,2))$minimum,
                optimize(fun.3,interval=c(0,2))$minimum,
                optimize(fun.4,interval=c(0,4))$minimum)

#================  Gross Metabolics ==========================
# Mimizing gross metabolics.

a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]

fun.1 <- function(t) a*t+b*(2.506^c)/(t^(d-1))
fun.2 <- function(t) a*t+b*(3.959^c)/(t^(d-1))
fun.3 <- function(t) a*t+b*(4.894^c)/(t^(d-1))
fun.4 <- function(t) a*t+b*(6.282^c)/(t^(d-1))

met_gross_dur = c(optimize(fun.1,interval=c(0,2))$minimum,
                  optimize(fun.2,interval=c(0,2))$minimum,
                  optimize(fun.3,interval=c(0,2))$minimum,
                  optimize(fun.4,interval=c(0,4))$minimum)

#================  Utility ==========================
# Finds the alpha value that minimizes SSE from experimental duration and predicted
# duration that maximizes utility.
# This section does not have probability of reward, this is base utility.
# This is fit with effort as gross and net cost.

masses = unique(prefdata$eff_mass)
mvttimes_pref = aggregate(movedur~condition,prefdata,mean)$movedur
rxtimes_pref = aggregate(reaction_tanv~condition,prefdata,mean)$reaction_tanv
p_alpha_pref = inv.logit(predict(pref_glm_use,data.frame(movedur=mvttimes_pref,eff_mass=masses)))

mvttimes_smallt = aggregate(movedur~condition,smalltdata,mean)$movedur
rxtimes_smallt = aggregate(reaction_tanv~eff_mass,smalltdata,mean)$reaction_tanv
p_alpha_smallt_gross = inv.logit(predict(smallt_glm_use,data.frame(movedur=mvttimes_smallt,eff_mass=masses)))

mvttimes_pilot = aggregate(movedur~condition,pilotdata,mean)$movedur
mvttimes_pilot_se = aggregate(movedur~condition,pilotdata,sd)$movedur/sqrt(max(pilotdata$subj))
miss_angle_sd_pilot = aggregate(absmissangle ~ eff_mass, pilotdata,'sd')$absmissangle
rxtimes_pilot = aggregate(reaction_tanv~eff_mass,smalltdata,mean)$reaction_tanv

a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]

alpha_utility_gross=optimize(fun_optim_prx,
                             masses = masses,
                             mvttimes = mvttimes_pref,
                             p_alpha  = c(1,1,1,1),
                             rxtimes = c(1,1,1,1),
                             interval=c(-100,300))
util_dur_gross = as.numeric(fun_dur_prx(alpha_utility_gross$minimum,
                                        masses = masses,
                                        mvttimes = mvttimes_pref,
                                        p_alpha  = c(1,1,1,1),
                                        rxtimes = c(1,1,1,1)))

a0 = mean(mpdata$metpowerrest)
a0_sd = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPNet_model)[1]
b=coef(MPNet_model)[2]
c=coef(MPNet_model)[3]
d=coef(MPNet_model)[4]

alpha_utility_net=optimize(fun_optim_prx,
                           masses = masses,
                           mvttimes = mvttimes_pref,
                           p_alpha  = c(1,1,1,1),
                           rxtimes = c(1,1,1,1),
                           interval=c(-100,300))
util_dur_net = as.numeric(fun_dur_prx(alpha_utility_gross$minimum,
                                      masses = masses,
                                      mvttimes = mvttimes_pref,
                                      p_alpha  = c(1,1,1,1),
                                      rxtimes = c(1,1,1,1)))

#================  Utility with reaction times and P(alpha) ==========================
# Finds the alpha value that minimizes SSE from experimental duration and predicted
# duration that maximizes utility.
# This utility includes reaction time and probability of reward.
# This is fit with effort as gross and net cost.

fun_optim_prx <- function(alpha,masses,mvttimes,p_alpha,rxtimes,opt_or_dur){
  err=0
  dur = rep(0,length(mvttimes))
  times = seq(0.3,2,0.001)
  ut = matrix(,nrow = length(mvttimes),ncol = length(times))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = p_alpha[k]
    rt = rxtimes[k]
    count = 1
    for (t in times){
      ut[k, count] = (alpha*p-a0*rt-(a*t+b*(m^c)/(t^(d-1))))/(rt+t)
      count = count+1
    }
    dur[k] = times[which.max(ut[k,])]
  }
  err = (mvttimes-dur)^2
  if (opt_or_dur == 'optimize'){
    return(sum(err))
  } else if (opt_or_dur == 'duration'){
    return(dur)
  }
}

fun_optim_prx_logit <- function(alpha,masses,mvttimes,p_alpha,rxtimes,opt_or_dur){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = inv.logit(predict(p_alpha,data.frame(movedur=t,eff_mass=m)))
    rt = rxtimes[k]
    times = seq(0.5,2,0.001)
    ut = rep(0,length(times))
    probs = inv.logit(predict(p_alpha,data.frame(movedur=times,eff_mass=m)))
    count = 1
    for (t in times){
      ut[count] = (alpha*probs[count]-a0*rt-(a*t+b*(m^c)/(t^(d-1))))/(rt+t)
      count = count+1
    }
    dur[k] = times[which.max(ut)]
    # print(max(ut))
  }
  err = (mvttimes-dur)^2
  if (opt_or_dur == 'optimize'){
    return(sum(err))
  } else if (opt_or_dur == 'duration'){
    return(dur)
  }
}

## Gross Utility
a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]

# # Using given probabilities
# alpha_utility_gross_rx = optimize(fun_optim_prx,
#                                   masses = masses,
#                                   mvttimes = mvttimes_pref,
#                                   p_alpha  = p_alpha_pref,
#                                   rxtimes = rxtimes_pref,
#                                   opt_or_dur = 'optimize',
#                                   interval=c(-100,300))
# 
# util_dur_gross_rx = as.numeric(fun_optim_prx(alpha_utility_gross_rx$minimum,
#                                        masses     = masses,
#                                        mvttimes   = mvttimes_pref,
#                                        p_alpha    = p_alpha_pref,
#                                        opt_or_dur = 'duration',
#                                        rxtimes    = rxtimes_pref))


# Using logit function
alpha_utility_gross_rx = optimize(fun_optim_prx_logit,
                                  masses     = masses,
                                  mvttimes   = mvttimes_pref,
                                  p_alpha    = pref_glm_use,
                                  rxtimes    = rxtimes_pref,
                                  opt_or_dur = 'optimize',
                                  interval   = c(-100,300))

util_dur_gross_rx = as.numeric(fun_optim_prx_logit(
                                       alpha      = alpha_utility_gross_rx$minimum,
                                       masses     = masses,
                                       mvttimes   = mvttimes_pref,
                                       p_alpha    = pref_glm_use,
                                       opt_or_dur = 'duration',
                                       rxtimes    = rxtimes_pref))
ut1_grs_alpha_2a = alpha_utility_gross_rx
ut1_grs_dur_2a   = util_dur_gross_rx

## Net Utility
a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPNet_model)[1]
b=coef(MPNet_model)[2]
c=coef(MPNet_model)[3]
d=coef(MPNet_model)[4]

# # Using given probabilities
# alpha_utility_net_rx = optimize(fun_optim_prx,
#                                 masses = masses,
#                                 mvttimes = mvttimes_pref,
#                                 p_alpha  = p_alpha_pref,
#                                 opt_or_dur = 'optimize',
#                                 rxtimes = rxtimes_pref,
#                                 interval=c(-100,300))
# util_dur_net_rx = as.numeric(fun_optim_prx(alpha_utility_net_rx$minimum,
#                                         masses = masses,
#                                         mvttimes = mvttimes_pref,
#                                         p_alpha  = p_alpha_pref,
#                                         opt_or_dur = 'duration',
#                                         rxtimes = rxtimes_pref))

# Using logit function
alpha_utility_net_rx = optimize(fun_optim_prx_logit,
                                masses = masses,
                                mvttimes = mvttimes_pref,
                                p_alpha  = pref_glm_use,
                                opt_or_dur = 'optimize',
                                rxtimes = rxtimes_pref,
                                interval=c(-100,300))
util_dur_net_rx = as.numeric(fun_optim_prx_logit(alpha_utility_net_rx$minimum,
                                        masses = masses,
                                        mvttimes = mvttimes_pref,
                                        p_alpha  = pref_glm_use,
                                        opt_or_dur = 'duration',
                                        rxtimes = rxtimes_pref))
ut1_net_alpha_2a = alpha_utility_net_rx
ut1_net_dur_2a   = util_dur_net_rx

#================  M = 1 ==========================
# Minimzing gross cost with mass exponent forced to 1.

# a=coef(MPNet_model)[1]
# b=coef(MPNet_model)[2]
# c=coef(MPNet_model)[3]
# d=coef(MPNet_model)[4]

a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]

c=1

m1_dur = as.numeric(c(optimize(fun.1,interval=c(0,10))$minimum,
                      optimize(fun.2,interval=c(0,10))$minimum,
                      optimize(fun.3,interval=c(0,10))$minimum,
                      optimize(fun.4,interval=c(0,10))$minimum))

#================  M = 2 ==========================
# Minimzing gross cost with mass exponent forced to 2.
c=2

m2_dur = as.numeric(c(optimize(fun.1,interval=c(0,2))$minimum,
                      optimize(fun.2,interval=c(0,2))$minimum,
                      optimize(fun.3,interval=c(0,2))$minimum,
                      optimize(fun.4,interval=c(0,4))$minimum))



#================  Torque Squared =========================
# Finds the alpha value that minimizes SSE from experimental duration and predicted
# duration that maximizes utility.
# This utility includes reaction time and probability of reward.
# Effort in this model is torque.

fun_optim_torque_prx <- function(alpha,masses,mvttimes,p_alpha,rxtimes){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = p_alpha[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.01,2,0.001)
    ut = rep(0,length(times))
    probs = inv.logit(predict(p_alpha,data.frame(movedur=times,eff_mass=m)))
    t_count = 0
    for (t in times){
    t_count = t_count+1
      ut[count] = (alpha*probs[t_count]-a0*rt-(a*t+b_torque*(m^c_torque)/(t^(d_torque-1))))/(rt+t)
      count = count+1
    }
    dur[k] = times[which.max(ut)]
  }
  err = (mvttimes-dur)^2
  return(sum(err))
}

fun_dur_torque_prx <- function(alpha,masses,mvttimes,p_alpha,rxtimes){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = p_alpha[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.2,2,0.001)
    ut = rep(0,length(times))
    probs = inv.logit(predict(p_alpha,data.frame(movedur=times,eff_mass=m)))
    t_count = 0
    for (t in times){
    t_count = t_count+1
      ut[count] = (alpha*probs[t_count]-a0*rt-(a*t+b_torque*(m^c_torque)/(t^(d_torque-1))))/(rt+t)
      count = count+1
    }
    # plot(ut)
    dur[k] = times[which.max(ut)]
  }
  return(dur)
}

fun_optim_torque_prx2 <- function(alpha,masses,mvttimes,probs,rxtimes){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = probs[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.01,2,0.001)
    ut = rep(0,length(times))
    t_count = 0
    for (t in times){
    t_count = t_count+1
      ut[count] = (alpha*p-a0*rt-(0*t+b_torque*(m^c_torque)/(t^(d_torque-1))))/(rt+t)
      count = count+1
    }
    dur[k] = times[which.max(ut)]
  }
  err = (mvttimes-dur)^2
  return(sum(err))
}

fun_dur_torque_prx2 <- function(alpha,masses,mvttimes,probs,rxtimes){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    rt = rxtimes[k]
    p = probs[k]
    count = 1
    times = seq(0.2,2,0.001)
    ut = rep(0,length(times))
    t_count = 0
    for (t in times){
    t_count = t_count+1
      ut[count] = (alpha*p-a0*rt-(0*t+b_torque*(m^c_torque)/(t^(d_torque-1))))/(rt+t)
      count = count+1
    }
    # plot(ut)
    dur[k] = times[which.max(ut)]
  }
  return(dur)
}

a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPGross_model)[1]

alpha_torque_2a=optimize(fun_optim_torque_prx,
                                masses = masses,
                                mvttimes = mvttimes_pref,
                                p_alpha  = pref_glm_use,
                                rxtimes = rxtimes_pref,
                                interval=c(-100,300))$minimum

torque_dur_2a = as.numeric(fun_dur_torque_prx(alpha_torque_2a,
                                        masses = masses,
                                        mvttimes = mvttimes_pref,
                                        p_alpha  = pref_glm_use,
                                        rxtimes = rxtimes_pref))

alpha_torque_2b=optimize(fun_optim_torque_prx,
                                masses = masses,
                                mvttimes = mvttimes_smallt,
                                p_alpha  = smallt_glm_use,
                                rxtimes = rxtimes_smallt,
                                interval=c(-100,300))$minimum

torque_dur_2b = as.numeric(fun_dur_torque_prx(alpha_torque_2b,
                                        masses = masses,
                                        mvttimes = mvttimes_smallt,
                                        p_alpha  = smallt_glm_use,
                                        rxtimes = rxtimes_smallt))

alpha_torque_2c=optimize(fun_optim_torque_prx2,
                                masses = masses,
                                mvttimes = mvttimes_pilot,
                                probs  = c(1,1,1,1),
                                rxtimes = rxtimes_pilot,
                                interval=c(-100,300))$minimum

torque_dur_2c = as.numeric(fun_dur_torque_prx2(alpha_torque_2c,
                                        masses = masses,
                                        mvttimes = mvttimes_pilot,
                                        probs  = c(1,1,1,1),
                                        rxtimes = rxtimes_pilot))

torque2a_util_sse = sum((torque_dur_2a-mvttimes_pref)^2)
torque2b_util_sse = sum((torque_dur_2b-mvttimes_smallt)^2)
torque2c_util_sse = sum((torque_dur_2c-mvttimes_pilot)^2)

torque2a_util_AIC = 2*7-sum((torque_dur_2a-mvttimes_pref)^2)
torque2b_util_AIC = 2*7-sum((torque_dur_2b-mvttimes_smallt)^2)
torque2c_util_AIC = 2*7-2*log(sum((torque_dur_2c-mvttimes_pilot)^2))

movedur_norm_2a = aggregate(movedur ~ eff_mass,prefdata,mean)$movedur/aggregate(movedur ~ eff_mass,prefdata,mean)$movedur[1]

movedur_norm_2b = aggregate(movedur ~ eff_mass,smalltdata,mean)$movedur/aggregate(movedur ~ eff_mass,smalltdata,mean)$movedur[1]

movedur_norm_2c = aggregate(movedur ~ eff_mass,pilotdata,mean)$movedur/aggregate(movedur ~ eff_mass,pilotdata,mean)$movedur[1]

torque_dur_2a_norm = torque_dur_2a/torque_dur_2a[1]
torque_dur_2b_norm = torque_dur_2b/torque_dur_2b[1]
torque_dur_2c_norm = torque_dur_2c/torque_dur_2c[1]

torque2a_util_norm_sse = sum((torque_dur_2a_norm-movedur_norm_2a)^2)
torque2b_util_norm_sse = sum((torque_dur_2b_norm-movedur_norm_2b)^2)
torque2c_util_norm_sse = sum((torque_dur_2c_norm-movedur_norm_2c)^2)

#================  Torque Squared Min Jerk =========================
# Finds the alpha value that minimizes SSE from experimental duration and predicted
# duration that maximizes utility.
# This utility includes reaction time and probability of reward.
# Effort in this model is torque estimated from a minimum jerk trajectory.

fun_optim_torque_prx_mj <- function(alpha,masses,mvttimes,p_alpha,rxtimes){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = p_alpha[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.01,3,0.01)
    ut = rep(0,length(times))
    probs = inv.logit(predict(p_alpha,data.frame(movedur=times,eff_mass=m)))
    t_count = 0
    for (t in times){
    t_count = t_count+1
      ut[count] = (alpha*probs[t_count]-coef(MPGross_model)[1]*rt-(0*t+b_torque_mj*(m^c_torque_mj)/(t^(d_torque_mj-1))))/(rt+t)
      count = count+1
    }
    dur[k] = times[which.max(ut)]
  }
  err = (mvttimes-dur)^2
  return(sum(err))
}

fun_dur_torque_prx_mj <- function(alpha,masses,mvttimes,p_alpha,rxtimes){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = p_alpha[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.01,3,0.01)
    ut = rep(0,length(times))
    probs = inv.logit(predict(p_alpha,data.frame(movedur=times,eff_mass=m)))
    t_count = 0
    for (t in times){
    t_count = t_count+1
      ut[count] = (alpha*probs[t_count]-coef(MPGross_model)[1]*rt-(0*t+b_torque_mj*(m^c_torque_mj)/(t^(d_torque_mj-1))))/(rt+t)
      count = count+1
    }
    # plot(ut)
    dur[k] = times[which.max(ut)]
  }
  return(dur)
}

fun_optim_torque_prx_mj2 <- function(alpha,masses,mvttimes,probs,rxtimes){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = probs[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.01,3,0.01)
    ut = rep(0,length(times))
    t_count = 0
    for (t in times){
    t_count = t_count+1
      ut[count] = (alpha*p-a0*rt-(0*t+b_torque_mj*(m^c_torque_mj)/(t^(d_torque_mj-1))))/(rt+t)
      count = count+1
    }
    dur[k] = times[which.max(ut)]
  }
  err = (mvttimes-dur)^2
  return(sum(err))
}

fun_dur_torque_prx_mj2 <- function(alpha,masses,mvttimes,probs,rxtimes){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = probs[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.01,3,0.01)
    ut = rep(0,length(times))
    t_count = 0
    for (t in times){
    t_count = t_count+1
      ut[count] = (alpha*p-a0*rt-(0*t+b_torque_mj*(m^c_torque_mj)/(t^(d_torque_mj-1))))/(rt+t)
      count = count+1
    }
    # plot(ut)
    dur[k] = times[which.max(ut)]
  }
  return(dur)
}

a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPGross_model)[1]

alpha_torque_2a_mj=optimize(fun_optim_torque_prx_mj,
                                masses = masses,
                                mvttimes = mvttimes_pref,
                                p_alpha  = pref_glm_use,
                                rxtimes = rxtimes_pref,
                                interval=c(-100,300))$minimum

torque_mj_dur_2a = as.numeric(fun_dur_torque_prx_mj(alpha_torque_2a_mj,
                                        masses = masses,
                                        mvttimes = mvttimes_pref,
                                        p_alpha  = pref_glm_use,
                                        rxtimes = rxtimes_pref))

alpha_torque_2b_mj=optimize(fun_optim_torque_prx_mj,
                                masses = masses,
                                mvttimes = mvttimes_smallt,
                                p_alpha  = smallt_glm_use,
                                rxtimes = rxtimes_smallt,
                                interval=c(-100,300))$minimum

torque_mj_dur_2b = as.numeric(fun_dur_torque_prx_mj(alpha_torque_2b_mj,
                                        masses = masses,
                                        mvttimes = mvttimes_smallt,
                                        p_alpha  = smallt_glm_use,
                                        rxtimes = rxtimes_smallt))

alpha_torque_2c_mj=optimize(fun_optim_torque_prx_mj2,
                                masses = masses,
                                mvttimes = mvttimes_pilot,
                                probs  = c(1,1,1,1),
                                rxtimes = rxtimes_pilot,
                                interval=c(-100,300))$minimum

torque_mj_dur_2c = as.numeric(fun_dur_torque_prx_mj2(alpha_torque_2c_mj,
                                        masses = masses,
                                        mvttimes = mvttimes_pilot,
                                        probs  = c(1,1,1,1),
                                        rxtimes = rxtimes_pilot))


#================  2b and 2c Utility =========================
# Utility fits for experiment 2b  and 2c, same things as previous sections.

fun_p_alpha <- function(miss_dist, min_dist){
  p_alpha = c(0,0,0,0)
  count = 1
  for (k in miss_dist){
    p_alpha[count] = 2*(pnorm(min_dist, mean = 0, sd = k)-.5)
    count = count+1
  }
  return(p_alpha)
}
p_alpha_pilot_gross = fun_p_alpha(miss_angle_sd_pilot, 90)

# 2b utility fits
a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]

alpha_smallt_gross = optimize(fun_optim_prx_logit,
                      masses     = masses,
                      mvttimes   = mvttimes_smallt,
                      p_alpha    = smallt_glm_use,
                      rxtimes    = rxtimes_smallt,
                      opt_or_dur = 'optimize',
                      interval   = c(-100,1000))

util_dur_smallt_gross = as.numeric(fun_optim_prx_logit(alpha_smallt_gross$minimum, #changing between alpha_pref and alpha_smallt_gross
                                     masses   = masses,
                                     mvttimes = mvttimes_smallt,
                                     p_alpha  = smallt_glm_use,
                                     rxtimes  = rxtimes_smallt,
                                     opt_or_dur = 'duration'))

ut1_grs_alpha_2b = alpha_smallt_gross
ut1_grs_dur_2b   = util_dur_smallt_gross

a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPNet_model)[1]
b=coef(MPNet_model)[2]
c=coef(MPNet_model)[3]
d=coef(MPNet_model)[4]

alpha_smallt_net = optimize(fun_optim_prx_logit,
                      masses     = masses,
                      mvttimes   = mvttimes_smallt,
                      p_alpha    = smallt_glm_use,
                      rxtimes    = rxtimes_smallt,
                      opt_or_dur = 'optimize',
                      interval   = c(-100,1000))

util_dur_smallt_net = as.numeric(fun_optim_prx_logit(alpha_smallt_net$minimum, #changing between alpha_pref and alpha_smallt_gross
                                     masses   = masses,
                                     mvttimes = mvttimes_smallt,
                                     p_alpha  = smallt_glm_use,
                                     rxtimes  = rxtimes_smallt,
                                     opt_or_dur = 'duration'))

ut1_net_alpha_2b = alpha_smallt_net
ut1_net_dur_2b   = util_dur_smallt_net

# 2c utility stuff
a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]

masses = unique(prefdata$eff_mass)

alpha_pilot_gross=optimize(fun_optim_prx,
                     masses   = masses,
                     mvttimes = mvttimes_pilot,
                     p_alpha  = p_alpha_pilot_gross,
                     rxtimes  = rxtimes_pilot,
                     opt_or_dur = 'optimize',
                     interval = c(-100,1000))

util_dur_pilot_gross = as.numeric(fun_optim_prx(alpha_pilot_gross$minimum,
                                    masses   = masses,
                                    mvttimes = mvttimes_pilot,
                                    p_alpha  = p_alpha_pilot_gross,
                                    rxtimes  = rxtimes_pilot,
                                    opt_or_dur = 'duration'))

ut1_grs_alpha_2c = alpha_pilot_gross
ut1_grs_dur_2c   = util_dur_pilot_gross

a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPNet_model)[1]
b=coef(MPNet_model)[2]
c=coef(MPNet_model)[3]
d=coef(MPNet_model)[4]

alpha_pilot_net=optimize(fun_optim_prx,
                     masses   = masses,
                     mvttimes = mvttimes_pilot,
                     p_alpha  = p_alpha_pilot_gross,
                     rxtimes  = rxtimes_pilot,
                     opt_or_dur = 'optimize',
                     interval = c(-100,1000))

util_dur_pilot_net = as.numeric(fun_optim_prx(alpha_pilot_net$minimum,
                                    masses   = masses,
                                    mvttimes = mvttimes_pilot,
                                    p_alpha  = p_alpha_pilot_gross,
                                    rxtimes  = rxtimes_pilot,
                                    opt_or_dur = 'duration'))

ut1_net_alpha_2c = alpha_pilot_net
ut1_net_dur_2c   = util_dur_pilot_net

#================  Utility2 and P(alpha) ==========================
# Utility 2 fits, similar to before.

fun_optim_prx_ut2 <- function(alpha,masses,mvttimes,p_alpha,rxtimes,opt_or_dur){
  err=0
  dur = rep(0,length(mvttimes))
  times = seq(0.3,2,0.001)
  ut = matrix(,nrow = length(mvttimes),ncol = length(times))
  for (k in 1:length(mvttimes)){
    m = masses[k]
    p = p_alpha[k]
    rt = rxtimes[k]
    count = 1
    for (t in times){
      ut[k, count] = alpha*p-a0*rt-a*t-(b*(m^c)/(t^(d-1)))
      count = count+1
    }
    dur[k] = times[which.max(ut[k,])]
  }
  err = (mvttimes-dur)^2
  if (opt_or_dur == 'optimize'){
    return(sum(err))
  } else if (opt_or_dur == 'duration'){
    return(dur)
  }
}

fun_optim_prx_logit_ut2 <- function(alpha,masses,mvttimes,p_alpha,rxtimes,opt_or_dur){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = inv.logit(predict(p_alpha,data.frame(movedur=t,eff_mass=m)))
    rt = rxtimes[k]
    times = seq(0.5,2,0.001)
    ut = rep(0,length(times))
    probs = inv.logit(predict(p_alpha,data.frame(movedur=times,eff_mass=m)))
    count = 1
    for (t in times){
      ut[count] = alpha*probs[count]-a0*rt-(a*t+b*(m^c)/(t^(d-1)))
      count = count+1
    }
    dur[k] = times[which.max(ut)]
    # print(max(ut))
  }
  err = (mvttimes-dur)^2
  if (opt_or_dur == 'optimize'){
    return(sum(err))
  } else if (opt_or_dur == 'duration'){
    return(dur)
  }
}

## Gross Utility
a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]

# Using logit function
ut2_grs_alpha_2a = optimize(fun_optim_prx_logit_ut2,
                        masses     = masses,
                        mvttimes   = mvttimes_pref,
                        p_alpha    = pref_glm_use,
                        rxtimes    = rxtimes_pref,
                        opt_or_dur = 'optimize',
                        interval   = c(-100,1000))

ut2_grs_dur_2a = as.numeric(fun_optim_prx_logit_ut2(
  alpha      = ut2_grs_alpha_2a$minimum,
  masses     = masses,
  mvttimes   = mvttimes_pref,
  p_alpha    = pref_glm_use,
  opt_or_dur = 'duration',
  rxtimes    = rxtimes_pref))

ut2_grs_alpha_2b = optimize(fun_optim_prx_logit_ut2,
                        masses     = masses,
                        mvttimes   = mvttimes_smallt,
                        p_alpha    = smallt_glm_use,
                        rxtimes    = rxtimes_smallt,
                        opt_or_dur = 'optimize',
                        interval   = c(-100,1000))

ut2_grs_dur_2b = as.numeric(fun_optim_prx_logit_ut2(
  alpha = ut2_grs_alpha_2b$minimum, #changing between alpha_pref and alpha_smallt_gross
  masses   = masses,
  mvttimes = mvttimes_smallt,
  p_alpha  = smallt_glm_use,
  rxtimes  = rxtimes_smallt,
  opt_or_dur = 'duration'))

ut2_grs_alpha_2c = optimize(fun_optim_prx_ut2,
                        masses   = masses,
                        mvttimes = mvttimes_pilot,
                        p_alpha  = p_alpha_pilot_gross,
                        rxtimes  = rxtimes_pilot,
                        opt_or_dur = 'optimize',
                        interval = c(-100,1e5))

ut2_grs_dur_2c = as.numeric(fun_optim_prx_ut2(
  alpha = ut2_grs_alpha_2c$minimum,
  masses   = masses,
  mvttimes = mvttimes_pilot,
  p_alpha  = p_alpha_pilot_gross,
  rxtimes  = rxtimes_pilot,
  opt_or_dur = 'duration'))

#================  Utility3 and P(alpha) ==========================
# same, but with utility 3.
fun_optim_prx_ut3 <- function(alpha,masses,mvttimes,p_alpha,rxtimes,opt_or_dur){
  err=0
  dur = rep(0,length(mvttimes))
  times = seq(0.1,2,0.001)
  ut = matrix(,nrow = length(mvttimes),ncol = length(times))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = p_alpha[k]
    rt = rxtimes[k]
    count = 1
    for (t in times){
      ut[k, count] = ((alpha*p)/(t+rt))-a0*rt-(a*t+b*(m^c)/(t^(d-1)))
      count = count+1
    }
    dur[k] = times[which.max(ut[k,])]
  }
  err = (mvttimes-dur)^2
  if (opt_or_dur == 'optimize'){
    return(sum(err))
  } else if (opt_or_dur == 'duration'){
    return(dur)
  }
}

fun_optim_prx_logit_ut3 <- function(alpha,masses,mvttimes,p_alpha,rxtimes,opt_or_dur){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = inv.logit(predict(p_alpha,data.frame(movedur=t,eff_mass=m)))
    rt = rxtimes[k]
    times = seq(0.5,2,0.001)
    ut = rep(0,length(times))
    probs = inv.logit(predict(p_alpha,data.frame(movedur=times,eff_mass=m)))
    count = 1
    for (t in times){
      ut[count] = ((alpha*probs[count])/(t+rt))-a0*rt-(a*t+b*(m^c)/(t^(d-1)))
      count = count+1
    }
    dur[k] = times[which.max(ut)]
    # print(max(ut))
  }
  err = (mvttimes-dur)^2
  if (opt_or_dur == 'optimize'){
    return(sum(err))
  } else if (opt_or_dur == 'duration'){
    return(dur)
  }
}

## Gross Utility
a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]

# Using logit function
ut3_grs_alpha_2a = optimize(fun_optim_prx_logit_ut3,
                        masses     = masses,
                        mvttimes   = mvttimes_pref,
                        p_alpha    = pref_glm_use,
                        rxtimes    = rxtimes_pref,
                        opt_or_dur = 'optimize',
                        interval   = c(-100,1000))

ut3_grs_dur_2a = as.numeric(fun_optim_prx_logit_ut3(
  alpha      = ut3_grs_alpha_2a$minimum,
  masses     = masses,
  mvttimes   = mvttimes_pref,
  p_alpha    = pref_glm_use,
  opt_or_dur = 'duration',
  rxtimes    = rxtimes_pref))

ut3_grs_alpha_2b = optimize(fun_optim_prx_logit_ut3,
                        masses     = masses,
                        mvttimes   = mvttimes_smallt,
                        p_alpha    = smallt_glm_use,
                        rxtimes    = rxtimes_smallt,
                        opt_or_dur = 'optimize',
                        interval   = c(-100,1000))

ut3_grs_dur_2b = as.numeric(fun_optim_prx_logit_ut3(
  alpha      = ut3_grs_alpha_2b$minimum, #changing between alpha_pref and alpha_smallt_gross
  masses     = masses,
  mvttimes   = mvttimes_smallt,
  p_alpha    = smallt_glm_use,
  rxtimes    = rxtimes_smallt,
  opt_or_dur = 'duration'))

ut3_grs_alpha_2c = optimize(fun_optim_prx_ut3,
                        masses     = masses,
                        mvttimes   = mvttimes_pilot,
                        p_alpha    = p_alpha_pilot_gross,
                        rxtimes    = rxtimes_pilot,
                        opt_or_dur = 'optimize',
                        interval   = c(-100,100))

ut3_grs_dur_2c = as.numeric(fun_optim_prx_ut3(
  alpha      = ut3_grs_alpha_2c$minimum,
  masses     = masses,
  mvttimes   = mvttimes_pilot,
  p_alpha    = p_alpha_pilot_gross,
  rxtimes    = rxtimes_pilot,
  opt_or_dur = 'duration'))


#================  Utility4 and P(alpha) ==========================

fun_optim_prx_ut4 <- function(alpha,masses,mvttimes,p_alpha,rxtimes,opt_or_dur){
  err=0
  dur = rep(0,length(mvttimes))
  times = seq(0.1,2,0.001)
  ut = matrix(,nrow = length(mvttimes),ncol = length(times))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = p_alpha[k]
    rt = rxtimes[k]
    count = 1
    for (t in times){
      ut[k, count] = (alpha*p)/(a0*rt+a*t+b*(m^c)/(t^(d-1)))
      count = count+1
    }
    dur[k] = times[which.max(ut[k,])]
  }
  err = (mvttimes-dur)^2
  if (opt_or_dur == 'optimize'){
    return(sum(err))
  } else if (opt_or_dur == 'duration'){
    return(dur)
  }
}

fun_optim_prx_logit_ut4 <- function(alpha,masses,mvttimes,p_alpha,rxtimes,opt_or_dur){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = inv.logit(predict(p_alpha,data.frame(movedur=t,eff_mass=m)))
    rt = rxtimes[k]
    times = seq(0.1,2,0.001)
    ut = rep(0,length(times))
    probs = inv.logit(predict(p_alpha,data.frame(movedur=times,eff_mass=m)))
    count = 1
    for (t in times){
      ut[count] = (alpha*probs[count])/(a0*rt+(a*t+b*(m^c)/(t^(d-1))))
      count = count+1
    }
    dur[k] = times[which.max(ut)]
    # print(max(ut))
  }
  err = (mvttimes-dur)^2
  if (opt_or_dur == 'optimize'){
    return(sum(err))
  } else if (opt_or_dur == 'duration'){
    return(dur)
  }
}

## Gross Utility
a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]

# Using logit function
# ut4_grs_alpha_2a = optimize(fun_optim_prx_logit_ut4,
#                             masses     = masses,
#                             mvttimes   = mvttimes_pref,
#                             p_alpha    = pref_glm_use,
#                             rxtimes    = rxtimes_pref,
#                             opt_or_dur = 'optimize',
#                             interval   = c(-100,1000))
ut4_grs_alpha_2a = 1

ut4_grs_dur_2a = as.numeric(fun_optim_prx_logit_ut4(
  alpha      = ut4_grs_alpha_2a,
  masses     = masses,
  mvttimes   = mvttimes_pref,
  p_alpha    = pref_glm_use,
  opt_or_dur = 'duration',
  rxtimes    = rxtimes_pref))

# ut4_grs_alpha_2b = optimize(fun_optim_prx_logit_ut4,
#                             masses     = masses,
#                             mvttimes   = mvttimes_smallt,
#                             p_alpha    = smallt_glm_use,
#                             rxtimes    = rxtimes_smallt,
#                             opt_or_dur = 'optimize',
#                             interval   = c(-100,1000))

ut4_grs_alpha_2b = 1

ut4_grs_dur_2b = as.numeric(fun_optim_prx_logit_ut4(
  alpha      = ut4_grs_alpha_2b, #changing between alpha_pref and alpha_smallt_gross
  masses     = masses,
  mvttimes   = mvttimes_smallt,
  p_alpha    = smallt_glm_use,
  rxtimes    = rxtimes_smallt,
  opt_or_dur = 'duration'))

# ut4_grs_alpha_2c = optimize(fun_optim_prx_ut4,
#                             masses     = masses,
#                             mvttimes   = mvttimes_pilot,
#                             p_alpha    = p_alpha_pilot_gross,
#                             rxtimes    = rxtimes_pilot,
#                             opt_or_dur = 'optimize',
#                             interval   = c(-100,100))

ut4_grs_alpha_2c = 1

ut4_grs_dur_2c = as.numeric(fun_optim_prx_ut4(
  alpha      = ut4_grs_alpha_2c,
  masses     = masses,
  mvttimes   = mvttimes_pilot,
  p_alpha    = p_alpha_pilot_gross,
  rxtimes    = rxtimes_pilot,
  opt_or_dur = 'duration'))

#================  Utility2net and P(alpha) ==========================

## Net Utility
a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPNet_model)[1]
b=coef(MPNet_model)[2]
c=coef(MPNet_model)[3]
d=coef(MPNet_model)[4]

# Using logit function
ut2_net_alpha_2a = optimize(fun_optim_prx_logit_ut2,
                        masses     = masses,
                        mvttimes   = mvttimes_pref,
                        p_alpha    = pref_glm_use,
                        rxtimes    = rxtimes_pref,
                        opt_or_dur = 'optimize',
                        interval   = c(-100,1000))

ut2_net_dur_2a = as.numeric(fun_optim_prx_logit_ut2(
  alpha      = ut2_net_alpha_2a$minimum,
  masses     = masses,
  mvttimes   = mvttimes_pref,
  p_alpha    = pref_glm_use,
  opt_or_dur = 'duration',
  rxtimes    = rxtimes_pref))

ut2_net_alpha_2b = optimize(fun_optim_prx_logit_ut2,
                        masses     = masses,
                        mvttimes   = mvttimes_smallt,
                        p_alpha    = smallt_glm_use,
                        rxtimes    = rxtimes_smallt,
                        opt_or_dur = 'optimize',
                        interval   = c(-100,1000))

ut2_net_dur_2b = as.numeric(fun_optim_prx_logit_ut2(
  alpha      = ut2_net_alpha_2b$minimum, #changing between alpha_pref and alpha_smallt_gross
  masses     = masses,
  mvttimes   = mvttimes_smallt,
  p_alpha    = smallt_glm_use,
  rxtimes    = rxtimes_smallt,
  opt_or_dur = 'duration'))

ut2_net_alpha_2c = optimize(fun_optim_prx_ut2,
                        masses     = masses,
                        mvttimes   = mvttimes_pilot,
                        p_alpha    = p_alpha_pilot_gross,
                        rxtimes    = rxtimes_pilot,
                        opt_or_dur = 'optimize',
                        interval   = c(-100,1e5))

ut2_net_dur_2c = as.numeric(fun_optim_prx_ut2(
  alpha      = ut2_net_alpha_2c$minimum,
  masses     = masses,
  mvttimes   = mvttimes_pilot,
  p_alpha    = p_alpha_pilot_gross,
  rxtimes    = rxtimes_pilot,
  opt_or_dur = 'duration'))

#================  Utility3net and P(alpha) ==========================

## Net Utility
a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPNet_model)[1]
b=coef(MPNet_model)[2]
c=coef(MPNet_model)[3]
d=coef(MPNet_model)[4]

# Using logit function
ut3_net_alpha_2a = optimize(fun_optim_prx_logit_ut3,
                        masses     = masses,
                        mvttimes   = mvttimes_pref,
                        p_alpha    = pref_glm_use,
                        rxtimes    = rxtimes_pref,
                        opt_or_dur = 'optimize',
                        interval   = c(-100,1000))

ut3_net_dur_2a = as.numeric(fun_optim_prx_logit_ut3(
  alpha      = ut3_net_alpha_2a$minimum,
  masses     = masses,
  mvttimes   = mvttimes_pref,
  p_alpha    = pref_glm_use,
  opt_or_dur = 'duration',
  rxtimes    = rxtimes_pref))

ut3_net_alpha_2b = optimize(fun_optim_prx_logit_ut3,
                        masses     = masses,
                        mvttimes   = mvttimes_smallt,
                        p_alpha    = smallt_glm_use,
                        rxtimes    = rxtimes_smallt,
                        opt_or_dur = 'optimize',
                        interval   = c(-100,1000))

ut3_net_dur_2b = as.numeric(fun_optim_prx_logit_ut3(
  alpha      = ut3_net_alpha_2b$minimum, #changing between alpha_pref and alpha_smallt_gross
  masses     = masses,
  mvttimes   = mvttimes_smallt,
  p_alpha    = smallt_glm_use,
  rxtimes    = rxtimes_smallt,
  opt_or_dur = 'duration'))

ut3_net_alpha_2c = optimize(fun_optim_prx_ut3,
                        masses     = masses,
                        mvttimes   = mvttimes_pilot,
                        p_alpha    = p_alpha_pilot_gross,
                        rxtimes    = rxtimes_pilot,
                        opt_or_dur = 'optimize',
                        interval   = c(-100,100))

ut3_net_dur_2c = as.numeric(fun_optim_prx_ut3(
  alpha      = ut3_net_alpha_2c$minimum,
  masses     = masses,
  mvttimes   = mvttimes_pilot,
  p_alpha    = p_alpha_pilot_gross,
  rxtimes    = rxtimes_pilot,
  opt_or_dur = 'duration'))


#================  Utility4net and P(alpha) ==========================
## Net Utility
a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPNet_model)[1]
b=coef(MPNet_model)[2]
c=coef(MPNet_model)[3]
d=coef(MPNet_model)[4]
# Using logit function
# ut4_net_alpha_2a = optimize(fun_optim_prx_logit_ut4,
#                             masses     = masses,
#                             mvttimes   = mvttimes_pref,
#                             p_alpha    = pref_glm_use,
#                             rxtimes    = rxtimes_pref,
#                             opt_or_dur = 'optimize',
#                             interval   = c(-100,1000))
ut4_net_alpha_2a = 1

ut4_net_dur_2a = as.numeric(fun_optim_prx_logit_ut4(
  alpha      = ut4_net_alpha_2a,
  masses     = masses,
  mvttimes   = mvttimes_pref,
  p_alpha    = pref_glm_use,
  opt_or_dur = 'duration',
  rxtimes    = rxtimes_pref))

# ut4_net_alpha_2b = optimize(fun_optim_prx_logit_ut4,
#                             masses     = masses,
#                             mvttimes   = mvttimes_smallt,
#                             p_alpha    = smallt_glm_use,
#                             rxtimes    = rxtimes_smallt,
#                             opt_or_dur = 'optimize',
#                             interval   = c(-100,1000))

ut4_net_alpha_2b = 1

ut4_net_dur_2b = as.numeric(fun_optim_prx_logit_ut4(
  alpha      = ut4_net_alpha_2b, #changing between alpha_pref and alpha_smallt_gross
  masses     = masses,
  mvttimes   = mvttimes_smallt,
  p_alpha    = smallt_glm_use,
  rxtimes    = rxtimes_smallt,
  opt_or_dur = 'duration'))

# ut4_net_alpha_2c = optimize(fun_optim_prx_ut4,
#                             masses     = masses,
#                             mvttimes   = mvttimes_pilot,
#                             p_alpha    = p_alpha_pilot_gross,
#                             rxtimes    = rxtimes_pilot,
#                             opt_or_dur = 'optimize',
#                             interval   = c(-100,100))

ut4_net_alpha_2c = 1

ut4_net_dur_2c = as.numeric(fun_optim_prx_ut4(
  alpha      = ut4_net_alpha_2c,
  masses     = masses,
  mvttimes   = mvttimes_pilot,
  p_alpha    = p_alpha_pilot_gross,
  rxtimes    = rxtimes_pilot,
  opt_or_dur = 'duration'))

# Reset to gross ===================
a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]
```

### Combined utility code

```{r, echo = FALSE, warning = FALSE}
# This section is very similar to the chunk above, but it fits experimetn 2a/2b
# at the same time and computes one alpha value for both.
fun_optim_prx_comb <- function(alpha,masses,mvttimes,p_alpha,rxtimes,opt_or_dur){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = p_alpha[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.1,3,0.001)
    ut = rep(0,length(times))
    for (t in times){
      ut[count] = (alpha*p-a0*rt-(a*t+b*(m^c)/(t^(d-1))))/(rt+t)
      count = count+1
    }
    dur[k] = times[which.max(ut)]
  }
  err = (mvttimes-dur)^2
  if (opt_or_dur == 'optimize'){
    return(sum(err))
  } else if (opt_or_dur == 'duration'){
    return(dur)
  }
}

fun_optim_prx_logit_comb <- function(alpha,masses,mvttimes,glm1,glm2,rxtimes,opt_or_dur){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.1,3,0.001)
    ut = rep(0,length(times))
    if (k<5){
      probs = inv.logit(predict(glm1,data.frame(movedur=times,eff_mass=m)))
    } else {
      probs = inv.logit(predict(glm2,data.frame(movedur=times,eff_mass=m)))
    }
    t_count = 0
    for (t in times){
    t_count = t_count+1
      ut[count] = (alpha*probs[t_count]-a0*rt-(a*t+b*(m^c)/(t^(d-1))))/(rt+t)
      count = count+1
    }
    dur[k] = times[which.max(ut)]
  }
  err = (mvttimes-dur)^2
  if (opt_or_dur == 'optimize'){
    return(sum(err))
  } else if (opt_or_dur == 'duration'){
    return(dur)
  }
}

masses = unique(prefdata$eff_mass)
mvttimes_pref = aggregate(movedur~condition,prefdata,mean)$movedur
mvttimes_pref_se = aggregate(movedur~condition,prefdata,sd)$movedur/sqrt(max(prefdata$subj))
miss_dist_sd_pref = aggregate(miss_dist ~ eff_mass, prefdata,'sd')$miss_dist
rxtimes_pref = aggregate(reaction_tanv~eff_mass,prefdata,mean)$reaction_tanv

mvttimes_smallt = aggregate(movedur~condition,smalltdata,mean)$movedur
mvttimes_smallt_se = aggregate(movedur~condition,smalltdata,sd)$movedur/sqrt(max(smalltdata$subj))
miss_dist_sd_smallt = aggregate(miss_dist ~ eff_mass, smalltdata,'sd')$miss_dist
rxtimes_smallt = aggregate(reaction_tanv~eff_mass,smalltdata,mean)$reaction_tanv

# Combined stuff
# Not using logit function
# alpha_pref_comb_gross=optimize(fun_optim_prx_comb,
#                       masses     = c(masses,masses),
#                       mvttimes   = c(mvttimes_pref,mvttimes_smallt),
#                       p_alpha    = c(p_alpha_pref,p_alpha_smallt_gross),
#                       rxtimes    = c(rxtimes_pref,rxtimes_smallt),
#                       opt_or_dur = 'optimize',
#                       interval   = c(-100,200))
# pref_glm_use smallt_glm_use

# COMBINED UTILITY Torque Squared ===========================
# USING logit function
a=coef(MPGross_model)[1]
b=coef(torque2_model)[1]
c=coef(torque2_model)[2]
d=coef(torque2_model)[3]
alpha_torque_comb_gross=optimize(fun_optim_prx_logit_comb,
                      masses     = c(masses,masses),
                      mvttimes   = c(mvttimes_pref,mvttimes_smallt),
                      glm1       = pref_glm_use,
                      glm2       = smallt_glm_use,
                      rxtimes    = c(rxtimes_pref,rxtimes_smallt),
                      opt_or_dur = 'optimize',
                      interval   = c(-100,200))

util_torque_pref_alpha_comb_gross = as.numeric(fun_optim_prx_logit_comb(
                                       alpha      = alpha_torque_comb_gross$minimum,
                                       masses     = c(masses,masses),
                                       mvttimes   = c(mvttimes_pref,mvttimes_smallt),
                                       glm1       = pref_glm_use,
                                       glm2       = smallt_glm_use,
                                       opt_or_dur = 'duration',
                                       rxtimes    = c(rxtimes_pref,rxtimes_smallt)))

ut1_torque_alpha_2a2b = alpha_torque_comb_gross
ut1_torque_dur_2a2b   = util_torque_pref_alpha_comb_gross

ut1_torque_dur_2a2b2c = as.numeric(fun_optim_prx_comb(
                                       alpha_torque_comb_gross$minimum,
                                       masses = masses,
                                       mvttimes = mvttimes_pilot,
                                       p_alpha  = c(1,1,1,1),
                                       opt_or_dur = 'duration',
                                       rxtimes = rxtimes_pilot))

# COMBINED UTILITY Gross ===========================
# USING logit function
a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]
alpha_pref_comb_gross=optimize(fun_optim_prx_logit_comb,
                      masses     = c(masses,masses),
                      mvttimes   = c(mvttimes_pref,mvttimes_smallt),
                      glm1       = pref_glm_use,
                      glm2       = smallt_glm_use,
                      rxtimes    = c(rxtimes_pref,rxtimes_smallt),
                      opt_or_dur = 'optimize',
                      interval   = c(-100,200))

util_dur_pref_alpha_comb_gross = as.numeric(fun_optim_prx_logit_comb(
                                       alpha      = alpha_pref_comb_gross$minimum,
                                       masses     = c(masses,masses),
                                       mvttimes   = c(mvttimes_pref,mvttimes_smallt),
                                       glm1       = pref_glm_use,
                                       glm2       = smallt_glm_use,
                                       opt_or_dur = 'duration',
                                       rxtimes    = c(rxtimes_pref,rxtimes_smallt)))

ut1_grs_alpha_2a2b = alpha_pref_comb_gross
ut1_grs_dur_2a2b   = util_dur_pref_alpha_comb_gross


util_dur_pilot_gross_alpha_comb_gross = as.numeric(fun_optim_prx_comb(
                                       alpha_pref_comb_gross$minimum,
                                       masses = masses,
                                       mvttimes = mvttimes_pilot,
                                       p_alpha  = c(1,1,1,1),
                                       opt_or_dur = 'duration',
                                       rxtimes = rxtimes_pilot))

ut1_grs_dur_2a2b2c = as.numeric(fun_optim_prx(
                          alpha    = alpha_pref_comb_gross$minimum,
                          masses   = masses,
                          mvttimes = mvttimes_pilot,
                          p_alpha  = p_alpha_pilot_gross,
                          rxtimes  = rxtimes_pilot,
                          opt_or_dur = 'duration'))

# COMBINED UTILITY Net  ===========================
a=coef(MPNet_model)[1]
b=coef(MPNet_model)[2]
c=coef(MPNet_model)[3]
d=coef(MPNet_model)[4]


alpha_pref_comb_net=optimize(fun_optim_prx_logit_comb,
                      masses     = c(masses,masses),
                      mvttimes   = c(mvttimes_pref,mvttimes_smallt),
                      glm1       = pref_glm_use,
                      glm2       = smallt_glm_use,
                      rxtimes    = c(rxtimes_pref,rxtimes_smallt),
                      opt_or_dur = 'optimize',
                      interval   = c(-100,200))

util_dur_pref_alpha_comb_net = as.numeric(fun_optim_prx_logit_comb(alpha_pref_comb_net$minimum,
                                       masses     = c(masses,masses),
                                       mvttimes   = c(mvttimes_pref,mvttimes_smallt),
                                       glm1       = pref_glm_use,
                                       glm2       = smallt_glm_use,
                                       opt_or_dur = 'duration',
                                       rxtimes    = c(rxtimes_pref,rxtimes_smallt)))

ut1_net_alpha_2a2b = alpha_pref_comb_net
ut1_net_dur_2a2b   = util_dur_pref_alpha_comb_net

ut1_net_dur_2a2b2c = as.numeric(fun_optim_prx(
                          alpha    = alpha_pref_comb_net$minimum,
                          masses   = masses,
                          mvttimes = mvttimes_pilot,
                          p_alpha  = p_alpha_pilot_gross,
                          rxtimes  = rxtimes_pilot,
                          opt_or_dur = 'duration'))

# Pilot
# Gross
a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]

p_alphas = data.frame('data_set' = c(rep('smallt',4),rep('pref',4),rep('pilot',4)),
                      'eff_mass' = cbind(rep(masses,3)),
                      'p_alpha'  = c(p_alpha_smallt_gross, p_alpha_pref, p_alpha_pilot_gross),
                      'movedur'  = c(mvttimes_smallt,mvttimes_pref, mvttimes_pilot),
                      'expnum'   = c(rep(3,4),rep(1,4),rep(2,4)))

p_alphas$expnum = as.factor(p_alphas$expnum)
p_alpha_plot <- ggplot()+
  geom_line(data=p_alphas,aes(x=movedur,y=p_alpha,color=expnum),size=3)+
  labs(x='Movement Duration (s)',
       y='Probability of Success')+
  scale_color_manual(labels = c('Circle\n(Normal)','None\n(Large)','Arc\n(Small)'),values = gg_color_hue(3))+
  # theme_classic()
  theme(text              = element_text(size=15,color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        legend.text       = element_text(size=12),
        legend.text.align = 0,
        legend.position   = 'right',
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))+
  guides(color=guide_legend(override.aes = list(size = 7),
                            title="Target type\n(size)",
                            keyheight=.5,
                            default.unit='inch'))

# setwd(pref_plots_dir)
# if (save_plots){ggsave(filename='p_alpha_plot.pdf',plot=p_alpha_plot,height=4,width=6,useDingbats=FALSE)}

## Using ut2/ut3/ut4 ===========================

fun_optim_prx_comb_ut2 <- function(alpha,masses,mvttimes,p_alpha,rxtimes,opt_or_dur){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = p_alpha[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.1,2,0.001)
    ut = rep(0,length(times))
    for (t in times){
      ut[count] = alpha*p-a0*rt-(a*t+b*(m^c)/(t^(d-1)))
      count = count+1
    }
    dur[k] = times[which.max(ut)]
  }
  err = (mvttimes-dur)^2
  if (opt_or_dur == 'optimize'){
    return(sum(err))
  } else if (opt_or_dur == 'duration'){
    return(dur)
  }
}

fun_optim_prx_logit_comb_ut2 <- function(alpha,masses,mvttimes,glm1,glm2,rxtimes,opt_or_dur){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.1,2,0.001)
    ut = rep(0,length(times))
    if (k<5){
      probs = inv.logit(predict(glm1,data.frame(movedur=times,eff_mass=m)))
    } else {
      probs = inv.logit(predict(glm2,data.frame(movedur=times,eff_mass=m)))
    }
    t_count = 0
    for (t in times){
      t_count = t_count+1
      ut[count] = alpha*probs[t_count]-a0*rt-(a*t+b*(m^c)/(t^(d-1)))
      count = count+1
    }
    dur[k] = times[which.max(ut)]
  }
  err = (mvttimes-dur)^2
  if (opt_or_dur == 'optimize'){
    return(sum(err))
  } else if (opt_or_dur == 'duration'){
    return(dur)
  }
}

a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]
ut2_grs_alpha_2a2b=optimize(fun_optim_prx_logit_comb_ut2,
                        masses     = c(masses,masses),
                        mvttimes   = c(mvttimes_pref,mvttimes_smallt),
                        glm1       = pref_glm_use,
                        glm2       = smallt_glm_use,
                        rxtimes    = c(rxtimes_pref,rxtimes_smallt),
                        opt_or_dur = 'optimize',
                        interval   = c(-100,1000))

ut2_grs_dur_2a2b = as.numeric(fun_optim_prx_logit_comb_ut2(
  alpha      = ut2_grs_alpha_2a2b$minimum,
  masses     = c(masses,masses),
  mvttimes   = c(mvttimes_pref,mvttimes_smallt),
  glm1       = pref_glm_use,
  glm2       = smallt_glm_use,
  opt_or_dur = 'duration',
  rxtimes    = c(rxtimes_pref,rxtimes_smallt)))

ut2_grs_dur_2a2b2c = as.numeric(fun_optim_prx_ut2(
  alpha    = ut2_grs_alpha_2a2b$minimum,
  masses   = masses,
  mvttimes = mvttimes_pilot,
  p_alpha  = p_alpha_pilot_gross,
  rxtimes  = rxtimes_pilot,
  opt_or_dur = 'duration'))

fun_optim_prx_comb_ut3 <- function(alpha,masses,mvttimes,p_alpha,rxtimes,opt_or_dur){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    p = p_alpha[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.1,2,0.001)
    ut = rep(0,length(times))
    for (t in times){
      ut[count] = ((alpha*p)/(t+rt))-a0*rt-(a*t+b*(m^c)/(t^(d-1)))
      count = count+1
    }
    dur[k] = times[which.max(ut)]
  }
  err = (mvttimes-dur)^2
  if (opt_or_dur == 'optimize'){
    return(sum(err))
  } else if (opt_or_dur == 'duration'){
    return(dur)
  }
}

fun_optim_prx_logit_comb_ut3 <- function(alpha,masses,mvttimes,glm1,glm2,rxtimes,opt_or_dur){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.1,2,0.001)
    ut = rep(0,length(times))
    if (k<5){
      probs = inv.logit(predict(glm1,data.frame(movedur=times,eff_mass=m)))
    } else {
      probs = inv.logit(predict(glm2,data.frame(movedur=times,eff_mass=m)))
    }
    t_count = 0
    for (t in times){
      t_count = t_count+1
      ut[count] = ((alpha*probs[t_count])/(t+rt))-a0*rt-(a*t+b*(m^c)/(t^(d-1)))
      count = count+1
    }
    dur[k] = times[which.max(ut)]
  }
  err = (mvttimes-dur)^2
  if (opt_or_dur == 'optimize'){
    return(sum(err))
  } else if (opt_or_dur == 'duration'){
    return(dur)
  }
}

a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]
ut3_grs_alpha_2a2b = optimize(fun_optim_prx_logit_comb_ut3,
                          masses     = c(masses,masses),
                          mvttimes   = c(mvttimes_pref,mvttimes_smallt),
                          glm1       = pref_glm_use,
                          glm2       = smallt_glm_use,
                          rxtimes    = c(rxtimes_pref,rxtimes_smallt),
                          opt_or_dur = 'optimize',
                          interval   = c(-100,1000))

ut3_grs_dur_2a2b = as.numeric(fun_optim_prx_logit_comb_ut3(
  alpha      = ut3_grs_alpha_2a2b$minimum,
  masses     = c(masses,masses),
  mvttimes   = c(mvttimes_pref,mvttimes_smallt),
  glm1       = pref_glm_use,
  glm2       = smallt_glm_use,
  opt_or_dur = 'duration',
  rxtimes    = c(rxtimes_pref,rxtimes_smallt)))

ut3_grs_dur_2a2b2c = as.numeric(fun_optim_prx_ut3(
  alpha    = ut3_grs_alpha_2a2b$minimum,
  masses   = masses,
  mvttimes = mvttimes_pilot,
  p_alpha  = p_alpha_pilot_gross,
  rxtimes  = rxtimes_pilot,
  opt_or_dur = 'duration'))

fun_optim_prx_logit_comb_ut4 <- function(alpha,masses,mvttimes,glm1,glm2,rxtimes,opt_or_dur){
  err=0
  dur = rep(0,length(mvttimes))
  for (k in 1:length(mvttimes)){
    t = mvttimes[k]
    m = masses[k]
    rt = rxtimes[k]
    count = 1
    times = seq(0.1,2,0.001)
    ut = rep(0,length(times))
    if (k<5){
      probs = inv.logit(predict(glm1,data.frame(movedur=times,eff_mass=m)))
    } else {
      probs = inv.logit(predict(glm2,data.frame(movedur=times,eff_mass=m)))
    }
    t_count = 0
    for (t in times){
      t_count = t_count+1
      ut[count] = (alpha*probs[t_count])/(a0*rt+(a*t+b*(m^c)/(t^(d-1))))
      count = count+1
    }
    dur[k] = times[which.max(ut)]
  }
  err = (mvttimes-dur)^2
  if (opt_or_dur == 'optimize'){
    return(sum(err))
  } else if (opt_or_dur == 'duration'){
    return(dur)
  }
}

ut4_grs_dur_2a2b = c(ut4_grs_dur_2a,ut4_grs_dur_2b)
ut4_grs_dur_2a2b2c = c(ut4_grs_dur_2c)

## Using ut2 net ===========================

## Net Utility
a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPNet_model)[1]
b=coef(MPNet_model)[2]
c=coef(MPNet_model)[3]
d=coef(MPNet_model)[4]

ut2_net_alpha_2a2b=optimize(fun_optim_prx_logit_comb_ut2,
                        masses     = c(masses,masses),
                        mvttimes   = c(mvttimes_pref,mvttimes_smallt),
                        glm1       = pref_glm_use,
                        glm2       = smallt_glm_use,
                        rxtimes    = c(rxtimes_pref,rxtimes_smallt),
                        opt_or_dur = 'optimize',
                        interval   = c(-100,1000))

ut2_net_dur_2a2b = as.numeric(fun_optim_prx_logit_comb_ut2(
  alpha      = ut2_net_alpha_2a2b$minimum,
  masses     = c(masses,masses),
  mvttimes   = c(mvttimes_pref,mvttimes_smallt),
  glm1       = pref_glm_use,
  glm2       = smallt_glm_use,
  opt_or_dur = 'duration',
  rxtimes    = c(rxtimes_pref,rxtimes_smallt)))

ut2_net_dur_2a2b2c = as.numeric(fun_optim_prx_ut2(
  alpha    = ut2_net_alpha_2a2b$minimum,
  masses   = masses,
  mvttimes = mvttimes_pilot,
  p_alpha  = p_alpha_pilot_gross,
  rxtimes  = rxtimes_pilot,
  opt_or_dur = 'duration'))

## Using ut3 net ===========================

## Net Utility
a0 = mean(mpdata$metpowerrest)
a0_se = sd(mpdata$metpowerrest)/sqrt(8)
a=coef(MPNet_model)[1]
b=coef(MPNet_model)[2]
c=coef(MPNet_model)[3]
d=coef(MPNet_model)[4]
ut3_net_alpha_2a2b = optimize(fun_optim_prx_logit_comb_ut3,
                          masses     = c(masses,masses),
                          mvttimes   = c(mvttimes_pref,mvttimes_smallt),
                          glm1       = pref_glm_use,
                          glm2       = smallt_glm_use,
                          rxtimes    = c(rxtimes_pref,rxtimes_smallt),
                          opt_or_dur = 'optimize',
                          interval   = c(-100,1000))

ut3_net_dur_2a2b = as.numeric(fun_optim_prx_logit_comb_ut3(
  alpha      = ut3_net_alpha_2a2b$minimum,
  masses     = c(masses,masses),
  mvttimes   = c(mvttimes_pref,mvttimes_smallt),
  glm1       = pref_glm_use,
  glm2       = smallt_glm_use,
  opt_or_dur = 'duration',
  rxtimes    = c(rxtimes_pref,rxtimes_smallt)))

ut3_net_dur_2a2b2c = as.numeric(fun_optim_prx_ut3(
  alpha    = ut3_net_alpha_2a2b$minimum,
  masses   = masses,
  mvttimes = mvttimes_pilot,
  p_alpha  = p_alpha_pilot_gross,
  rxtimes  = rxtimes_pilot,
  opt_or_dur = 'duration'))


## Using ut4 net

ut4_net_dur_2a2b = c(ut4_net_dur_2a,ut4_net_dur_2b)
ut4_net_dur_2a2b2c = c(ut4_net_dur_2a,ut4_net_dur_2b,ut4_net_dur_2c)
## Reset Gross ==============
a=coef(MPGross_model)[1]
b=coef(MPGross_model)[2]*100
c=coef(MPGross_model)[3]
d=coef(MPGross_model)[4]


```


## Table for the coefficients in Utility Modeling
We next fitted a utility model by altering $\alpha$ to try and predict the movement durations seen in 2a,b,c.

The utility function that is fit for these next plots is below.
$T_r$ and $T_m$ are the reaction time and movement duration.
$P(R|m,t)$ is determined from the section above, probability alpha modeling. $a$, $b$, $c$, $d$ are determined from the metabolic data.
Resting rate is shown by $a_0$, and $a_0$ = `r round(mean(mpdata_rest),3)`.
The parameters a, b, c, and d are shown in \@ref(tab:effortmodtab).

$$J = \frac{\alpha P(R|m,T_m) -\left( a_0 T_r + a T_m + \frac{bm^c}{T_m^d} \right)}{T_r+T_m}$$
Ideally the probability function has an effect of mass in it, but for the following results we use the glm from experiment 2a/2b to fit $\alpha$, which leads to the probability function only including a term of time.

$$J = \frac{\alpha P(R|T_m) -\left( a_0 T_r + a T_m + \frac{bm^c}{T_m^d} \right)}{T_r+T_m}$$

$T_r$ and $T_m$ are the reaction time and movement duration. Using the values from experiment 2a,b,c, we can optimize the error of the prediction by altering $\alpha$.

The tables below show the movement durations (\@ref{tab:utilmovedurstab}), reaction time (\@ref{rab:utilreacttimestab}).

```{r, echo = FALSE, warnings = FALSE}
# This just shows the movement durations and reaction times used.
# These are total averages, not average of averages.

movedurs = cbind(round(aggregate(movedur~eff_mass,prefdata,mean)$movedur,3),
                 round(aggregate(movedur~eff_mass,smalltdata,mean)$movedur,3),
                 round(aggregate(movedur~eff_mass,pilotdata,mean)$movedur,3))
colnames(movedurs) = c('2a','2b','2c')
rownames(movedurs) = c('2.506 kg','3.959  kg','4.894  kg','6.282 kg')


reacttimes = cbind(round(aggregate(reaction_tanv~eff_mass,prefdata,mean)$reaction_tanv,3),
                   round(aggregate(reaction_tanv~eff_mass,smalltdata,mean)$reaction_tanv,3),
                   round(aggregate(reaction_tanv~eff_mass,pilotdata,mean)$reaction_tanv,3))
colnames(reacttimes) = c('2a','2b','2c')
rownames(reacttimes) = c('2.506 kg','3.959  kg','4.894  kg','6.282 kg')

```

```{r utilmovedurstab, echo = FALSE, warning = FALSE, message = FALSE}
kable(movedurs, caption = 'Movement durations by experiement and effective mass used in the Utility model')
```

```{r utilreacttimestab, echo = FALSE, warnigns = FALSE}
kable(reacttimes, caption = 'Reaction times by experiement and effective mass used in the Utility model')
```

## Experimental Utility Fits
FITTING Three ALPHA VALUEs, one to each experiment.
### 2a Alpha
This table (\@ref(tab:utildurs2a)) shows the $\alpha$ value, predicted duration for the models, and the SSE between that and the experimental data. The SSE for all these models is shown in detail later.

```{r utildurs2a, echo = FALSE, warning = FALSE, message = FALSE}
# These next chunks make tables and plots for predicted movement durations when 
# fitting 3 alpha values, one to each experiment.

tab1 = cbind(c(round(alpha_utility_net_rx$minimum,4)),
             c(round(alpha_utility_gross_rx$minimum,4)),
             c(round(alpha_torque_2a,4)),
             c(round(alpha_torque_2a_mj,4)))
# rownames(tab1) = c('a0','a','b','c','d','$\\alpha$')
rownames(tab1) = c('$\\alpha$')
colnames(tab1) = c('Net Metabolics', 'Gross Metabolics','Torque$^2$','Torque$^2$ minjerk')

tab2 = cbind(c(0,
               round(aggregate(movedur ~ eff_mass,prefdata,mean)$movedur,4),
               0),
             c(0,
               round(met_net_dur,4),
               formatC(sum((met_net_dur-mvttimes_pref)^2),format = 'e', digits = 3)),
             c(0,
               round(met_gross_dur,4),
               formatC(sum((met_gross_dur-mvttimes_pref)^2),format = 'e', digits = 3)),
             c(round(alpha_utility_net_rx$minimum,4),
               round(util_dur_net_rx,4),
               formatC(sum((util_dur_net_rx-mvttimes_pref)^2),format = 'e', digits = 3)),
             c(round(alpha_utility_gross_rx$minimum,4),
               round(util_dur_gross_rx,4),
               formatC(sum((util_dur_gross_rx-mvttimes_pref)^2),format = 'e', digits = 3)),
             c(round(alpha_torque_2a,4),
               round(torque_dur_2a,4),
               formatC(sum((torque_dur_2a-mvttimes_pref)^2),format = 'e', digits = 3)),
             c(round(alpha_torque_2a_mj,4),
               round(torque_mj_dur_2a,4),
               formatC(sum((torque_mj_dur_2a-mvttimes_pref)^2),format = 'e', digits = 3)))
rownames(tab2) = c('Alpha','2.44','4.83','7.13','11.69','SSE')
colnames(tab2) = c('2a Experiment','Net Metabolic Power','Gross Metabolic power','Utility (Net Power)', 'Utility (Gross Power','Torque$^2$','Torque$^2$ minjerk')

```

<!-- ```{r utilcoefftabs, echo = FALSE, warning = FALSE, message = FALSE} -->
<!--   kable(tab1, caption = 'Parameters used in the Utility modeling') -->
<!-- ``` -->


```{r , echo = FALSE, warning = FALSE, message = FALSE}
  kable(tab2, caption = 'Preferred duration and predicted durations for each model.')
```

The probability of success for utility in experiement 2a using the optimized alpha value are shown below.

```{r optprobstab2a, echo = FALSE, warning = FALSE, message = FALSE}
  
opt_probs = cbind(inv.logit(predict(pref_glm_use,data.frame(movedur=util_dur_net_rx,eff_mass=masses))),
                  inv.logit(predict(pref_glm_use,data.frame(movedur=util_dur_gross_rx,eff_mass=masses))),
                  inv.logit(predict(pref_glm_use,data.frame(movedur=torque_dur_2a,eff_mass=masses))),
                  inv.logit(predict(pref_glm_use,data.frame(movedur=torque_mj_dur_2a,eff_mass=masses))))

rownames(opt_probs) = masses
colnames(opt_probs) = c('Utility Net','Utility Gross','Utility Torque','Utility Torque Mj')

kable(opt_probs, caption = 'Probability of success used in utility modeling when fitting alpha, Expirement 2a.')
```


### 2b Alpha

This table (\@ref(tab:utildurs2b)) shows the $\alpha$ value, predicted durations for the models, and the SSE between that and the experimental data. The SSE for all these models is shown in detail later (section \@ref{SSE2b}).

```{r , echo = FALSE, warning = FALSE, message = FALSE}
tab1 = cbind(c(round(alpha_smallt_net$minimum,4)),
             c(round(alpha_smallt_gross$minimum,4)),
             c(round(alpha_torque_2b,4)),
             c(round(alpha_torque_2b_mj,4)))
# rownames(tab1) = c('a0','a','b','c','d','$\\alpha$')
rownames(tab1) = c('$\\alpha$')
colnames(tab1) = c('Net Metabolics', 'Gross Metabolics','Torque$^2$','Torque$^2$ minjerk')

tab2 = cbind(c(0,
               round(mvttimes_smallt,4),
               0),
             c(0,
               round(met_net_dur,4),
               formatC(sum((met_net_dur-mvttimes_smallt)^2),format = 'e', digits = 3)),
             c(0,
               round(met_gross_dur,4),
               formatC(sum((met_gross_dur-mvttimes_smallt)^2),format = 'e', digits = 3)),
             c(round(alpha_smallt_net$minimum,4),
               round(util_dur_smallt_net,4),
               formatC(sum((util_dur_smallt_net-mvttimes_smallt)^2),format = 'e', digits = 3)),
             c(round(alpha_smallt_gross$minimum,4),
               round(util_dur_smallt_gross,4),
               formatC(sum((util_dur_smallt_gross-mvttimes_smallt)^2),format = 'e', digits = 3)),
             c(round(alpha_torque_2b,4),
               round(torque_dur_2b,4),
               formatC(sum((torque_dur_2b-mvttimes_smallt)^2),format = 'e', digits = 3)),
             c(round(alpha_torque_2b_mj,4),
               round(torque_mj_dur_2b,4),
               formatC(sum((torque_mj_dur_2b-mvttimes_smallt)^2),format = 'e', digits = 3)))
rownames(tab2) = c('Alpha','2.44','4.83','7.13','11.69','SSE')
colnames(tab2) = c('2b Experiment','Net Metabolic Power','Gross Metabolic power','Utility (Net Power)', 'Utility (Gross Power','Torque$^2$','Torque$^2$ minjerk')

```


```{r utildurs2b, echo = FALSE, warning = FALSE, message = FALSE}
  kable(tab2, caption = 'Preferred duration and predicted durations for each model.')
```

The probability of success for utility in experiement 2b using the optimized alpha value are shown below.

```{r optprobstab2b, echo = FALSE, warning = FALSE, message = FALSE}
  
opt_probs = cbind(inv.logit(predict(smallt_glm_use,data.frame(movedur=util_dur_smallt_net,eff_mass=masses))),
                  inv.logit(predict(smallt_glm_use,data.frame(movedur=util_dur_smallt_gross,eff_mass=masses))),
                  inv.logit(predict(smallt_glm_use,data.frame(movedur=torque_dur_2b,eff_mass=masses))),
                  inv.logit(predict(smallt_glm_use,data.frame(movedur=torque_mj_dur_2b,eff_mass=masses))))

rownames(opt_probs) = masses
colnames(opt_probs) = c('Utility Net','Utility Gross','Utility Torque','Utility Torque Mj')

kable(opt_probs, caption = 'Probability of success used in utility modeling when fitting alpha, Expirement 2b.')
```


### 2c Alpha

This table (\@ref(tab:utildurs2c)) shows the $\alpha$ value, predicted durations for the models, and the SSE between that and the experimental data. The SSE for all these models is shown in detail later (section \@ref{SSE2b}).

```{r , echo = FALSE, warning = FALSE, message = FALSE}
tab1 = cbind(c(round(alpha_pilot_net$minimum,4)),
             c(round(alpha_pilot_gross$minimum,4)),
             c(round(alpha_torque_2c,4)),
             c(round(alpha_torque_2c_mj,4)))
# rownames(tab1) = c('a0','a','b','c','d','$\\alpha$')
rownames(tab1) = c('$\\alpha$')
colnames(tab1) = c('Net Metabolics', 'Gross Metabolics','Torque$^2$','Torque$^2$ minjerk')

tab2 = cbind(c(0,
               round(mvttimes_pilot,4),
               0),
             
             c(0,
               round(met_net_dur,4),
               formatC(sum((met_net_dur-mvttimes_pilot)^2),format = 'e', digits = 3)),
             
             c(0,
               round(met_gross_dur,4),
               formatC(sum((met_gross_dur-mvttimes_pilot)^2),format = 'e', digits = 3)),
             
             c(round(alpha_pilot_net$minimum,4),
               round(util_dur_pilot_net,4),
               formatC(sum((util_dur_pilot_net-mvttimes_pilot)^2),format = 'e', digits = 3)),
             
             c(round(alpha_pilot_gross$minimum,4),
               round(util_dur_pilot_gross,4),
               formatC(sum((util_dur_pilot_gross-mvttimes_pilot)^2),format = 'e', digits = 3)),
             
             c(round(alpha_torque_2c,4),
               round(torque_dur_2c,4),
               formatC(sum((torque_dur_2c-mvttimes_pilot)^2),format = 'e', digits = 3)),
             
             c(round(alpha_torque_2c_mj,4),
               round(torque_mj_dur_2c,4),
               formatC(sum((torque_mj_dur_2c-mvttimes_pilot)^2),format = 'e', digits = 3)))
rownames(tab2) = c('Alpha','2.44','4.83','7.13','11.69','SSE')
colnames(tab2) = c('2c Experiment','Net Metabolic Power','Gross Metabolic power','Utility (Net Power)', 'Utility (Gross Power','Torque$^2$','Torque$^2$ minjerk')

```


```{r utildurs2c, echo = FALSE, warning = FALSE, message = FALSE}
  kable(tab2, caption = 'Preferred duration and predicted durations for each model.')
```

The probability of success for utility in experiement 2b using the optimized alpha value are shown below.

```{r optprobstab2c, echo = FALSE, warning = FALSE, message = FALSE}
  
opt_probs = cbind(c(1,1,1,1),
                  c(1,1,1,1),
                  c(1,1,1,1),
                  c(1,1,1,1))

rownames(opt_probs) = masses
colnames(opt_probs) = c('Utility Net','Utility Gross','Utility Torque','Utility Torque Mj')

kable(opt_probs, caption = 'Probability of success used in utility modeling when fitting alpha, Expirement 2c.')
```


```{r, echo = FALSE, warning = FALSE}

control_times = rbind(cbind(rep('smallt',4),rep('data',4),c(2.506,3.959,4.894,6.282),mvttimes_smallt,rep(3,4),mvttimes_smallt_se),
                      cbind(rep('pref',4),rep('data',4),c(2.506,3.959,4.894,6.282),mvttimes_pref,rep(1,4),mvttimes_pref_se),
                      cbind(rep('pilot',4),rep('data',4),c(2.506,3.959,4.894,6.282),mvttimes_pilot,rep(2,4),mvttimes_pilot_se),
                      
                      cbind(rep('smallt',4),rep('model',4),c(2.506,3.959,4.894,6.282),util_dur_smallt_gross,rep(3,4),rep(0,4)),
                      cbind(rep('pref',4),rep('model',4),c(2.506,3.959,4.894,6.282),util_dur_gross_rx,rep(1,4),rep(0,4)),
                      cbind(rep('pilot',4),rep('model',4),c(2.506,3.959,4.894,6.282),util_dur_pilot_gross,rep(2,4),rep(0,4)))
                      # cbind(rep('pilot',4),rep('model',4),c(2.506,3.959,4.894,6.282),util_dur_pilot_gross_alpha_comb_gross,rep(2,4),rep(0,4)))
colnames(control_times) = c('exp','datatype','eff_mass','movedur','expnum','movedur_se')


control_times = as.data.frame(control_times)
control_times$movedur = as.numeric(as.character(control_times$movedur))
control_times$movedur_se = as.numeric(as.character(control_times$movedur_se))
control_times$eff_mass = as.numeric(as.character(control_times$eff_mass))

utilfits_by_exp_3alphas <- ggplot()+
  geom_errorbar(data=control_times,
                aes(x=eff_mass,
                    ymin=movedur-movedur_se,
                    ymax=movedur+movedur_se,
                    color=expnum,
                    alpha=datatype),
                size=3,
                width=.2)+
  geom_line(data=control_times,
              aes(x=eff_mass,
                  y=movedur,
                  linetype=datatype,
                  color=expnum,
                  alpha = datatype),
              size=3)+
  # geom_line(data=data.frame(cbind(unique(control_times$eff_mass),
  #                           util_dur_pilot_gross_alpha_comb_gross) %>% `colnames<-`(c('eff_mass','movedur'))),
  #           aes(x=eff_mass,
  #               y=movedur),
  #           linetype = 'dashed',
  #           color = 'black',
  #           size=3)+
  geom_line(data=data.frame(cbind(unique(control_times$eff_mass),
                                  met_gross_dur) %>% `colnames<-`(c('eff_mass','movedur'))),
            aes(x=eff_mass,
                y=movedur),
            linetype = 'dashed',
            color    = 'red',
            size=3)+
  scale_linetype_manual(values=c('solid','dashed'),
                        labels=c('Data (Solid)','Model (Dashed)'))+
  scale_alpha_discrete(range=c(.5,1),
                        labels=c('Data (Solid)','Model (Dashed)'))+
  labs(x='Effective mass (kg)',
       y='Movement Duration (s)',
       title = paste('Util fits by Experiment\n2a \U1D6FC = ',round(alpha_utility_gross_rx$minimum,3),
                     ', 2b \U1D6FC = ',
                     round(alpha_smallt_gross$minimum,3),
                     ', 2c \U1D6FC = ',
                     round(alpha_pilot_gross$minimum,3),
                     '\nRed = metgross min',sep=''))+
  scale_color_manual(labels = c('2a',
                                '2b',
                                '2c',
                                'Gross Met Min'),
                     values = c(gg_color_hue(3),
                                'black',
                                'red'))+
  scale_x_continuous(breaks = c(unique(control_times$eff_mass)))+
  theme_classic()+
  theme(text              = element_text(size=20,color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        legend.text       = element_text(size=15),
        legend.text.align = 0,
        legend.position   = 'right',
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))+
  guides(color=guide_legend(override.aes = list(size = 7),
                            title="Target type\n(size)",
                            keyheight=.5,
                            default.unit='inch'),
         linetype = guide_legend(title="Data Type",
                           keyheight=.4,
                           default.unit='inch'),
         alpha = FALSE)


setwd(pref_plots_dir)
if (save_plots){ggsave(filename='utilfits_by_exp_3alphas.pdf',plot=utilfits_by_exp_3alphas,height=4,width=6,useDingbats=FALSE)}

```

```{r utilfits3alphas, echo = FALSE, warning = FALSE, fig.width=12, fig.height=9, fig.cap = 'Utility fits across experiments.'}
  utilfits_by_exp_3alphas
```

## 2a and 2b Combined Utility fits
This section analysis fits one $\alpha$ value to experiment 2a and 2b at the same time.
These next tables show the movement durations, predicted movement durations, the fitted alpha values, and the probabilities of success.
The $\alpha$ value for 2a and 2b are fit at once, so it is the same. 2c has its own $\alpha$ value.

The $\alpha$ value fitted here is `r alpha_pref_comb_gross$minimum`.
The SSE for experiment 2a/2b when using one alpha is `r formatC(sum((mvttimes_pref -util_dur_pref_alpha_comb_gross[1:4])^2)+sum((mvttimes_smallt -util_dur_pref_alpha_comb_gross[5:8])^2),format = 'e', digits = 3)`.
The SSE for experiment 2c is `r formatC(sum((util_dur_pilot_gross-mvttimes_pilot)^2),format = 'e', digits = 3)`. 
The total SSE for all 3 is `r formatC(sum((mvttimes_pref -util_dur_pref_alpha_comb_gross[1:4])^2)+sum((mvttimes_smallt -util_dur_pref_alpha_comb_gross[5:8])^2)+sum((util_dur_pilot_gross-mvttimes_pilot)^2),format = 'e', digits = 3)`.


```{r, echo = FALSE, warning = FALSE}
# These code chunks fits one alpha to 2a/2b, and creates tables and plots to show the results.
# This chunk specifically shows two tables, experimental and predicted movement durations 
# for our main utility.
# Also report probabilities of success used, and alpha values used.

comb_ut_probtab = cbind(round(inv.logit(predict(pref_glm_use,
                                                data.frame(movedur=util_dur_pref_alpha_comb_gross[1:4],eff_mass=masses))),4),
                        round(inv.logit(predict(smallt_glm_use,
                                                data.frame(movedur=util_dur_pref_alpha_comb_gross[5:8],eff_mass=masses))),4),
                        c(1,1,1,1))
colnames(comb_ut_probtab) = c('2a','2b','2c')
rownames(comb_ut_probtab) = unique(prefdata$eff_mass)

comb_ut_durtab = cbind(mvttimes_pref,
                       util_dur_pref_alpha_comb_gross[1:4],
                       mvttimes_smallt,
                       util_dur_pref_alpha_comb_gross[5:8],
                       mvttimes_pilot,
                       util_dur_pilot_gross)
colnames(comb_ut_durtab) = c('2a Exp','2a pred','2b Exp','2b pred','2c Exp','2c pred')
rownames(comb_ut_durtab) = unique(prefdata$eff_mass)

alph_tab = cbind(round(alpha_pref_comb_gross$minimum,3), round(alpha_pref_comb_gross$minimum,3), round(alpha_pilot_gross$minimum,3))
colnames(alph_tab) = c('2a','2b','2c')
rownames(alph_tab) = '\alpha'

```

```{r combutdurtab1, echo = FALSE, warning = FALSE, tab.cap = 'Experimental and predicted movement durations for the experiments.'}
kable(comb_ut_durtab, caption = 'Experimental and predicted movement durations for the experiments.')
```

```{r combutprobtab1, echo = FALSE, warning = FALSE, tab.cap = 'Probabilites of success for the experiments.'}
kable(comb_ut_probtab, caption = 'Probabilites of success for the experiments.')
```

```{r alphtab1, echo = FALSE, warning = FALSE, tab.cap = 'Alpha values fitted to experiment 2a/2b, and a seperate alpha for 2c.'}
kable(alph_tab, caption = 'Alpha values fitted to experiment 2a/2b, and a seperate alpha for 2c.')
```

### Grouped plot
```{r, echo = FALSE, warning = FALSE}
# Plot utility.

# control_times = rbind(cbind(rep('smallt',4),rep('data',4),unique(prefdata$eff_mass),mvttimes_smallt,rep(3,4),mvttimes_smallt_se),
#                       cbind(rep('pref',4),rep('data',4),unique(prefdata$eff_mass),mvttimes_pref,rep(1,4),mvttimes_pref_se),
#                       cbind(rep('pilot',4),rep('data',4),unique(prefdata$eff_mass),mvttimes_pilot,rep(2,4),mvttimes_pilot_se),
#                       
#                       cbind(rep('smallt',4),rep('model',4),unique(prefdata$eff_mass),util_dur_pref_alpha_comb_gross[5:8],rep(3,4),rep(0,4)),
#                       cbind(rep('pref',4),rep('model',4),unique(prefdata$eff_mass),util_dur_pref_alpha_comb_gross[1:4],rep(1,4),rep(0,4)),
#                       cbind(rep('pilot',4),rep('model',4),unique(prefdata$eff_mass),util_dur_pilot_gross,rep(2,4),rep(0,4)))
#                       # cbind(rep('pilot',4),rep('model',4),c(2.506,3.959,4.894,6.282),util_dur_pilot_gross_alpha_comb_gross,rep(2,4),rep(0,4)))
control_times = rbind(cbind(rep('smallt',4),rep('data',4),unique(prefdata$condition)/2.2,mvttimes_smallt,rep(3,4),mvttimes_smallt_se),
                      cbind(rep('pref',4),rep('data',4),unique(prefdata$condition)/2.2,mvttimes_pref,rep(1,4),mvttimes_pref_se),
                      cbind(rep('pilot',4),rep('data',4),unique(prefdata$condition)/2.2,mvttimes_pilot,rep(2,4),mvttimes_pilot_se),
                      
                      cbind(rep('smallt',4),rep('model',4),unique(prefdata$condition)/2.2,util_dur_pref_alpha_comb_gross[5:8],rep(3,4),rep(0,4)),
                      cbind(rep('pref',4),rep('model',4),unique(prefdata$condition)/2.2,util_dur_pref_alpha_comb_gross[1:4],rep(1,4),rep(0,4)),
                      cbind(rep('pilot',4),rep('model',4),unique(prefdata$condition)/2.2,util_dur_pilot_gross,rep(2,4),rep(0,4)))
                      # cbind(rep('pilot',4),rep('model',4),c(2.506,3.959,4.894,6.282),util_dur_pilot_gross_alpha_comb_gross,rep(2,4),rep(0,4)))
colnames(control_times) = c('exp','datatype','eff_mass','movedur','expnum','movedur_se')

control_times = as.data.frame(control_times)
control_times$movedur = as.numeric(as.character(control_times$movedur))
control_times$movedur_se = as.numeric(as.character(control_times$movedur_se))
control_times$eff_mass = as.numeric(as.character(control_times$eff_mass))

utilfits_by_exp_2alphas <- ggplot()+
  geom_errorbar(data=control_times,
                aes(x=eff_mass,
                    ymin=movedur-movedur_se,
                    ymax=movedur+movedur_se,
                    color=expnum,
                    alpha=datatype),
                size=3,
                width=.2)+
  geom_line(data=control_times,
              aes(x=eff_mass,
                  y=movedur,
                  linetype=datatype,
                  color=expnum,
                  alpha = datatype),
              size=3)+
  geom_line(data=data.frame(cbind(unique(control_times$eff_mass),
                            util_dur_pilot_gross_alpha_comb_gross) %>% `colnames<-`(c('eff_mass','movedur'))),
            aes(x=eff_mass,
                y=movedur),
            linetype = 'dashed',
            color = 'black',
            size=3)+
  geom_line(data=data.frame(cbind(unique(control_times$eff_mass),
                                  met_gross_dur) %>% `colnames<-`(c('eff_mass','movedur'))),
            aes(x=eff_mass,
                y=movedur),
            linetype = 'dashed',
            color    = 'red',
            size=3)+
  scale_linetype_manual(values=c('solid','dashed'),
                        labels=c('Data (Solid)','Model (Dashed)'))+
  scale_alpha_discrete(range=c(.5,1),
                        labels=c('Data (Solid)','Model (Dashed)'))+
  labs(x='Added mass (kg)',
       y='Movement Duration (s)',
       title = paste('Util fits by Experiment\n2a,2b \U1D6FC = ',
                     round(alpha_pref_comb_gross$minimum,3),
                     ', 2c \U1D6FC = ',
                     round(alpha_pilot_gross$minimum,3),
                     '\nBlack = prob equal 1, red = metgross min',sep=''))+
  scale_color_manual(labels = c('Circle\n(Normal)',
                                'None\n(Large)',
                                'Arc\n(Small)',
                                paste('\U1D6FC = ',round(alpha_pref_comb_gross$minimum,3),sep=''),
                                'Gross Met Min'),
                     values = c(gg_color_hue(3),
                                'black',
                                'red'))+
  scale_x_continuous(breaks = c(unique(control_times$eff_mass)))+
  theme_classic()+
  theme(text              = element_text(size=20,color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        legend.text       = element_text(size=15),
        legend.text.align = 0,
        legend.position   = 'right',
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))+
  guides(color=guide_legend(override.aes = list(size = 7),
                            title="Target type\n(size)",
                            keyheight=.5,
                            default.unit='inch'),
         linetype = guide_legend(title="Data Type",
                           keyheight=.4,
                           default.unit='inch'),
         alpha = FALSE)

setwd(pref_plots_dir)
if (save_plots){ggsave(filename='utilfits_by_exp_2alphas.pdf',plot=utilfits_by_exp_2alphas,height=8,width=12,useDingbats=FALSE)}

theme_set(theme_cowplot(font_size=12))
exp_legend <- get_legend(utilfits_by_exp_2alphas)

plots_to_fix = c('Movedur_by_experiment',
                 'Movedurnorm_by_experiment',
                 'utilfits_by_exp_2alphas')

for (plot in plots_to_fix){
  string = paste(plot,'<-',plot,'+
                 theme_classic()+
                 theme(text              = element_text(color=\'black\'),
                 axis.text         = element_text(color=\'black\'),
                 axis.ticks        = element_line(color=\'black\'),
                 plot.title        = element_text(hjust = 0.5),
                 axis.line         = element_line(color=\'black\'),
                 legend.position   = \'none\')',sep = '')
  eval(parse(text = string))
}

grouped_utility_movedur <- plot_grid(plot_grid(Movedur_by_experiment+
                                                 labs(title = 'Movement Duration\nBy Experiment')+
                                                 theme(legend.position='none',
                                                       plot.title = element_text(hjust = 0.5),
                                                       text=element_text(size=16)),
                                               Movedurnorm_by_experiment+
                                                 labs(title = 'Normalized Movement Duration\nBy Experiment')+
                                                 theme(legend.position='none',
                                                       plot.title = element_text(hjust = 0.5),
                                                       text=element_text(size=16)),
                                               labels=c('A','B'),
                                               label_size = 24),
                                     plot_grid(utilfits_by_exp_2alphas+
                                                 theme(text=element_text(size=16),
                                                       legend.position = 'none'),
                                               exp_legend,
                                               labels = c('C',''),
                                               label_size = 24,
                                               rel_widths = c(.8,.2)),
                                     nrow = 2,
                                     rel_heights = c(.4,.8))


setwd(pref_plots_dir)
if (save_plots){ggsave('grouped_utility_movedur.pdf',plot=grouped_utility_movedur,width=9/.8,height=9, useDingbats = FALSE)}

```

<!-- ```{r groupedutilitymovedur1, echo = FALSE, warning = FALSE, fig.width=12, fig.height=9, fig.cap = 'Utility fits across experiments.'} -->
<!--   grouped_utility_movedur -->
<!-- ``` -->



```{r utilfits2alphas, echo = FALSE, warning = FALSE, fig.width=12, fig.height=9, fig.cap = 'Utility fits across experiments.'}

  setwd(pref_plots_dir)
  if (save_plots){ggsave(filename='utilfits_by_exp_2alphas.pdf',plot=utilfits_by_exp_2alphas,height=4,width=6,useDingbats=FALSE)}
  utilfits_by_exp_2alphas+
     theme(text=element_text(size=16),
           legend.position = 'none')
```

# Different utility models

Utility 1:
$$J = \frac{\alpha P(R|m,T_m) -\left( a_0 T_r + a T_m + \frac{bm^c}{T_m^d} \right)}{T_r+T_m}$$

Utility 2:
$$J = \alpha P(R|m,T_m) -\left( a_0 T_r + a T_m + \frac{bm^c}{T_m^d} \right)$$

Utility 3:
$$J = \frac{\alpha P(R|m,T_m)}{T_r+T_m} -\left( a_0 T_r + a T_m + \frac{bm^c}{T_m^d} \right)$$

Utility 4:
$$J = \frac{P(R|m,T_m)}{a_0 T_r + a T_m + \frac{bm^c}{T_m^d}}$$

<!-- Utility 4 is utility 2 with net rate: -->
<!-- $$J = \alpha P(R|m,T_m) -\left( a_0 T_r + a_{net} T_m + \frac{b_{net}m^{c_{net}}}{T_m^{d_{net}}} \right)$$ -->

<!-- Utility 5 is utility 2 with net rate: -->
<!-- $$J = \frac{\alpha P(R|m,T_m)}{T_r+T_m} -\left( a_0 T_r + a_{net} T_m + \frac{b_{net}m^{c_{net}}}{T_m^{d_{net}}} \right)$$ -->
## All random utility models
### One Alpha value

```{r, echo = FALSE, warning = FALSE}
# This section creates tables of predicted durations and SSE values for 
# utility 1/2/3/, using net/gross.
# Creates SSE plots as well.

sse_fun <- function(dur1,dur2){
  sse = formatC(sum((dur1-dur2)^2),format = 'e', digits = 3)
  return(sse)
}

alt_ut_plot <- function(df, ylabel = 'Move Dur (s)',diff_or_abs){
  if (diff_or_abs == 'diff'){
    for(ut_mod in unique(filter(df,data!='Exp')$data)){
      df[df$data == ut_mod,'movedur'] = df[df$data == ut_mod,'movedur']-df[df$data == 'Exp','movedur']
    }
    df = filter(df,data!='Exp')
  }
  g<-ggplot()+
  geom_line(data = df,
            aes(x = eff_mass,
                y = movedur,
                group = factor(data),
                color = factor(data)),
            size = 1)+
  geom_point(data=df,
             aes(x = eff_mass,
                 y = movedur,
                 color = factor(data)),
             size = 2)+
  geom_point(data=filter(df,data=='Exp'),
             aes(x = eff_mass,
                 y = movedur),
             color = gg_color_hue(length(unique(df$data)))[1],
             size = 5)+
  geom_line(data=filter(df,data=='Exp'),
            aes(x = eff_mass,
                y = movedur,
                group = data),
            color = gg_color_hue(length(unique(df$data)))[1],
            size = 2)+
  geom_text(data = filter(df, eff_mass == 2.506),
            aes(x = eff_mass,
                y = movedur,
                label = data))+
  scale_color_manual(values = gg_color_hue(length(unique(df$data))))+
  labs(x = 'Effective Mass (kg)', y = ylabel, color = 'Data')#, title = 'ut2/ut3 not shown cause it doesn\'t fit.')
  if (diff_or_abs == 'diff'){
    g<-g+geom_hline(yintercept = 0, linetype = 'dashed')
  }
  return(g)
}

#2a =========================================================
ut_2a_tab = cbind(c('alpha',unique(prefdata$eff_mass),'SSE'),
                  c('alpha',round(mvttimes_pref,4),'SSE'),
                  c(round(ut1_grs_alpha_2a$minimum,3),ut1_grs_dur_2a,sse_fun(ut1_grs_dur_2a,mvttimes_pref)),
                  c(round(ut2_grs_alpha_2a$minimum,3),ut2_grs_dur_2a,sse_fun(ut2_grs_dur_2a,mvttimes_pref)),
                  c(round(ut3_grs_alpha_2a$minimum,3),ut3_grs_dur_2a,sse_fun(ut3_grs_dur_2a,mvttimes_pref)),
                  c(round(ut1_net_alpha_2a$minimum,3),ut1_net_dur_2a,sse_fun(ut1_net_dur_2a,mvttimes_pref)),
                  c(round(ut2_net_alpha_2a$minimum,3),ut2_net_dur_2a,sse_fun(ut2_net_dur_2a,mvttimes_pref)),
                  c(round(ut3_net_alpha_2a$minimum,3),ut3_net_dur_2a,sse_fun(ut3_net_dur_2a,mvttimes_pref)),
                  c(round(ut1_grs_alpha_2a2b$minimum,3),ut1_grs_dur_2a2b[1:4],sse_fun(ut1_grs_dur_2a2b[1:4],mvttimes_pref)),
                  c(round(ut2_grs_alpha_2a2b$minimum,3),ut2_grs_dur_2a2b[1:4],sse_fun(ut2_grs_dur_2a2b[1:4],mvttimes_pref)),
                  c(round(ut3_grs_alpha_2a2b$minimum,3),ut3_grs_dur_2a2b[1:4],sse_fun(ut3_grs_dur_2a2b[1:4],mvttimes_pref)),
                  c(round(ut1_net_alpha_2a2b$minimum,3),ut1_net_dur_2a2b[1:4],sse_fun(ut1_net_dur_2a2b[1:4],mvttimes_pref)),
                  c(round(ut2_net_alpha_2a2b$minimum,3),ut2_net_dur_2a2b[1:4],sse_fun(ut2_net_dur_2a2b[1:4],mvttimes_pref)),
                  c(round(ut3_net_alpha_2a2b$minimum,3),ut3_net_dur_2a2b[1:4],sse_fun(ut3_net_dur_2a2b[1:4],mvttimes_pref))
)
colnames(ut_2a_tab)<-c('eff_mass','Movement Duration (s)',
                       'Utility 1 Gross Duration',
                       'Utility 2 Gross Duration',
                       'Utility 3 Gross Duration',
                       'Utility 1 Net Duration',
                       'Utility 2 Net Duration',
                       'Utility 3 Net Duration',
                       'Utility Comb 1 Gross Duration',
                       'Utility Comb 2 Gross Duration',
                       'Utility Comb 3 Gross Duration',
                       'Utility Comb 1 Net Duration',
                       'Utility Comb 2 Net Duration',
                       'Utility Comb 3 Net Duration'
)
kable(ut_2a_tab, caption = '2a - Movement duration by utility model for experiment 2a.')

masses = unique(prefdata$eff_mass)
ut_2a_df = as.data.frame(rbind(cbind(masses,rep('Exp',4),mvttimes_pref),
                               cbind(masses,rep('Ut1Grs',4),ut1_grs_dur_2a),
                               cbind(masses,rep('Ut2Grs',4),ut2_grs_dur_2a),
                               cbind(masses,rep('Ut3Grs',4),ut3_grs_dur_2a),
                               cbind(masses,rep('Ut1Net',4),ut1_net_dur_2a),
                               cbind(masses,rep('Ut2Net',4),ut2_net_dur_2a),
                               cbind(masses,rep('Ut3Net',4),ut3_net_dur_2a),
                               cbind(masses,rep('Utcomb1Grs',4),ut1_grs_dur_2a2b[1:4]),
                               cbind(masses,rep('Utcomb2Grs',4),ut2_grs_dur_2a2b[1:4]),
                               cbind(masses,rep('Utcomb3Grs',4),ut3_grs_dur_2a2b[1:4]),
                               cbind(masses,rep('Utcomb1Net',4),ut1_net_dur_2a2b[1:4]),
                               cbind(masses,rep('Utcomb2Net',4),ut2_net_dur_2a2b[1:4]),
                               cbind(masses,rep('Utcomb3Net',4),ut3_net_dur_2a2b[1:4])) %>% `colnames<-`(c('eff_mass','data','movedur')))
ut_2a_df$movedur = as.numeric(as.character(ut_2a_df$movedur))
ut_2a_df$data = as.factor(ut_2a_df$data)

alt_ut_plots = list()
alt_ut_plots[['2a_abs']] <- alt_ut_plot(ut_2a_df,ylabel = '2a Move Dur (s)',diff_or_abs = 'null')
alt_ut_plots[['2a_diff']] <- alt_ut_plot(ut_2a_df,ylabel = '2a Move Dur Diff (s)',diff_or_abs = 'diff')

#2b =========================================================
ut_2b_tab = cbind(c('alpha',unique(prefdata$eff_mass),'SSE'),
                  c('alpha',round(mvttimes_smallt,4),'SSE'),
                  c(round(ut1_grs_alpha_2b$minimum,3),ut1_grs_dur_2b,sse_fun(ut1_grs_dur_2b,mvttimes_smallt)),
                  c(round(ut2_grs_alpha_2b$minimum,3),ut2_grs_dur_2b,sse_fun(ut2_grs_dur_2b,mvttimes_smallt)),
                  c(round(ut3_grs_alpha_2b$minimum,3),ut3_grs_dur_2b,sse_fun(ut3_grs_dur_2b,mvttimes_smallt)),
                  c(round(ut1_net_alpha_2b$minimum,3),ut1_net_dur_2b,sse_fun(ut1_net_dur_2b,mvttimes_smallt)),
                  c(round(ut2_net_alpha_2b$minimum,3),ut2_net_dur_2b,sse_fun(ut2_net_dur_2b,mvttimes_smallt)),
                  c(round(ut3_net_alpha_2b$minimum,3),ut3_net_dur_2b,sse_fun(ut3_net_dur_2b,mvttimes_smallt)),
                  c(round(ut1_grs_alpha_2a2b$minimum,3),ut1_grs_dur_2a2b[5:8],sse_fun(ut1_grs_dur_2a2b[5:8],mvttimes_smallt)),
                  c(round(ut2_grs_alpha_2a2b$minimum,3),ut2_grs_dur_2a2b[5:8],sse_fun(ut2_grs_dur_2a2b[5:8],mvttimes_smallt)),
                  c(round(ut3_grs_alpha_2a2b$minimum,3),ut3_grs_dur_2a2b[5:8],sse_fun(ut3_grs_dur_2a2b[5:8],mvttimes_smallt)),
                  c(round(ut1_net_alpha_2a2b$minimum,3),ut1_net_dur_2a2b[5:8],sse_fun(ut1_net_dur_2a2b[5:8],mvttimes_smallt)),
                  c(round(ut2_net_alpha_2a2b$minimum,3),ut2_net_dur_2a2b[5:8],sse_fun(ut2_net_dur_2a2b[5:8],mvttimes_smallt)),
                  c(round(ut3_net_alpha_2a2b$minimum,3),ut3_net_dur_2a2b[5:8],sse_fun(ut3_net_dur_2a2b[5:8],mvttimes_smallt)))
colnames(ut_2b_tab)<-c('eff_mass','Movement Duration (s)',
                       'Utility 1 Gross Duration',
                       'Utility 2 Gross Duration',
                       'Utility 3 Gross Duration',
                       'Utility 1 Net Duration',
                       'Utility 2 Net Duration',
                       'Utility 3 Net Duration',
                       'Utility Comb 1 Gross Duration',
                       'Utility Comb 2 Gross Duration',
                       'Utility Comb 3 Gross Duration',
                       'Utility Comb 1 Net Duration',
                       'Utility Comb 2 Net Duration',
                       'Utility Comb 3 Net Duration')
kable(ut_2b_tab, caption = '2b - Movement duration by utility model for experiment 2b.')

masses = unique(prefdata$eff_mass)
ut_2b_df = as.data.frame(rbind(cbind(masses,rep('Exp',4),mvttimes_smallt),
                               cbind(masses,rep('Ut1Grs',4),ut1_grs_dur_2b),
                               cbind(masses,rep('Ut2Grs',4),ut2_grs_dur_2b),
                               cbind(masses,rep('Ut3Grs',4),ut3_grs_dur_2b),
                               cbind(masses,rep('Ut1Net',4),ut1_net_dur_2b),
                               cbind(masses,rep('Ut2Net',4),ut2_net_dur_2b),
                               cbind(masses,rep('Ut3Net',4),ut3_net_dur_2b),
                               cbind(masses,rep('Utcomb1Grs',4),ut1_grs_dur_2a2b[5:8]),
                               cbind(masses,rep('Utcomb2Grs',4),ut2_grs_dur_2a2b[5:8]),
                               cbind(masses,rep('Utcomb3Grs',4),ut3_grs_dur_2a2b[5:8]),
                               cbind(masses,rep('Utcomb1Net',4),ut1_net_dur_2a2b[5:8]),
                               cbind(masses,rep('Utcomb2Net',4),ut2_net_dur_2a2b[5:8]),
                               cbind(masses,rep('Utcomb3Net',4),ut3_net_dur_2a2b[5:8])) %>% `colnames<-`(c('eff_mass','data','movedur')))
ut_2b_df$movedur = as.numeric(as.character(ut_2b_df$movedur))
ut_2b_df$data = as.factor(ut_2b_df$data)

alt_ut_plots[['2b_abs']]  <- alt_ut_plot(ut_2b_df,ylabel = '2b Move Dur (s)',diff_or_abs = 'null')
alt_ut_plots[['2b_diff']] <- alt_ut_plot(ut_2b_df,ylabel = '2b Move Dur Diff (s)',diff_or_abs = 'diff')

#2c =========================================================
ut_2c_tab = cbind(c('alpha',unique(prefdata$eff_mass),'SSE'),
                  c('alpha',round(mvttimes_pilot,4),'SSE'),
                  c(round(ut1_grs_alpha_2c$minimum,3),ut1_grs_dur_2c,sse_fun(ut1_grs_dur_2b,mvttimes_pilot)),
                  c(round(ut2_grs_alpha_2c$minimum,3),ut2_grs_dur_2c,sse_fun(ut2_grs_dur_2b,mvttimes_pilot)),
                  c(round(ut3_grs_alpha_2c$minimum,3),ut3_grs_dur_2c,sse_fun(ut3_grs_dur_2b,mvttimes_pilot)),
                  c(round(ut1_net_alpha_2c$minimum,3),ut1_net_dur_2c,sse_fun(ut1_net_dur_2b,mvttimes_pilot)),
                  c(round(ut2_net_alpha_2c$minimum,3),ut2_net_dur_2c,sse_fun(ut2_net_dur_2b,mvttimes_pilot)),
                  c(round(ut3_net_alpha_2c$minimum,3),ut3_net_dur_2c,sse_fun(ut3_net_dur_2b,mvttimes_pilot)),
                  c(round(ut1_grs_alpha_2a2b$minimum,3),ut1_grs_dur_2a2b2c,sse_fun(ut1_grs_dur_2a2b2c,mvttimes_pilot)),
                  c(round(ut2_grs_alpha_2a2b$minimum,3),ut2_grs_dur_2a2b2c,sse_fun(ut2_grs_dur_2a2b2c,mvttimes_pilot)),
                  c(round(ut3_grs_alpha_2a2b$minimum,3),ut3_grs_dur_2a2b2c,sse_fun(ut3_grs_dur_2a2b2c,mvttimes_pilot)),
                  c(round(ut1_net_alpha_2a2b$minimum,3),ut1_net_dur_2a2b2c,sse_fun(ut1_net_dur_2a2b2c,mvttimes_pilot)),
                  c(round(ut2_net_alpha_2a2b$minimum,3),ut2_net_dur_2a2b2c,sse_fun(ut2_net_dur_2a2b2c,mvttimes_pilot)),
                  c(round(ut3_net_alpha_2a2b$minimum,3),ut3_net_dur_2a2b2c,sse_fun(ut3_net_dur_2a2b2c,mvttimes_pilot)))
colnames(ut_2c_tab)<-c('eff_mass','Movement Duration (s)',
                       'Utility 1 Gross Duration',
                       'Utility 2 Gross Duration',
                       'Utility 3 Gross Duration',
                       'Utility 1 Net Duration',
                       'Utility 2 Net Duration',
                       'Utility 3 Net Duration',
                       'Utility Comb 1 Gross Duration',
                       'Utility Comb 2 Gross Duration',
                       'Utility Comb 3 Gross Duration',
                       'Utility Comb 1 Net Duration',
                       'Utility Comb 2 Net Duration',
                       'Utility Comb 3 Net Duration')
kable(ut_2c_tab, caption = '2c - Movement duration by utility model for experiment 2c.')

masses = unique(prefdata$eff_mass)
ut_2c_df = as.data.frame(rbind(cbind(masses,rep('Exp',4),mvttimes_pilot),
                               cbind(masses,rep('Ut1Grs',4),ut1_grs_dur_2c),
                               cbind(masses,rep('Ut2Grs',4),ut2_grs_dur_2c),
                               cbind(masses,rep('Ut3Grs',4),ut3_grs_dur_2c),
                               cbind(masses,rep('Ut1Net',4),ut1_net_dur_2c),
                               cbind(masses,rep('Ut2Net',4),ut2_net_dur_2c),
                               cbind(masses,rep('Ut3Net',4),ut3_net_dur_2c),
                               cbind(masses,rep('Utcomb1Grs',4),ut1_grs_dur_2a2b2c),
                               cbind(masses,rep('Utcomb2Grs',4),ut2_grs_dur_2a2b2c),
                               cbind(masses,rep('Utcomb3Grs',4),ut3_grs_dur_2a2b2c),
                               cbind(masses,rep('Utcomb1Net',4),ut1_net_dur_2a2b2c),
                               cbind(masses,rep('Utcomb2Net',4),ut2_net_dur_2a2b2c),
                               cbind(masses,rep('Utcomb3Net',4),ut3_net_dur_2a2b2c)) %>% `colnames<-`(c('eff_mass','data','movedur')))
ut_2c_df$movedur = as.numeric(as.character(ut_2c_df$movedur))
ut_2c_df$data = as.factor(ut_2c_df$data)

alt_ut_plots[['2c_abs']]  <- alt_ut_plot(ut_2c_df,ylabel = '2c Move Dur (s)',diff_or_abs = 'null')
alt_ut_plots[['2c_diff']] <- alt_ut_plot(ut_2c_df,ylabel = '2c Move Dur Diff (s)',diff_or_abs = 'diff')

```

```{r SSEaltutilitymodelsOneAlpha, echo = FALSE, warning = FALSE, fig.height=6, fig.width = 9, fig.cap = 'SSE Alternative utility models for 2a, 2b, and 2c.'}
# This is where the plots happen.

alt_ut_sse_df = rbind(cbind(rep('2a',12),
                            levels(ut_2a_df$data)[2:13],
                            c(sse_fun(ut1_grs_dur_2a,mvttimes_pref),
                              sse_fun(ut2_grs_dur_2a,mvttimes_pref),
                              sse_fun(ut3_grs_dur_2a,mvttimes_pref),
                              sse_fun(ut1_net_dur_2a,mvttimes_pref),
                              sse_fun(ut2_net_dur_2a,mvttimes_pref),
                              sse_fun(ut3_net_dur_2a,mvttimes_pref),
                              sse_fun(ut1_grs_dur_2a2b[1:4],mvttimes_pref),
                              sse_fun(ut2_grs_dur_2a2b[1:4],mvttimes_pref),
                              sse_fun(ut3_grs_dur_2a2b[1:4],mvttimes_pref),
                              sse_fun(ut1_net_dur_2a2b[1:4],mvttimes_pref),
                              sse_fun(ut2_net_dur_2a2b[1:4],mvttimes_pref),
                              sse_fun(ut3_net_dur_2a2b[1:4],mvttimes_pref))),
                      cbind(rep('2b',12),
                            levels(ut_2b_df$data)[2:13],
                            c(sse_fun(ut1_grs_dur_2b,mvttimes_smallt),
                              sse_fun(ut2_grs_dur_2b,mvttimes_smallt),
                              sse_fun(ut3_grs_dur_2b,mvttimes_smallt),
                              sse_fun(ut1_net_dur_2b,mvttimes_smallt),
                              sse_fun(ut2_net_dur_2b,mvttimes_smallt),
                              sse_fun(ut3_net_dur_2b,mvttimes_smallt),
                              sse_fun(ut1_grs_dur_2a2b[5:8],mvttimes_smallt),
                              sse_fun(ut2_grs_dur_2a2b[5:8],mvttimes_smallt),
                              sse_fun(ut3_grs_dur_2a2b[5:8],mvttimes_smallt),
                              sse_fun(ut1_net_dur_2a2b[5:8],mvttimes_smallt),
                              sse_fun(ut2_net_dur_2a2b[5:8],mvttimes_smallt),
                              sse_fun(ut3_net_dur_2a2b[5:8],mvttimes_smallt))),
                      cbind(rep('2c',12),
                            levels(ut_2a_df$data)[2:13],
                            c(sse_fun(ut1_grs_dur_2c,mvttimes_pilot),
                              sse_fun(ut2_grs_dur_2c,mvttimes_pilot),
                              sse_fun(ut3_grs_dur_2c,mvttimes_pilot),
                              sse_fun(ut1_net_dur_2c,mvttimes_pilot),
                              sse_fun(ut2_net_dur_2c,mvttimes_pilot),
                              sse_fun(ut3_net_dur_2c,mvttimes_pilot),
                              sse_fun(ut1_grs_dur_2a2b2c,mvttimes_pilot),
                              sse_fun(ut2_grs_dur_2a2b2c,mvttimes_pilot),
                              sse_fun(ut3_grs_dur_2a2b2c,mvttimes_pilot),
                              sse_fun(ut1_net_dur_2a2b2c,mvttimes_pilot),
                              sse_fun(ut2_net_dur_2a2b2c,mvttimes_pilot),
                              sse_fun(ut3_net_dur_2a2b2c,mvttimes_pilot))))
colnames(alt_ut_sse_df) <- c('exp','utmod','sse')
alt_ut_sse_df = as.data.frame(alt_ut_sse_df)
alt_ut_sse_df$sse = as.numeric(as.character(alt_ut_sse_df$sse))
# alt_ut_sse_df$sse = abs(log(as.numeric(as.character(alt_ut_sse_df$sse))))

ggplot()+
  geom_bar(data=alt_ut_sse_df,
           aes(x = exp,
               y = sse,
               fill = factor(utmod)),
           color = 'black',
           position = 'dodge',
           stat = 'identity')+
  geom_text(data=alt_ut_sse_df,
            aes(x = exp,
                y = sse,
                label = utmod,
                group = utmod),
            position = position_dodge(width = .9),
            angle = 90,
            hjust = -.1)+
  labs(x = 'Experiment', y = 'SSE - Lower Better', fill = 'Utility\nModel')+
  scale_y_continuous(trans='log10')

ggplot(data=aggregate(sse ~ utmod, alt_ut_sse_df, sum))+
  geom_bar(aes(x = utmod,
               y = sse,
               fill = factor(utmod)),
           color = 'black',
           position = 'dodge',
           stat = 'identity')+
  geom_text(aes(x = utmod,
                y = sse,
                label = utmod,
                group = utmod),
            position = position_dodge(width = .9),
            angle = 90,
            hjust = -.1)+
  labs(x = 'Utility Model', y = 'SSE Across 2a,2a,2c - Lower Better', fill = 'Utility\nModel')+
  scale_y_continuous(trans='log10')+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
# setwd(pref_plots_dir)
# if (save_plots){ggsave(filename='alt_ut_mod.pdf',plot=alt_ut_mod,height=10,width=9,useDingbats=FALSE)}
```

<!-- #### Utility Plot -->
<!-- ```{r, echo = FALSE, warning = FALSE} -->

<!-- control_times = rbind(cbind(rep('smallt',4),rep('data',4),unique(prefdata$condition)/2.2,mvttimes_smallt,rep(3,4),mvttimes_smallt_se), -->
<!--                       cbind(rep('pref',4),rep('data',4),unique(prefdata$condition)/2.2,mvttimes_pref,rep(1,4),mvttimes_pref_se), -->
<!--                       cbind(rep('pilot',4),rep('data',4),unique(prefdata$condition)/2.2,mvttimes_pilot,rep(2,4),mvttimes_pilot_se), -->

<!--                       cbind(rep('smallt',4),rep('model',4),unique(prefdata$condition)/2.2,ut2_grs_dur_2a2b[5:8],rep(3,4),rep(0,4)), -->
<!--                       cbind(rep('pref',4),rep('model',4),unique(prefdata$condition)/2.2,ut2_grs_dur_2a2b[1:4],rep(1,4),rep(0,4)), -->
<!--                       cbind(rep('pilot',4),rep('model',4),unique(prefdata$condition)/2.2,ut2_grs_dur_2a2b2c,rep(2,4),rep(0,4))) -->
<!-- colnames(control_times) = c('exp','datatype','eff_mass','movedur','expnum','movedur_se') -->

<!-- control_times = as.data.frame(control_times) -->
<!-- control_times$movedur = as.numeric(as.character(control_times$movedur)) -->
<!-- control_times$movedur_se = as.numeric(as.character(control_times$movedur_se)) -->
<!-- control_times$eff_mass = as.numeric(as.character(control_times$eff_mass)) -->

<!-- utilfits_by_exp_ut2_2alphas <- ggplot()+ -->
<!--   geom_errorbar(data=control_times, -->
<!--                 aes(x=eff_mass, -->
<!--                     ymin=movedur-movedur_se, -->
<!--                     ymax=movedur+movedur_se, -->
<!--                     color=expnum, -->
<!--                     alpha=datatype), -->
<!--                 size=3, -->
<!--                 width=.2)+ -->
<!--   geom_line(data=control_times, -->
<!--               aes(x=eff_mass, -->
<!--                   y=movedur, -->
<!--                   linetype=datatype, -->
<!--                   color=expnum, -->
<!--                   alpha = datatype), -->
<!--               size=3)+ -->
<!--   geom_line(data=data.frame(cbind(unique(control_times$eff_mass), -->
<!--                             ut2_grs_dur_2a2b2c) %>% `colnames<-`(c('eff_mass','movedur'))), -->
<!--             aes(x=eff_mass, -->
<!--                 y=movedur), -->
<!--             linetype = 'dashed', -->
<!--             color = 'black', -->
<!--             size=3)+ -->
<!--   scale_linetype_manual(values=c('solid','dashed'), -->
<!--                         labels=c('Data (Solid)','Model (Dashed)'))+ -->
<!--   scale_alpha_discrete(range=c(.5,1), -->
<!--                         labels=c('Data (Solid)','Model (Dashed)'))+ -->
<!--   labs(x='Added mass (kg)', -->
<!--        y='Movement Duration (s)', -->
<!--        title = paste('Util fits by Experiment, \U1D6FC = ', -->
<!--                      round(ut2_grs_alpha_2a2b$minimum,3),sep=''))+ -->
<!--   scale_color_manual(labels = c('Circle\n(Normal)', -->
<!--                                 'None\n(Large)', -->
<!--                                 'Arc\n(Small)', -->
<!--                                 paste('\U1D6FC = ',round(alpha_pref_comb_gross$minimum,3),sep=''), -->
<!--                                 'Gross Met Min'), -->
<!--                      values = c(gg_color_hue(3), -->
<!--                                 'black', -->
<!--                                 'red'))+ -->
<!--   scale_x_continuous(breaks = c(unique(control_times$eff_mass)))+ -->
<!--   theme_classic()+ -->
<!--   theme(text              = element_text(size=20,color='black'), -->
<!--         axis.text         = element_text(color='black'), -->
<!--         axis.ticks        = element_line(color='black'), -->
<!--         legend.text       = element_text(size=15), -->
<!--         legend.text.align = 0, -->
<!--         legend.position   = 'right', -->
<!--         plot.title        = element_text(hjust = 0.5), -->
<!--         axis.line         = element_line(color='black'))+ -->
<!--   guides(color=guide_legend(override.aes = list(size = 7), -->
<!--                             title="Target type\n(size)", -->
<!--                             keyheight=.5, -->
<!--                             default.unit='inch'), -->
<!--          linetype = guide_legend(title="Data Type", -->
<!--                            keyheight=.4, -->
<!--                            default.unit='inch'), -->
<!--          alpha = FALSE) -->

<!-- # setwd(pref_plots_dir) -->
<!-- # if (save_plots){ggsave(filename='utilfits_by_exp_ut2_2alphas.pdf',plot=utilfits_by_exp_ut2_2alphas,height=8,width=12,useDingbats=FALSE)} -->

<!-- ``` -->

### Two Alpha value

```{r, echo = FALSE, warning = FALSE}
# This is similar to before, but fitting three alpha values, one to 2a, another 2b
# and third to 2c. Should really be labeled Three alpha value.
#2a =========================================================
ut_2a_tab = cbind(c('alpha',unique(prefdata$eff_mass),'SSE'),
                  c('alpha',round(mvttimes_pref,4),'SSE'),
                  c(round(ut1_grs_alpha_2a$minimum,3),ut1_grs_dur_2a,sse_fun(ut1_grs_dur_2a,mvttimes_pref)),
                  c(round(ut2_grs_alpha_2a$minimum,3),ut2_grs_dur_2a,sse_fun(ut2_grs_dur_2a,mvttimes_pref)),
                  c(round(ut3_grs_alpha_2a$minimum,3),ut3_grs_dur_2a,sse_fun(ut3_grs_dur_2a,mvttimes_pref)),
                  c(round(ut1_net_alpha_2a$minimum,3),ut1_net_dur_2a,sse_fun(ut1_net_dur_2a,mvttimes_pref)),
                  c(round(ut2_net_alpha_2a$minimum,3),ut2_net_dur_2a,sse_fun(ut2_net_dur_2a,mvttimes_pref)),
                  c(round(ut3_net_alpha_2a$minimum,3),ut3_net_dur_2a,sse_fun(ut3_net_dur_2a,mvttimes_pref)),
                  c(round(ut1_grs_alpha_2a2b$minimum,3),ut1_grs_dur_2a2b[1:4],sse_fun(ut1_grs_dur_2a2b[1:4],mvttimes_pref)),
                  c(round(ut2_grs_alpha_2a2b$minimum,3),ut2_grs_dur_2a2b[1:4],sse_fun(ut2_grs_dur_2a2b[1:4],mvttimes_pref)),
                  c(round(ut3_grs_alpha_2a2b$minimum,3),ut3_grs_dur_2a2b[1:4],sse_fun(ut3_grs_dur_2a2b[1:4],mvttimes_pref)),
                  c(round(ut1_net_alpha_2a2b$minimum,3),ut1_net_dur_2a2b[1:4],sse_fun(ut1_net_dur_2a2b[1:4],mvttimes_pref)),
                  c(round(ut2_net_alpha_2a2b$minimum,3),ut2_net_dur_2a2b[1:4],sse_fun(ut2_net_dur_2a2b[1:4],mvttimes_pref)),
                  c(round(ut3_net_alpha_2a2b$minimum,3),ut3_net_dur_2a2b[1:4],sse_fun(ut3_net_dur_2a2b[1:4],mvttimes_pref))
)
colnames(ut_2a_tab)<-c('eff_mass','Movement Duration (s)',
                       'Utility 1 Gross Duration',
                       'Utility 2 Gross Duration',
                       'Utility 3 Gross Duration',
                       'Utility 1 Net Duration',
                       'Utility 2 Net Duration',
                       'Utility 3 Net Duration',
                       'Utility Comb 1 Gross Duration',
                       'Utility Comb 2 Gross Duration',
                       'Utility Comb 3 Gross Duration',
                       'Utility Comb 1 Net Duration',
                       'Utility Comb 2 Net Duration',
                       'Utility Comb 3 Net Duration'
)
kable(ut_2a_tab, caption = '2a - Movement duration by utility model for experiment 2a.')

masses = unique(prefdata$eff_mass)
ut_2a_df = as.data.frame(rbind(cbind(masses,rep('Exp',4),mvttimes_pref),
                               cbind(masses,rep('Ut1Grs',4),ut1_grs_dur_2a),
                               cbind(masses,rep('Ut2Grs',4),ut2_grs_dur_2a),
                               cbind(masses,rep('Ut3Grs',4),ut3_grs_dur_2a),
                               cbind(masses,rep('Ut1Net',4),ut1_net_dur_2a),
                               cbind(masses,rep('Ut2Net',4),ut2_net_dur_2a),
                               cbind(masses,rep('Ut3Net',4),ut3_net_dur_2a),
                               cbind(masses,rep('Utcomb1Grs',4),ut1_grs_dur_2a2b[1:4]),
                               cbind(masses,rep('Utcomb2Grs',4),ut2_grs_dur_2a2b[1:4]),
                               cbind(masses,rep('Utcomb3Grs',4),ut3_grs_dur_2a2b[1:4]),
                               cbind(masses,rep('Utcomb1Net',4),ut1_net_dur_2a2b[1:4]),
                               cbind(masses,rep('Utcomb2Net',4),ut2_net_dur_2a2b[1:4]),
                               cbind(masses,rep('Utcomb3Net',4),ut3_net_dur_2a2b[1:4])) %>% `colnames<-`(c('eff_mass','data','movedur')))
ut_2a_df$movedur = as.numeric(as.character(ut_2a_df$movedur))
ut_2a_df$data = as.factor(ut_2a_df$data)

alt_ut_plots = list()
alt_ut_plots[['2a_abs']] <- alt_ut_plot(ut_2a_df,ylabel = '2a Move Dur (s)',diff_or_abs = 'null')
alt_ut_plots[['2a_diff']] <- alt_ut_plot(ut_2a_df,ylabel = '2a Move Dur Diff (s)',diff_or_abs = 'diff')

#2b =========================================================
ut_2b_tab = cbind(c('alpha',unique(prefdata$eff_mass),'SSE'),
                  c('alpha',round(mvttimes_smallt,4),'SSE'),
                  c(round(ut1_grs_alpha_2b$minimum,3),ut1_grs_dur_2b,sse_fun(ut1_grs_dur_2b,mvttimes_smallt)),
                  c(round(ut2_grs_alpha_2b$minimum,3),ut2_grs_dur_2b,sse_fun(ut2_grs_dur_2b,mvttimes_smallt)),
                  c(round(ut3_grs_alpha_2b$minimum,3),ut3_grs_dur_2b,sse_fun(ut3_grs_dur_2b,mvttimes_smallt)),
                  c(round(ut1_net_alpha_2b$minimum,3),ut1_net_dur_2b,sse_fun(ut1_net_dur_2b,mvttimes_smallt)),
                  c(round(ut2_net_alpha_2b$minimum,3),ut2_net_dur_2b,sse_fun(ut2_net_dur_2b,mvttimes_smallt)),
                  c(round(ut3_net_alpha_2b$minimum,3),ut3_net_dur_2b,sse_fun(ut3_net_dur_2b,mvttimes_smallt)),
                  c(round(ut1_grs_alpha_2a2b$minimum,3),ut1_grs_dur_2a2b[5:8],sse_fun(ut1_grs_dur_2a2b[5:8],mvttimes_smallt)),
                  c(round(ut2_grs_alpha_2a2b$minimum,3),ut2_grs_dur_2a2b[5:8],sse_fun(ut2_grs_dur_2a2b[5:8],mvttimes_smallt)),
                  c(round(ut3_grs_alpha_2a2b$minimum,3),ut3_grs_dur_2a2b[5:8],sse_fun(ut3_grs_dur_2a2b[5:8],mvttimes_smallt)),
                  c(round(ut1_net_alpha_2a2b$minimum,3),ut1_net_dur_2a2b[5:8],sse_fun(ut1_net_dur_2a2b[5:8],mvttimes_smallt)),
                  c(round(ut2_net_alpha_2a2b$minimum,3),ut2_net_dur_2a2b[5:8],sse_fun(ut2_net_dur_2a2b[5:8],mvttimes_smallt)),
                  c(round(ut3_net_alpha_2a2b$minimum,3),ut3_net_dur_2a2b[5:8],sse_fun(ut3_net_dur_2a2b[5:8],mvttimes_smallt)))
colnames(ut_2b_tab)<-c('eff_mass','Movement Duration (s)',
                       'Utility 1 Gross Duration',
                       'Utility 2 Gross Duration',
                       'Utility 3 Gross Duration',
                       'Utility 1 Net Duration',
                       'Utility 2 Net Duration',
                       'Utility 3 Net Duration',
                       'Utility Comb 1 Gross Duration',
                       'Utility Comb 2 Gross Duration',
                       'Utility Comb 3 Gross Duration',
                       'Utility Comb 1 Net Duration',
                       'Utility Comb 2 Net Duration',
                       'Utility Comb 3 Net Duration')
kable(ut_2b_tab, caption = '2b - Movement duration by utility model for experiment 2b.')

masses = unique(prefdata$eff_mass)
ut_2b_df = as.data.frame(rbind(cbind(masses,rep('Exp',4),mvttimes_smallt),
                               cbind(masses,rep('Ut1Grs',4),ut1_grs_dur_2b),
                               cbind(masses,rep('Ut2Grs',4),ut2_grs_dur_2b),
                               cbind(masses,rep('Ut3Grs',4),ut3_grs_dur_2b),
                               cbind(masses,rep('Ut1Net',4),ut1_net_dur_2b),
                               cbind(masses,rep('Ut2Net',4),ut2_net_dur_2b),
                               cbind(masses,rep('Ut3Net',4),ut3_net_dur_2b),
                               cbind(masses,rep('Utcomb1Grs',4),ut1_grs_dur_2a2b[5:8]),
                               cbind(masses,rep('Utcomb2Grs',4),ut2_grs_dur_2a2b[5:8]),
                               cbind(masses,rep('Utcomb3Grs',4),ut3_grs_dur_2a2b[5:8]),
                               cbind(masses,rep('Utcomb1Net',4),ut1_net_dur_2a2b[5:8]),
                               cbind(masses,rep('Utcomb2Net',4),ut2_net_dur_2a2b[5:8]),
                               cbind(masses,rep('Utcomb3Net',4),ut3_net_dur_2a2b[5:8])) %>% `colnames<-`(c('eff_mass','data','movedur')))
ut_2b_df$movedur = as.numeric(as.character(ut_2b_df$movedur))
ut_2b_df$data = as.factor(ut_2b_df$data)

alt_ut_plots[['2b_abs']]  <- alt_ut_plot(ut_2b_df,ylabel = '2b Move Dur (s)',diff_or_abs = 'null')
alt_ut_plots[['2b_diff']] <- alt_ut_plot(ut_2b_df,ylabel = '2b Move Dur Diff (s)',diff_or_abs = 'diff')

#2c =========================================================
ut_2c_tab = cbind(c('alpha',unique(prefdata$eff_mass),'SSE'),
                  c('alpha',round(mvttimes_pilot,4),'SSE'),
                  c(round(ut1_grs_alpha_2c$minimum,3),ut1_grs_dur_2c,sse_fun(ut1_grs_dur_2b,mvttimes_pilot)),
                  c(round(ut2_grs_alpha_2c$minimum,3),ut2_grs_dur_2c,sse_fun(ut2_grs_dur_2b,mvttimes_pilot)),
                  c(round(ut3_grs_alpha_2c$minimum,3),ut3_grs_dur_2c,sse_fun(ut3_grs_dur_2b,mvttimes_pilot)),
                  c(round(ut1_net_alpha_2c$minimum,3),ut1_net_dur_2c,sse_fun(ut1_net_dur_2b,mvttimes_pilot)),
                  c(round(ut2_net_alpha_2c$minimum,3),ut2_net_dur_2c,sse_fun(ut2_net_dur_2b,mvttimes_pilot)),
                  c(round(ut3_net_alpha_2c$minimum,3),ut3_net_dur_2c,sse_fun(ut3_net_dur_2b,mvttimes_pilot)),
                  c(round(ut1_grs_alpha_2c$minimum,3),ut1_grs_dur_2c,sse_fun(ut1_grs_dur_2c,mvttimes_pilot)),
                  c(round(ut2_grs_alpha_2c$minimum,3),ut2_grs_dur_2c,sse_fun(ut2_grs_dur_2c,mvttimes_pilot)),
                  c(round(ut3_grs_alpha_2c$minimum,3),ut3_grs_dur_2c,sse_fun(ut3_grs_dur_2c,mvttimes_pilot)),
                  c(round(ut1_net_alpha_2c$minimum,3),ut1_net_dur_2c,sse_fun(ut1_net_dur_2c,mvttimes_pilot)),
                  c(round(ut2_net_alpha_2c$minimum,3),ut2_net_dur_2c,sse_fun(ut2_net_dur_2c,mvttimes_pilot)),
                  c(round(ut3_net_alpha_2c$minimum,3),ut3_net_dur_2c,sse_fun(ut3_net_dur_2c,mvttimes_pilot)))
colnames(ut_2c_tab)<-c('eff_mass','Movement Duration (s)',
                       'Utility 1 Gross Duration',
                       'Utility 2 Gross Duration',
                       'Utility 3 Gross Duration',
                       'Utility 1 Net Duration',
                       'Utility 2 Net Duration',
                       'Utility 3 Net Duration',
                       'Utility Comb 1 Gross Duration',
                       'Utility Comb 2 Gross Duration',
                       'Utility Comb 3 Gross Duration',
                       'Utility Comb 1 Net Duration',
                       'Utility Comb 2 Net Duration',
                       'Utility Comb 3 Net Duration')
kable(ut_2c_tab, caption = '2c - Movement duration by utility model for experiment 2c.')

masses = unique(prefdata$eff_mass)
ut_2c_df = as.data.frame(rbind(cbind(masses,rep('Exp',4),mvttimes_pilot),
                               cbind(masses,rep('Ut1Grs',4),ut1_grs_dur_2c),
                               cbind(masses,rep('Ut2Grs',4),ut2_grs_dur_2c),
                               cbind(masses,rep('Ut3Grs',4),ut3_grs_dur_2c),
                               cbind(masses,rep('Ut1Net',4),ut1_net_dur_2c),
                               cbind(masses,rep('Ut2Net',4),ut2_net_dur_2c),
                               cbind(masses,rep('Ut3Net',4),ut3_net_dur_2c),
                               cbind(masses,rep('Utcomb1Grs',4),ut1_grs_dur_2c),
                               cbind(masses,rep('Utcomb2Grs',4),ut2_grs_dur_2c),
                               cbind(masses,rep('Utcomb3Grs',4),ut3_grs_dur_2c),
                               cbind(masses,rep('Utcomb1Net',4),ut1_net_dur_2c),
                               cbind(masses,rep('Utcomb2Net',4),ut2_net_dur_2c),
                               cbind(masses,rep('Utcomb3Net',4),ut3_net_dur_2c)) %>% `colnames<-`(c('eff_mass','data','movedur')))
ut_2c_df$movedur = as.numeric(as.character(ut_2c_df$movedur))
ut_2c_df$data = as.factor(ut_2c_df$data)

alt_ut_plots[['2c_abs']]  <- alt_ut_plot(ut_2c_df,ylabel = '2c Move Dur (s)',diff_or_abs = 'null')
alt_ut_plots[['2c_diff']] <- alt_ut_plot(ut_2c_df,ylabel = '2c Move Dur Diff (s)',diff_or_abs = 'diff')

```

```{r SSEaltutilitymodelsTwoAlpha, echo = FALSE, warning = FALSE, fig.height=6, fig.width = 9, fig.cap = 'SSE Alternative utility models for 2a, 2b, and 2c.'}

alt_ut_sse_df = rbind(cbind(rep('2a',12),
                            levels(ut_2a_df$data)[2:13],
                            c(sse_fun(ut1_grs_dur_2a,mvttimes_pref),
                              sse_fun(ut2_grs_dur_2a,mvttimes_pref),
                              sse_fun(ut3_grs_dur_2a,mvttimes_pref),
                              sse_fun(ut1_net_dur_2a,mvttimes_pref),
                              sse_fun(ut2_net_dur_2a,mvttimes_pref),
                              sse_fun(ut3_net_dur_2a,mvttimes_pref),
                              sse_fun(ut1_grs_dur_2a2b[1:4],mvttimes_pref),
                              sse_fun(ut2_grs_dur_2a2b[1:4],mvttimes_pref),
                              sse_fun(ut3_grs_dur_2a2b[1:4],mvttimes_pref),
                              sse_fun(ut1_net_dur_2a2b[1:4],mvttimes_pref),
                              sse_fun(ut2_net_dur_2a2b[1:4],mvttimes_pref),
                              sse_fun(ut3_net_dur_2a2b[1:4],mvttimes_pref))),
                      cbind(rep('2b',12),
                            levels(ut_2b_df$data)[2:13],
                            c(sse_fun(ut1_grs_dur_2b,mvttimes_smallt),
                              sse_fun(ut2_grs_dur_2b,mvttimes_smallt),
                              sse_fun(ut3_grs_dur_2b,mvttimes_smallt),
                              sse_fun(ut1_net_dur_2b,mvttimes_smallt),
                              sse_fun(ut2_net_dur_2b,mvttimes_smallt),
                              sse_fun(ut3_net_dur_2b,mvttimes_smallt),
                              sse_fun(ut1_grs_dur_2a2b[5:8],mvttimes_smallt),
                              sse_fun(ut2_grs_dur_2a2b[5:8],mvttimes_smallt),
                              sse_fun(ut3_grs_dur_2a2b[5:8],mvttimes_smallt),
                              sse_fun(ut1_net_dur_2a2b[5:8],mvttimes_smallt),
                              sse_fun(ut2_net_dur_2a2b[5:8],mvttimes_smallt),
                              sse_fun(ut3_net_dur_2a2b[5:8],mvttimes_smallt))),
                      cbind(rep('2c',12),
                            levels(ut_2a_df$data)[2:13],
                            c(sse_fun(ut1_grs_dur_2c,mvttimes_pilot),
                              sse_fun(ut2_grs_dur_2c,mvttimes_pilot),
                              sse_fun(ut3_grs_dur_2c,mvttimes_pilot),
                              sse_fun(ut1_net_dur_2c,mvttimes_pilot),
                              sse_fun(ut2_net_dur_2c,mvttimes_pilot),
                              sse_fun(ut3_net_dur_2c,mvttimes_pilot),
                              sse_fun(ut1_grs_dur_2a2b2c,mvttimes_pilot),
                              sse_fun(ut2_grs_dur_2a2b2c,mvttimes_pilot),
                              sse_fun(ut3_grs_dur_2a2b2c,mvttimes_pilot),
                              sse_fun(ut1_net_dur_2a2b2c,mvttimes_pilot),
                              sse_fun(ut2_net_dur_2a2b2c,mvttimes_pilot),
                              sse_fun(ut3_net_dur_2a2b2c,mvttimes_pilot))))
colnames(alt_ut_sse_df) <- c('exp','utmod','sse')
alt_ut_sse_df = as.data.frame(alt_ut_sse_df)
alt_ut_sse_df$sse = as.numeric(as.character(alt_ut_sse_df$sse))
# alt_ut_sse_df$sse = abs(log(as.numeric(as.character(alt_ut_sse_df$sse))))

ggplot()+
  geom_bar(data=alt_ut_sse_df,
           aes(x = exp,
               y = sse,
               fill = factor(utmod)),
           color = 'black',
           position = 'dodge',
           stat = 'identity')+
  geom_text(data=alt_ut_sse_df,
            aes(x = exp,
                y = sse,
                label = utmod,
                group = utmod),
            position = position_dodge(width = .9),
            angle = 90,
            hjust = -.1)+
  labs(x = 'Experiment', y = 'SSE - Lower Better', fill = 'Utility\nModel')+
  scale_y_continuous(trans='log10')

ggplot(data=aggregate(sse ~ utmod, alt_ut_sse_df, sum))+
  geom_bar(aes(x = utmod,
               y = sse,
               fill = factor(utmod)),
           color = 'black',
           position = 'dodge',
           stat = 'identity')+
  geom_text(aes(x = utmod,
                y = sse,
                label = utmod,
                group = utmod),
            position = position_dodge(width = .9),
            angle = 90,
            hjust = -.1)+
  labs(x = 'Utility Model', y = 'SSE Across 2a,2a,2c - Lower Better', fill = 'Utility\nModel')+
  scale_y_continuous(trans='log10')+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
# setwd(pref_plots_dir)
# if (save_plots){ggsave(filename='alt_ut_mod.pdf',plot=alt_ut_mod,height=10,width=9,useDingbats=FALSE)}
```

## Specific alternative models

### One alpha value
This next plot/section is showing the total SSE when fitting one alpha to 2a/2b, then applied to 2c. 


```{r, echo = FALSE, warning = FALSE}
# Similar to the previous section, but only for specific models that we care about.
# This focuses on Utility (net/gross/torque), net reward, effeciency, gross cost, and net cost


ut_pred_tab_2a = cbind(c(mvttimes_pref,0),
                    c(ut1_grs_dur_2a2b[1:4], sse_fun(ut1_grs_dur_2a2b[1:4],mvttimes_pref)),
                    c(ut1_net_dur_2a2b[1:4], sse_fun(ut1_net_dur_2a2b[1:4],mvttimes_pref)),
                    c(ut1_torque_dur_2a2b[1:4], sse_fun(ut1_torque_dur_2a2b[1:4],mvttimes_pref)),
                    c(ut2_grs_dur_2a2b[1:4], sse_fun(ut2_grs_dur_2a2b[1:4],mvttimes_pref)),
                    c(ut4_grs_dur_2a2b[1:4], sse_fun(ut4_grs_dur_2a2b[1:4],mvttimes_pref)),
                    c(met_gross_dur, sse_fun(met_gross_dur,mvttimes_pref)),
                    c(met_net_dur, sse_fun(met_net_dur,mvttimes_pref)))
ut_pred_tab_2a = matrix(round(as.numeric(ut_pred_tab_2a),4),nrow=5,byrow=FALSE)
rownames(ut_pred_tab_2a) = c('2.506', '3.959', '4.894', '6.282', 'SSE')
colnames(ut_pred_tab_2a) =  c('Experimental',
                              'Utility Gross',
                              'Utility Net',
                              'Utility Torque',
                              'Net Reward',
                              'Effeciency',
                              'Gross Cost',
                              'Net Cost')

ut_pred_tab_2b = cbind(c(mvttimes_smallt,0),
                       c(ut1_grs_dur_2a2b[5:8], sse_fun(ut1_grs_dur_2a2b[5:8],mvttimes_smallt)),
                       c(ut1_net_dur_2a2b[5:8], sse_fun(ut1_net_dur_2a2b[5:8],mvttimes_smallt)),
                       c(ut1_torque_dur_2a2b[5:8], sse_fun(ut1_torque_dur_2a2b[5:8],mvttimes_smallt)),
                       c(ut2_grs_dur_2a2b[5:8], sse_fun(ut2_grs_dur_2a2b[5:8],mvttimes_smallt)),
                       c(ut4_grs_dur_2a2b[5:8], sse_fun(ut4_grs_dur_2a2b[5:8],mvttimes_smallt)),
                       c(met_gross_dur, sse_fun(met_gross_dur,mvttimes_smallt)),
                       c(met_net_dur, sse_fun(met_net_dur,mvttimes_smallt)))
ut_pred_tab_2b = matrix(round(as.numeric(ut_pred_tab_2b),4),nrow=5,byrow=FALSE)
rownames(ut_pred_tab_2b) = c('2.506', '3.959', '4.894', '6.282', 'SSE')
colnames(ut_pred_tab_2b) =  c('Experimental 2a',
                              'Utility Gross',
                              'Utility Net',
                              'Utility Torque',
                              'Net Reward',
                              'Effeciency',
                              'Gross Cost',
                              'Net Cost')

ut_pred_tab_2b = cbind(c(mvttimes_smallt,0),
                       c(ut1_grs_dur_2a2b[5:8], sse_fun(ut1_grs_dur_2a2b[5:8],mvttimes_smallt)),
                       c(ut1_net_dur_2a2b[5:8], sse_fun(ut1_net_dur_2a2b[5:8],mvttimes_smallt)),
                       c(ut1_torque_dur_2a2b[5:8], sse_fun(ut1_torque_dur_2a2b[5:8],mvttimes_smallt)),
                       c(ut2_grs_dur_2a2b[5:8], sse_fun(ut2_grs_dur_2a2b[5:8],mvttimes_smallt)),
                       c(ut4_grs_dur_2a2b[5:8], sse_fun(ut4_grs_dur_2a2b[5:8],mvttimes_smallt)),
                       c(met_gross_dur, sse_fun(met_gross_dur,mvttimes_smallt)),
                       c(met_net_dur, sse_fun(met_net_dur,mvttimes_smallt)))
ut_pred_tab_2b = matrix(round(as.numeric(ut_pred_tab_2b),4),nrow=5,byrow=FALSE)
rownames(ut_pred_tab_2b) = c('2.506', '3.959', '4.894', '6.282', 'SSE')
colnames(ut_pred_tab_2b) =  c('Experimental 2b',
                              'Utility Gross',
                              'Utility Net',
                              'Utility Torque',
                              'Net Reward',
                              'Effeciency',
                              'Gross Cost',
                              'Net Cost')


ut_pred_tab_2c = cbind(c(mvttimes_pilot,0),
                       c(ut1_grs_dur_2a2b2c, sse_fun(ut1_grs_dur_2a2b2c,mvttimes_pilot)),
                       c(ut1_net_dur_2a2b2c, sse_fun(ut1_net_dur_2a2b2c,mvttimes_pilot)),
                       c(ut1_torque_dur_2a2b2c, sse_fun(ut1_torque_dur_2a2b2c,mvttimes_pilot)),
                       c(ut2_grs_dur_2a2b2c, sse_fun(ut2_grs_dur_2a2b2c,mvttimes_pilot)),
                       c(ut4_grs_dur_2a2b2c, sse_fun(ut4_grs_dur_2a2b2c,mvttimes_pilot)),
                       c(met_gross_dur, sse_fun(met_gross_dur,mvttimes_pilot)),
                       c(met_net_dur, sse_fun(met_net_dur,mvttimes_pilot)))
ut_pred_tab_2c = matrix(round(as.numeric(ut_pred_tab_2c),4),nrow=5,byrow=FALSE)
rownames(ut_pred_tab_2c) = c('2.506', '3.959', '4.894', '6.282', 'SSE')
colnames(ut_pred_tab_2c) =  c('Experimental 2c',
                              'Utility Gross',
                              'Utility Net',
                              'Utility Torque',
                              'Net Reward',
                              'Effeciency',
                              'Gross Cost',
                              'Net Cost')

kable(ut_pred_tab_2a, caption = 'Movement duration and predictions for experiment 2a. This is fitting one alpha value to experiment 2a/2b, then applying it to 2c.')

kable(ut_pred_tab_2b, caption = 'Movement duration and predictions for experiment 2b. This is fitting one alpha value to experiment 2a/2b, then applying it to 2c.')

kable(ut_pred_tab_2c, caption = 'Movement duration and predictions for experiment 2c. This is fitting one alpha value to experiment 2a/2b, then applying it to 2c.')
```

### Plotting specific models
```{r specificutilityplots, echo = FALSE, warning = FALSE,fig.height = 4, fig.width = 12}
# Plotting.

df_specific_model_durs_2a = rbind(cbind(masses,
                                        rep(1,4),
                                        rep('Exp',4),
                                        ut_pred_tab_2a[1:4,1]),
                                  cbind(masses,
                                        rep(2,4),
                                        rep('Utility Gross',4),
                                        ut_pred_tab_2a[1:4,2]),
                                  cbind(masses,
                                        rep(3,4),
                                        rep('Utility Net',4),
                                        ut_pred_tab_2a[1:4,3]),
                                  cbind(masses,
                                        rep(4,4),
                                        rep('Utility Torque',4),
                                        ut_pred_tab_2a[1:4,4]),
                                  cbind(masses,
                                        rep(5,4),
                                        rep('Net Reward',4),
                                        ut_pred_tab_2a[1:4,5]),
                                  cbind(masses,
                                        rep(6,4),
                                        rep('Effeciency',4),
                                        ut_pred_tab_2a[1:4,6]),
                                  cbind(masses,
                                        rep(7,4),
                                        rep('Gross Cost',4),
                                        ut_pred_tab_2a[1:4,7]),
                                  cbind(masses,
                                        rep(8,4),
                                        rep('Net Cost',4),
                                        ut_pred_tab_2a[1:4,8]))


df_specific_model_durs_2b = rbind(cbind(masses,
                                        rep(1,4),
                                        rep('Exp',4),
                                        ut_pred_tab_2b[1:4,1]),
                                  cbind(masses,
                                        rep(2,4),
                                        rep('Utility Gross',4),
                                        ut_pred_tab_2b[1:4,2]),
                                  cbind(masses,
                                        rep(3,4),
                                        rep('Utility Net',4),
                                        ut_pred_tab_2b[1:4,3]),
                                  cbind(masses,
                                        rep(4,4),
                                        rep('Utility Torque',4),
                                        ut_pred_tab_2b[1:4,4]),
                                  cbind(masses,
                                        rep(5,4),
                                        rep('Net Reward',4),
                                        ut_pred_tab_2b[1:4,5]),
                                  cbind(masses,
                                        rep(6,4),
                                        rep('Effeciency',4),
                                        ut_pred_tab_2b[1:4,6]),
                                  cbind(masses,
                                        rep(7,4),
                                        rep('Gross Cost',4),
                                        ut_pred_tab_2b[1:4,7]),
                                  cbind(masses,
                                        rep(8,4),
                                        rep('Net Cost',4),
                                        ut_pred_tab_2b[1:4,8]))

df_specific_model_durs_2c = rbind(cbind(masses,
                                  rep(1,4),
                                  rep('Exp',4),
                                  ut_pred_tab_2c[1:4,1]),
                            cbind(masses,
                                  rep(2,4),
                                  rep('Utility Gross',4),
                                  ut_pred_tab_2c[1:4,2]),
                            cbind(masses,
                                  rep(3,4),
                                  rep('Utility Net',4),
                                  ut_pred_tab_2c[1:4,3]),
                            cbind(masses,
                                  rep(4,4),
                                  rep('Utility Torque',4),
                                  ut_pred_tab_2c[1:4,4]),
                            cbind(masses,
                                  rep(5,4),
                                  rep('Net Reward',4),
                                  ut_pred_tab_2c[1:4,5]),
                            cbind(masses,
                                  rep(6,4),
                                  rep('Effeciency',4),
                                  ut_pred_tab_2c[1:4,6]),
                            cbind(masses,
                                  rep(7,4),
                                  rep('Gross Cost',4),
                                  ut_pred_tab_2c[1:4,7]),
                            cbind(masses,
                                  rep(8,4),
                                  rep('Net Cost',4),
                                  ut_pred_tab_2c[1:4,8]))

df_specific_model_durs_2a = as.data.frame(df_specific_model_durs_2a)
df_specific_model_durs_2b = as.data.frame(df_specific_model_durs_2b)
df_specific_model_durs_2c = as.data.frame(df_specific_model_durs_2c)
colnames(df_specific_model_durs_2a) = c('masses','modelnum','model','movedur')
colnames(df_specific_model_durs_2b) = c('masses','modelnum','model','movedur')
colnames(df_specific_model_durs_2c) = c('masses','modelnum','model','movedur')

df_specific_model_durs_2a$movedur = as.numeric(as.character(df_specific_model_durs_2a$movedur))
df_specific_model_durs_2b$movedur = as.numeric(as.character(df_specific_model_durs_2b$movedur))
df_specific_model_durs_2c$movedur = as.numeric(as.character(df_specific_model_durs_2c$movedur))


specific_model_plots <- function(dataframe){
  g <- ggplot()+geom_point(data = dataframe,
                      aes(x = masses,
                          y = movedur,
                          color = modelnum))+
    geom_line(data = dataframe,
              aes(x = masses,
                  y = movedur,
                  color = modelnum,
                  group = modelnum))+
    labs(x = 'Effective mass (kg)',
          y = 'Movement Duration (s)',
          color = 'Model')+
  scale_color_discrete(name="Utility Model",
                       labels = unique(dataframe$model))+
    geom_point(data = filter(dataframe, modelnum == 1),
               aes(x = masses,
                   y = movedur),
               size = 3,
               color = 'red')+
    geom_line(data = filter(dataframe, modelnum == 1),
               aes(x = masses,
                   y = movedur,
                   group = modelnum),
               size = 1,
               color = 'red')+
    scale_y_continuous(limits = c(0.6,1.1))
}

plot_grid(specific_model_plots(df_specific_model_durs_2a)+theme(legend.position = 'none'),
          specific_model_plots(df_specific_model_durs_2b)+theme(legend.position = 'none'),
          specific_model_plots(df_specific_model_durs_2c)+theme(legend.position = 'none'),
          get_legend(specific_model_plots(df_specific_model_durs_2c)),
          rel_widths = c(4,4,4,3),
          nrow = 1,
          labels = c('A','B','C',''))
```

```{r, echo = FALSE, warning = FALSE}

alt_ut_sse_spec_df = rbind(cbind(rep('2a', 7),
                            c(1, 2, 3, 4, 5, 6, 7),
                            c('Utility Gross',
                              'Utility Net',
                              'Utility Torque',
                              'Net Reward',
                              'Effeciency',
                              'Gross Cost',
                              'Net Cost'),
                            c(sse_fun(ut1_grs_dur_2a2b[1:4],mvttimes_pref),
                              sse_fun(ut1_net_dur_2a2b[1:4],mvttimes_pref),
                              sse_fun(ut1_torque_dur_2a2b[1:4],mvttimes_pref),
                              sse_fun(ut2_grs_dur_2a2b[1:4],mvttimes_pref),
                              sse_fun(ut4_grs_dur_2a2b[1:4],mvttimes_pref),
                              sse_fun(met_gross_dur,mvttimes_pref),
                              sse_fun(met_net_dur,mvttimes_pref))),
                      cbind(rep('2b', 7),
                            c(1, 2, 3, 4, 5, 6, 7),
                            c('Utility Gross',
                              'Utility Net',
                              'Utility Torque',
                              'Net Reward',
                              'Effeciency',
                              'Gross Cost',
                              'Net Cost'),
                            c(sse_fun(ut1_grs_dur_2a2b[5:8],mvttimes_smallt),
                              sse_fun(ut1_net_dur_2a2b[5:8],mvttimes_smallt),
                              sse_fun(ut1_torque_dur_2a2b[5:8],mvttimes_smallt),
                              sse_fun(ut2_grs_dur_2a2b[5:8],mvttimes_smallt),
                              sse_fun(ut4_grs_dur_2a2b[5:8],mvttimes_smallt),
                              sse_fun(met_gross_dur,mvttimes_smallt),
                              sse_fun(met_net_dur,mvttimes_smallt))),
                      cbind(rep('2c', 7),
                            c(1, 2, 3, 4, 5, 6, 7),
                            c('Utility Gross',
                              'Utility Net',
                              'Utility Torque',
                              'Net Reward',
                              'Effeciency',
                              'Gross Cost',
                              'Net Cost'),
                            c(sse_fun(ut1_grs_dur_2a2b2c,mvttimes_pilot),
                              sse_fun(ut1_net_dur_2a2b2c,mvttimes_pilot),
                              sse_fun(ut1_torque_dur_2a2b2c,mvttimes_pilot),
                              sse_fun(ut2_grs_dur_2a2b2c,mvttimes_pilot),
                              sse_fun(ut4_grs_dur_2a2b2c,mvttimes_pilot),
                              sse_fun(met_gross_dur,mvttimes_pilot),
                              sse_fun(met_net_dur,mvttimes_pilot))))

# c('Ut1combgrs',
#   'Ut1combnet',
#   'Ut2combgrs',
#   'Gross Cost',
#   'Net Cost',
#   'Torque Ut')

colnames(alt_ut_sse_spec_df) <- c('exp','utnum','utmod','sse')
alt_ut_sse_spec_df = as.data.frame(alt_ut_sse_spec_df)
alt_ut_sse_spec_df$sse = as.numeric(as.character(alt_ut_sse_spec_df$sse))

kable(alt_ut_sse_spec_df, caption = 'SSE of Specific utility models. Fitted 1 alpha.')
kable(aggregate(sse ~ utmod, alt_ut_sse_spec_df, sum), caption = 'SSE of Specific utility models. Fitted 1 alpha.')

alt_ut_plot_allexp <- ggplot(data=alt_ut_sse_spec_df)+
  geom_bar(aes(x = exp,
               y = sse,
               fill = factor(utnum)),
           color = 'black',
           position = 'dodge',
           stat = 'identity')+
  geom_text(aes(x = exp,
                y = sse,
                label = utmod,
                group = utnum),
            position = position_dodge(width = .9),
            angle = 90,
            hjust = -.1)+
  labs(x = 'Utility Model', y = 'SSE Across 2a,2a,2c - Lower Better')+
  scale_y_continuous(trans='log10')+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  scale_fill_discrete(name="Utility Model",
                             labels = c('Utility Gross',
                              'Utility Net',
                              'Utility Torque',
                              'Net Reward',
                              'Efficiency',
                              'Gross Cost',
                              'Net Cost'))

alt_ut_plot_agg <- ggplot(data=aggregate(sse ~ utnum + utmod, alt_ut_sse_spec_df, sum))+
  geom_bar(aes(x = factor(utnum),
               y = sse,
               fill = factor(utnum)),
           color = 'black',
           position = 'dodge',
           stat = 'identity')+
  geom_text(aes(x = factor(utnum),
                y = sse,
                label = utmod,
                group = utnum),
            position = position_dodge(width = .9),
            angle = 90,
            hjust = -.1)+
  labs(x = 'Utility Model', y = 'SSE Across 2a,2a,2c - Lower Better')+
  scale_y_continuous(trans='log10')+
  scale_x_discrete(#values = c(1,2,3,4,5,6),
                   labels = c('Utility Gross',
                              'Utility Net',
                              'Utility Torque',
                              'Net Reward',
                              'Efficiency',
                              'Gross Cost',
                              'Net Cost'))+
  theme(axis.text.x = element_text(angle = 30, hjust = 1))+
  scale_fill_discrete(name="Utility Model",
                             labels = c('Utility Gross',
                              'Utility Net',
                              'Utility Torque',
                              'Net Reward',
                              'Efficiency',
                              'Gross Cost',
                              'Net Cost'))

# alt_ut_plot_agg

```

```{r altutilitymodelSSEgroupplot, echo = FALSE, warning = FALSE,fig.height = 10, fig.width = 10}
# Grouping these plots for absolute metrics.
alt_ut_SSE_group_plot <- plot_grid(alt_ut_plot_allexp,
                                  alt_ut_plot_agg,
                                  align = 'vh',
                                  nrow = 2,
                                  labels = 'AUTO')

alt_ut_SSE_group_plot

setwd(pref_plots_dir)
if (save_plots){ggsave('alt_ut_SSE_group_plot.pdf',plot=alt_ut_SSE_group_plot, width = 8, height = 8, useDingbats = FALSE)}
```

## SSE NORMALIZED

```{r, echo = FALSE, warning = FALSE}
# Do the same things as the previous section, just with normalized values.
# Normalized to 0 lbs added.

mvttimes_pref_norm = mvttimes_pref/mvttimes_pref[1]
mvttimes_smallt_norm = mvttimes_smallt/mvttimes_smallt[1]
mvttimes_pilot_norm = mvttimes_pilot/mvttimes_pilot[1]

alt_ut_sse_spec_df_norm = rbind(cbind(rep('2a',7),
                                 c(1, 2, 4, 6, 7, 3, 5),
                                 c('Utility Gross',
                                   'Utility Net',
                                   'Net Reward',
                                   'Gross Cost',
                                   'Net Cost',
                                   'Utility Torque',
                                   'Efficiency'),
                                 c(sse_fun(ut1_grs_dur_2a2b[1:4]/ut1_grs_dur_2a2b[1],mvttimes_pref_norm),
                                   sse_fun(ut1_net_dur_2a2b[1:4]/ut1_net_dur_2a2b[1],mvttimes_pref_norm),
                                   sse_fun(ut2_grs_dur_2a2b[1:4]/ut2_grs_dur_2a2b[1],mvttimes_pref_norm),
                                   sse_fun(met_gross_dur/met_gross_dur[1],mvttimes_pref_norm),
                                   sse_fun(met_net_dur/met_net_dur[1],mvttimes_pref_norm),
                                   sse_fun(ut1_torque_dur_2a2b[1:4]/ut1_torque_dur_2a2b[1],mvttimes_pref_norm),
                                   sse_fun(ut3_grs_dur_2a2b[1:4]/ut3_grs_dur_2a2b[1],mvttimes_pref_norm))),
                           cbind(rep('2b',7),
                                 c(1, 2, 4, 6, 7, 3, 5),
                                 c('Utility Gross',
                                   'Utility Net',
                                   'Net Reward',
                                   'Gross Cost',
                                   'Net Cost',
                                   'Utility Torque',
                                   'Efficiency'),
                                 c(sse_fun(ut1_grs_dur_2a2b[5:8]/ut1_grs_dur_2a2b[5],mvttimes_smallt_norm),
                                   sse_fun(ut1_net_dur_2a2b[5:8]/ut1_net_dur_2a2b[5],mvttimes_smallt_norm),
                                   sse_fun(ut2_grs_dur_2a2b[5:8]/ut2_grs_dur_2a2b[5],mvttimes_smallt_norm),
                                   sse_fun(met_gross_dur/met_gross_dur[1],mvttimes_smallt_norm),
                                   sse_fun(met_net_dur/met_net_dur[1],mvttimes_smallt_norm),
                                   sse_fun(ut1_torque_dur_2a2b[5:8]/ut1_torque_dur_2a2b[5],mvttimes_smallt_norm),
                                   sse_fun(ut3_grs_dur_2a2b[5:8]/ut3_grs_dur_2a2b[5],mvttimes_pref_norm))),
                           cbind(rep('2c',7),
                                 c(1, 2, 4, 6, 7, 3, 5),
                                 c('Utility Gross',
                                   'Utility Net',
                                   'Net Reward',
                                   'Gross Cost',
                                   'Net Cost',
                                   'Utility Torque',
                                   'Efficiency'),
                                 c(sse_fun(ut1_grs_dur_2a2b2c/ut1_grs_dur_2a2b2c[1],mvttimes_pilot_norm),
                                   sse_fun(ut1_net_dur_2a2b2c/ut1_net_dur_2a2b2c[1],mvttimes_pilot_norm),
                                   sse_fun(ut2_grs_dur_2a2b2c/ut2_grs_dur_2a2b2c[1],mvttimes_pilot_norm),
                                   sse_fun(met_gross_dur/met_gross_dur[1],mvttimes_pilot_norm),
                                   sse_fun(met_net_dur/met_net_dur[1],mvttimes_pilot_norm),
                                   sse_fun(ut1_torque_dur_2a2b2c/ut1_torque_dur_2a2b2c[1],mvttimes_pilot_norm),
                                   sse_fun(ut4_grs_dur_2a2b2c/ut2_grs_dur_2a2b2c[1],mvttimes_pilot_norm))))


colnames(alt_ut_sse_spec_df_norm) <- c('exp','utnum','utmod','sse')
alt_ut_sse_spec_df_norm = as.data.frame(alt_ut_sse_spec_df_norm)
alt_ut_sse_spec_df_norm$sse = as.numeric(as.character(alt_ut_sse_spec_df_norm$sse))

kable(alt_ut_sse_spec_df_norm, caption = 'SSE NORM of Specific utility models. Fitted 1 alpha.')
kable(aggregate(sse ~ utmod, alt_ut_sse_spec_df_norm, sum), caption = 'SSE NORM of Specific utility models. Fitted 1 alpha.')

alt_ut_plot_allexp_norm <- ggplot(data=alt_ut_sse_spec_df_norm)+
  geom_bar(aes(x = exp,
               y = sse,
               fill = factor(utnum)),
           color = 'black',
           position = 'dodge',
           stat = 'identity')+
  geom_text(aes(x = exp,
                y = sse,
                label = utmod,
                group = utnum),
            position = position_dodge(width = .9),
            angle = 90,
            hjust = -.1)+
  labs(x = 'Utility Model', y = 'SSE NORM Across 2a,2a,2c', fill = 'Utility\nModel')+
  scale_y_continuous(trans='log10')+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  scale_fill_discrete(name="Utility Model",
                             labels = c('Utility Gross',
                              'Utility Net',
                              'Utility Torque',
                              'Net Reward',
                              'Gross Cost',
                              'Net Cost'))
# alt_ut_plot_allexp_norm

alt_ut_plot_agg_norm <- ggplot(data=aggregate(sse ~ utnum + utmod, alt_ut_sse_spec_df_norm, sum))+
  geom_bar(aes(x = factor(utnum),
               y = sse,
               fill = factor(utnum)),
           color = 'black',
           position = 'dodge',
           stat = 'identity')+
  geom_text(aes(x = factor(utnum),
                y = sse,
                label = utmod,
                group = utnum),
            position = position_dodge(width = .9),
            angle = 90,
            hjust = -.1)+
  labs(x = 'Utility Model', y = 'SSE NORM Across 2a,2a,2c')+
  scale_y_continuous(trans='log10')+
  scale_x_discrete(#values = c(1,2,3,4,5,6),
                   labels = c('Utility Gross',
                              'Utility Net',
                              'Utility Torque',
                              'Net Reward',
                              'Gross Cost',
                              'Net Cost'))+
  theme(axis.text.x = element_text(angle = 30, hjust = 1))+
  scale_fill_discrete(name="Utility Model",
                      labels = c('Utility Gross',
                                 'Utility Net',
                                 'Utility Torque',
                                 'Net Reward',
                                 'Gross Cost',
                                 'Net Cost'))
# alt_ut_plot_agg_norm

```

```{r altutilitymodelSSENormgroupplot, echo = FALSE, warning = FALSE,fig.height = 10, fig.width = 6}

alt_ut_SSE_norm_group_plot <- plot_grid(alt_ut_plot_allexp_norm,
                                  alt_ut_plot_agg_norm,
                                  align = 'vh',
                                  nrow = 2,
                                  labels = 'AUTO')

alt_ut_SSE_norm_group_plot

setwd(pref_plots_dir)
if (save_plots){ggsave('alt_ut_SSE_norm_group_plot.pdf',plot=alt_ut_SSE_norm_group_plot, width = 8, height = 8, useDingbats = FALSE)}
```

```{r AltUtPlotGrouped, echo = FALSE, warning = FALSE,fig.height = 10, fig.width = 10}
# This groups all the SSE plots for use in the supplemental section of the paper.
alt_ut_SSE_absnorm_group_plot <- plot_grid(plot_grid(alt_ut_plot_allexp+theme(legend.position = 'none'),
                                                  alt_ut_plot_allexp_norm+theme(legend.position = 'none'),
                                                  alt_ut_plot_agg+theme(legend.position = 'none'),
                                                  alt_ut_plot_agg_norm+theme(legend.position = 'none'),
                                                  align = 'vh',
                                                  nrow = 2,
                                                  labels = 'AUTO'),
                                        get_legend(alt_ut_plot_allexp),
                                        ncol = 2,
                                        rel_widths = c(8,1))

alt_ut_SSE_absnorm_group_plot

setwd(pref_plots_dir)
if (save_plots){ggsave('alt_ut_SSE_absnorm_group_plot.pdf',plot=alt_ut_SSE_absnorm_group_plot, width = 10, height = 8, useDingbats = FALSE)}
```

# Making the utility plot
```{r, echo = FALSE, warning = FALSE, message = FALSE}
# This chunk creates 3 plots for the utility predictions for
# Net reward rate, net reward, and torque as effort.
# It combines only net reward and torque to save for the paper.
ut_plot_text_size = 8
# Net Reward Rate ==========
mvttimes_pref_se_prop   = sse_prop(prefdata,'movedur')[1:4]
mvttimes_smallt_se_prop = sse_prop(smalltdata,'movedur')[1:4]

mvttimes_pref_se   = aggregate(movedur ~ condition, aggregate(movedur ~ condition + subj, prefdata,mean),sd)$movedur/sqrt(max(prefdata$subj))
mvttimes_smallt_se = aggregate(movedur ~ condition, aggregate(movedur ~ condition + subj, smalltdata,mean),sd)$movedur/sqrt(max(smalltdata$subj))

control_times = rbind(cbind(rep('smallt',4),rep('data',4),
                            round(unique(prefdata$condition)/2.2,3),mvttimes_smallt,rep(3,4),mvttimes_smallt_se),
                      cbind(rep('pref',4),rep('data',4),
                            round(unique(prefdata$condition)/2.2,3),mvttimes_pref,rep(1,4),mvttimes_pref_se),
                      cbind(rep('smallt',4),rep('model',4),
                            round(unique(prefdata$condition)/2.2,3),util_dur_pref_alpha_comb_gross[5:8],rep(3,4),rep(0,4)),
                      cbind(rep('pref',4),rep('model',4),
                            round(unique(prefdata$condition)/2.2,3),util_dur_pref_alpha_comb_gross[1:4],rep(1,4),rep(0,4)))
colnames(control_times) = c('exp','datatype','eff_mass','movedur','expnum','movedur_se')

control_times = as.data.frame(control_times)
control_times$movedur = as.numeric(as.character(control_times$movedur))
control_times$movedur_se = as.numeric(as.character(control_times$movedur_se))
control_times$eff_mass = as.numeric(as.character(control_times$eff_mass))

net_rwd_rate <- ggplot()+
  geom_errorbar(data=filter(control_times, datatype == 'data'),
                aes(x=eff_mass,
                    ymin=movedur-movedur_se,
                    ymax=movedur+movedur_se,
                    color=expnum),
                # position = position_dodge(width = 0.5),
                size=2,
                width=0)+
  geom_line(data=filter(control_times, datatype == 'data'),
              aes(x=eff_mass,
                  y=movedur,
                  linetype='solid',
                  color=expnum),
              # position = position_dodge(width = 0.5),
              size=2)+
  geom_line(data=filter(control_times, datatype == 'model'),
              aes(x=eff_mass,
                  y=movedur,
                  linetype='dashed',
                  color=expnum),
              # position = position_dodge(width = 0.5),
              size=2)+
  geom_line(data=data.frame(cbind(unique(control_times$eff_mass),
                                  met_gross_dur) %>% `colnames<-`(c('eff_mass','movedur'))),
            aes(x=eff_mass,
                y=movedur),
            linetype = 'dashed',
            color    = 'black',
            size=2)+
  scale_linetype_manual(values=c('dashed','solid'),
                        labels=c('Model (Dashed)','Data (Solid)'))+
  # scale_alpha_discrete(range=c(1,1),
  #                       labels=c('Data (Solid)','Model (Dashed)'))+
  labs(x='Added mass (kg)',
       y='Movement Duration (s)',
       title = paste('Net Reward Rate \n2a,2b \U1D6FC = ',
                     round(alpha_pref_comb_gross$minimum,3)
                     ,sep=''))+
  scale_color_manual(labels = c('Circle\n(Normal)',
                                'Arc\n(Small)',
                                paste('\U1D6FC = ',round(alpha_pref_comb_gross$minimum,3),sep=''),
                                'Gross Met Min'),
                     values = c(c('#535263','#919093'),
                                'black',
                                'black'))+
                     # values = c(c(gg_color_hue(3)[1],gg_color_hue(3)[3]),
                     #            'black',
                     #            'black'))+
    # scale_color_manual(values = c('#535263','#919093','#bcbcbc'))+
  scale_x_continuous(breaks = c(unique(control_times$eff_mass)))+
  theme_classic()+
  theme(text              = element_text(size=ut_plot_text_size+2,color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        legend.text       = element_text(size=ut_plot_text_size),
        legend.text.align = 0,
        legend.position   = 'right',
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))+
  guides(color=guide_legend(override.aes = list(size = 4),
                            title="Target type\n(size)",
                            keyheight=.5,
                            default.unit='inch'),
         linetype = guide_legend(title="Data Type",
                           keyheight=.4,
                           default.unit='inch'),
         alpha = FALSE)

# Net Reward ==========
control_times2 = rbind(cbind(rep('smallt',4),rep('data',4),
                            round(unique(prefdata$condition)/2.2,3),mvttimes_smallt,rep(3,4),mvttimes_smallt_se),
                      cbind(rep('pref',4),rep('data',4),
                            round(unique(prefdata$condition)/2.2,3),mvttimes_pref,rep(1,4),mvttimes_pref_se),
                      cbind(rep('smallt',4),rep('model',4),
                            round(unique(prefdata$condition)/2.2,3),ut2_grs_dur_2a2b[5:8],rep(3,4),rep(0,4)),
                      cbind(rep('pref',4),rep('model',4),
                            round(unique(prefdata$condition)/2.2,3),ut2_grs_dur_2a2b[1:4],rep(1,4),rep(0,4)))
colnames(control_times2) = c('exp','datatype','eff_mass','movedur','expnum','movedur_se')

control_times2 = as.data.frame(control_times2)
control_times2$movedur = as.numeric(as.character(control_times2$movedur))
control_times2$movedur_se = as.numeric(as.character(control_times2$movedur_se))
control_times2$eff_mass = as.numeric(as.character(control_times2$eff_mass))

net_rwd <- ggplot()+
  geom_errorbar(data=filter(control_times2, datatype == 'data'),
                aes(x=eff_mass,
                    ymin=movedur-movedur_se,
                    ymax=movedur+movedur_se,
                    color=expnum),
                # position = position_dodge(width = 0.5),
                size=2,
                width=0)+
  geom_line(data=filter(control_times2, datatype == 'data'),
              aes(x=eff_mass,
                  y=movedur,
                  linetype='solid',
                  color=expnum),
              # position = position_dodge(width = 0.5),
              size=2)+
  geom_line(data=filter(control_times2, datatype == 'model'),
              aes(x=eff_mass,
                  y=movedur,
                  linetype='dashed',
                  color=expnum),
              # position = position_dodge(width = 0.5),
              size=2)+
  geom_line(data=data.frame(cbind(unique(control_times2$eff_mass),
                                  met_gross_dur) %>% `colnames<-`(c('eff_mass','movedur'))),
            aes(x=eff_mass,
                y=movedur),
            linetype = 'dashed',
            color    = 'black',
            size=2)+
  scale_linetype_manual(values=c('dashed','solid'),
                        labels=c('Model (Dashed)','Data (Solid)'))+
  # scale_alpha_discrete(range=c(.5,1),
  #                       labels=c('Data (Solid)','Model (Dashed)'))+
  labs(x='Added mass (kg)',
       y='Movement Duration (s)',
       title = paste('Net Reward\n2a,2b \U1D6FC = ',
                     round(ut2_grs_alpha_2a2b$minimum,3),
                     '\nBlack = metgross min',sep=''))+
  scale_color_manual(labels = c('Circle\n(Normal)',
                                'Arc\n(Small)',
                                paste('\U1D6FC = ',round(ut2_grs_alpha_2a2b$minimum,3),sep=''),
                                'Gross Met Min'),
                     values = c(c('#535263','#919093'),
                                'black',
                                'black'))+
                     # values = c(c(gg_color_hue(3)[1],gg_color_hue(3)[3]),
                     #            'black',
                     #            'black'))+
    # scale_color_manual(values = c('#535263','#919093','#bcbcbc'))+
  scale_x_continuous(breaks = c(unique(control_times2$eff_mass)))+
  theme_classic()+
  theme(text              = element_text(size=ut_plot_text_size+2,color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        legend.text       = element_text(size=ut_plot_text_size),
        legend.text.align = 0,
        legend.position   = 'right',
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))+
  guides(color=guide_legend(override.aes = list(size = 4),
                            title="Target type\n(size)",
                            keyheight=.5,
                            default.unit='inch'),
         linetype = guide_legend(title="Data Type",
                           keyheight=.4,
                           default.unit='inch'),
         alpha = FALSE)

# Torque as Effort ==========
control_times_torque = rbind(cbind(rep('smallt',4),rep('data',4),
                            round(unique(prefdata$condition)/2.2,3),mvttimes_smallt,rep(3,4),mvttimes_smallt_se),
                      cbind(rep('pref',4),rep('data',4),
                            round(unique(prefdata$condition)/2.2,3),mvttimes_pref,rep(1,4),mvttimes_pref_se),
                      cbind(rep('smallt',4),rep('model',4),
                            round(unique(prefdata$condition)/2.2,3),ut1_torque_dur_2a2b[5:8],rep(3,4),rep(0,4)),
                      cbind(rep('pref',4),rep('model',4),
                            round(unique(prefdata$condition)/2.2,3),ut1_torque_dur_2a2b[1:4],rep(1,4),rep(0,4)))
colnames(control_times_torque) = c('exp','datatype','eff_mass','movedur','expnum','movedur_se')

control_times_torque = as.data.frame(control_times_torque)
control_times_torque$movedur = as.numeric(as.character(control_times_torque$movedur))
control_times_torque$movedur_se = as.numeric(as.character(control_times_torque$movedur_se))
control_times_torque$eff_mass = as.numeric(as.character(control_times_torque$eff_mass))

ut_torque <- ggplot()+
  geom_errorbar(data=filter(control_times_torque, datatype == 'data'),
                aes(x=eff_mass,
                    ymin=movedur-movedur_se,
                    ymax=movedur+movedur_se,
                    color=expnum),
                # position = position_dodge(width = 0.5),
                size=2,
                width=0)+
  geom_line(data=filter(control_times_torque, datatype == 'data'),
              aes(x=eff_mass,
                  y=movedur,
                  linetype='solid',
                  color=expnum),
              # position = position_dodge(width = 0.5),
              size=2)+
  geom_line(data=filter(control_times_torque, datatype == 'model'),
              aes(x=eff_mass,
                  y=movedur,
                  linetype='dashed',
                  color=expnum),
              # position = position_dodge(width = 0.5),
              size=2)+
  geom_line(data=data.frame(cbind(unique(control_times_torque$eff_mass),
                                  met_gross_dur) %>% `colnames<-`(c('eff_mass','movedur'))),
            aes(x=eff_mass,
                y=movedur),
            linetype = 'dashed',
            color    = 'black',
            size=2)+
  scale_linetype_manual(values=c('dashed','solid'),
                        labels=c('Model (Dashed)','Data (Solid)'))+
  labs(x='Added mass (kg)',
       y='Movement Duration (s)',
       title = paste('Torque as effort\n2a,2b \U1D6FC = ',
                     round(ut1_torque_alpha_2a2b$minimum,3),
                     sep=''))+
  scale_color_manual(labels = c('Circle\n(Normal)',
                                'Arc\n(Small)',
                                paste('\U1D6FC = ',round(ut1_torque_alpha_2a2b$minimum,3),sep=''),
                                'Gross Met Min'),
                     values = c(c('#535263','#919093'),
                                'black',
                                'black'))+
                     # values = c(c(gg_color_hue(3)[1],gg_color_hue(3)[3]),
                     #            'black',
                     #            'black'))+
    # scale_color_manual(values = c('#535263','#919093','#bcbcbc'))+
  scale_x_continuous(breaks = c(unique(control_times_torque$eff_mass)))+
  theme_classic()+
  theme(text              = element_text(size=ut_plot_text_size+2,color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        legend.text       = element_text(size=ut_plot_text_size),
        legend.text.align = 0,
        legend.position   = 'right',
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))+
  guides(color=guide_legend(override.aes = list(size = 4),
                            title="Target type\n(size)",
                            keyheight=.5,
                            default.unit='inch'),
         linetype = guide_legend(title="Data Type",
                           keyheight=.4,
                           default.unit='inch'),
         alpha = FALSE)



setwd(pref_plots_dir)
# if (save_plots){ggsave(filename='utilfits_by_exp_2alphas.pdf',plot=utilfits_by_exp_2alphas,height=8,width=12,useDingbats=FALSE)}

# Grouping for plot ===============
ut_pred_plot = plot_grid(net_rwd_rate+theme(legend.position = 'none')+theme(text = element_text(size=7.76)), 
                         ut_torque+theme(legend.position = 'none')+theme(text = element_text(size=7.76)), 
                         get_legend(net_rwd_rate),
                         nrow = 1,
                         rel_widths = c(1,1,.3),
                         labels = c('A','B'))



theme_set(theme_cowplot(font_size=7.76))
setwd(pref_plots_dir)
if (save_plots){ggsave(filename='ut_pred_plot.pdf',plot=ut_pred_plot,
                       height=4,
                       width=6,
                       useDingbats=FALSE)}
ut_pred_plot
```

# Cross-Validation Tables

```{r, echo = FALSE, warning = FALSE}
# These next chunks are cross validation. The secion headers should explain.
# These are where we fit one alpha value to an experiment, then see how they predict
# the other experiments. 
# So fit alpha to 2a, then predict 2b/2c.

sse_fun2 <- function(dur1,dur2){
  sse = sum((dur1-dur2)^2)
  return(sse)
}

AIC_fun <- function(SSE,n_params){
  aic_score = 4*log(SSE)-4*log(4)+2*(n_params+1)
  bic_score = 4*log(SSE)-4*log(4)+log(4)*(n_params+1)
  return(round(c(aic_score,bic_score),4))
}

cross_val_tab <- function(exp_dur, exp){
  ut1_grs_alpha <- eval(parse(text = paste('ut1_grs_alpha_',exp,sep='')))
  ut1_grs_dur <- eval(parse(text = paste('ut1_grs_dur_',exp,sep='')))

  ut1_net_alpha <- eval(parse(text = paste('ut1_net_alpha_',exp,sep='')))
  ut1_net_dur <- eval(parse(text = paste('ut1_net_dur_',exp,sep='')))
  
  alpha_torque <- eval(parse(text = paste('alpha_torque_',exp,sep='')))
  torque_dur <- eval(parse(text = paste('torque_dur_',exp,sep='')))
  
  ut2_grs_alpha <- eval(parse(text = paste('ut2_grs_alpha_',exp,sep='')))
  ut2_grs_dur <- eval(parse(text = paste('ut2_grs_dur_',exp,sep='')))
  
  ut4_grs_alpha <- eval(parse(text = paste('ut4_grs_alpha_',exp,sep='')))
  ut4_grs_dur <- eval(parse(text = paste('ut4_grs_dur_',exp,sep='')))
  
  ut_pred_tab = cbind(c('alpha',
                      unique(prefdata$eff_mass),
                      'SSE',
                      'AIC',
                      'BIC'),
                    c('',
                      round(exp_dur,4),
                      '',
                      '',
                      ''),
                    c(round(ut1_grs_alpha$minimum,3), # Utility Gross
                      ut1_grs_dur,
                      sse_fun(ut1_grs_dur,exp_dur),
                      AIC_fun(sse_fun2(ut1_grs_dur,exp_dur),1)[1],
                      AIC_fun(sse_fun2(ut1_grs_dur,exp_dur),1)[2]),
                    c(round(ut1_net_alpha$minimum,3), # Utility Net
                      ut1_net_dur,
                      sse_fun(ut1_net_dur,exp_dur),
                      AIC_fun(sse_fun2(ut1_net_dur,exp_dur),1)[1],
                      AIC_fun(sse_fun2(ut1_net_dur,exp_dur),1)[2]),
                    c(round(alpha_torque,3), # Utility Torque
                      torque_dur,
                      sse_fun(torque_dur,exp_dur),
                      AIC_fun(sse_fun2(torque_dur,exp_dur),1)[1],
                      AIC_fun(sse_fun2(torque_dur,exp_dur),1)[2]),
                    c('', # Net Rwd
                      ut2_grs_dur,
                      sse_fun(ut2_grs_dur,exp_dur),
                      AIC_fun(sse_fun2(ut2_grs_dur,exp_dur),1)[1],
                      AIC_fun(sse_fun2(ut2_grs_dur,exp_dur),1)[2]),
                    c('', # Efficiency
                      ut4_grs_dur,
                      sse_fun(ut4_grs_dur,exp_dur),
                      AIC_fun(sse_fun2(ut4_grs_dur,exp_dur),1)[1],
                      AIC_fun(sse_fun2(ut4_grs_dur,exp_dur),1)[2]),
                    c('', # Gross Cost
                      round(met_gross_dur,4),
                      sse_fun(met_gross_dur,exp_dur),
                      AIC_fun(sse_fun2(met_gross_dur,exp_dur),1)[1],
                      AIC_fun(sse_fun2(met_gross_dur,exp_dur),1)[2]),
                    c('', # Net Cost
                      round(met_net_dur,4),
                      sse_fun(met_net_dur,exp_dur),
                      AIC_fun(sse_fun2(met_net_dur,exp_dur),1)[1],
                      AIC_fun(sse_fun2(met_net_dur,exp_dur),1)[2]))
  colnames(ut_pred_tab) = c('','Experimental Mvttimes','Utility Grs','Utility Net','Utility Torque','Net Rwd Grs','Efficiency','Gross Cost','Net Cost')
  
  return(ut_pred_tab)
}


```

## Fit to 2a, predicting 2a, 2b, 2c

```{r, echo = FALSE, warning = FALSE}

kable(cross_val_tab(mvttimes_pref,'2a'), caption = 'Fitted one alpha to 2a, predicting 2a.')

```

```{r, echo = FALSE, warning = FALSE}

kable(cross_val_tab(mvttimes_smallt,'2a'), caption = 'Fitted one alpha to 2a, predicting 2b.')

```

```{r, echo = FALSE, warning = FALSE}

kable(cross_val_tab(mvttimes_pilot,'2a'), caption = 'Fitted one alpha to 2a, predicting 2c.')

```

## Fit to 2b, predicting 2a, 2b, 2c

```{r, echo = FALSE, warning = FALSE}

kable(cross_val_tab(mvttimes_pref,'2b'), caption = 'Fitted one alpha to 2b, predicting 2a.')

```

```{r, echo = FALSE, warning = FALSE}

kable(cross_val_tab(mvttimes_smallt,'2b'), caption = 'Fitted one alpha to 2b, predicting 2b.')

```

```{r, echo = FALSE, warning = FALSE}

kable(cross_val_tab(mvttimes_pilot,'2b'), caption = 'Fitted one alpha to 2b, predicting 2c.')

```

## Fit to 2c, predicting 2a, 2b, 2c

```{r, echo = FALSE, warning = FALSE}

kable(cross_val_tab(mvttimes_pref,'2c'), caption = 'Fitted one alpha to 2c, predicting 2a.')

```

```{r, echo = FALSE, warning = FALSE}

kable(cross_val_tab(mvttimes_smallt,'2c'), caption = 'Fitted one alpha to 2c, predicting 2b.')

```

```{r, echo = FALSE, warning = FALSE}

kable(cross_val_tab(mvttimes_pilot,'2c'), caption = 'Fitted one alpha to 2c, predicting 2c.')

```


# 2a Durations

## Model Plotting Function

```{r, echo = FALSE, warning = FALSE}
# These sections are deprecated. 
# Shows the predicted SSE for many models, AIC, and BIC scores.
# Not commenting this because it's generally not used.

# model_labs = c(TeX('2a Duration'), #1
#                TeX('2b Duration'), #2
#                TeX('3c Duration'), #3
#                TeX('4'),
#                TeX('5'),
#                TeX('6'),
#                TeX('2a Util'), #7
#                TeX('8'),
#                TeX('9'),
#                TeX('10'),
#                TeX('$Torque^2$'), #11
#                TeX('12'),
#                TeX('2b Util'), #13
#                TeX('2c Util'), #14
#                TeX('15'),
#                TeX('Gross Cost'), #16
#                TeX('Net Cost')) #17
# models_to_plot = c( 1, 2, 3, 7, 11, 13, 14, 17, 16)

model_plotting <- function(variable,label,temp_durs,errbar,cs,normalized){
  if (length(unique(temp_durs$model))==10){
    shapes = c(1:10)
  } else {
    shapes = c(16, 15, 17, 1, 0, 2, 5, 6, 11)
    # shapes = c(5,6,11,16,1,15,17,0,2)
  }
  if (normalized == 0){
    
    if (cs=='shape'){
      string = paste('g <- ggplot()+
        # geom_line(data=filter(temp_durs,model!=\'Pref\'),
        #                               aes(x=eff_mass,
        #                               y = ',variable,',
        #                               group = model),
        #                           color= \'grey\',
        #                           size=1)+
        # geom_line(data=filter(temp_durs,model==\'Pref\'),
        #                               aes(x=eff_mass,
        #                               y=',variable,'),
        #                           color= \'black\',
        #                           size=1)+
        geom_line(data=temp_durs,
                  aes(x=eff_mass,
                      y=',variable,',
                      color=factor(modelnum),
                      group=factor(modelnum)),
                  size=1)+
        geom_errorbar(data=errbar,aes(x=eff_mass,
                                      ymin=',variable,'-sd,
                                      ymax=',variable,'+sd),
                      color = \'black\',
                      size=1,
                      width = 0)+
        geom_point(data=temp_durs,
                   aes(x=eff_mass,
                       y=',variable,',
                       group=factor(modelnum),
                       shape=factor(modelnum)),
                   size=3)+
        guides(shape = guide_legend(override.aes = list(size = 5),
                                    title="Model",
                                    keyheight=.5,
                                    default.unit=\'inch\'))+
        scale_shape_manual(values = shapes,
                           labels = parse(text = model_labs[models_to_plot]))+
        # scale_linetype_manual(values = c(\'dashed\',
        #                                  \'dashed\',
        #                                  \'dashed\',
        #                                  \'solid\',
        #                                  \'dashed\',
        #                                  \'solid\',
        #                                  \'solid\',
        #                                  \'dashed\',
        #                                  \'dashed\'),
        #                       guide = \'none\')+
        scale_color_manual(values = c(\'black\',
                                      \'black\',
                                      \'black\',
                                      \'blue\',
                                      \'blue\',
                                      \'blue\',
                                      \'blue\',
                                      \'blue\',
                                      \'blue\'),
                              guide = \'none\')+
        labs(x=\'Effective Mass (kg)\',y=\'',label,'\')+
        scale_x_continuous(breaks=c(sort(unique(prefpilot$eff_mass))))+
        theme(legend.text=element_text(size=15),
              text = element_text(size=20),
              axis.text.x = element_text(size = 15),
              axis.text.y = element_text(size = 15),
              legend.text.align = 0)',sep = '')
      
    }
  
    if (cs == 'color'){
      string = paste('g <- ggplot()+
        geom_line(data=temp_durs,aes(x=eff_mass,
                                      y=',variable,',
                                      group=factor(modelnum),
                                      color=factor(modelnum),
                                      linetype = factor(modelnum)),
                                  size=2)+
        scale_linetype_manual(values=c(rep(\'dashed\',sum(models_to_plot<6)),
                                       \'solid\',
                                       rep(\'dashed\',sum(models_to_plot>6))),
                              guide = \'none\')+
        scale_color_manual(values = gg_color_hue(9)[models_to_plot],
                             labels=parse(text = model_labs[models_to_plot]))+
        geom_errorbar(data=errbar,aes(x=eff_mass,
                                      ymin=',variable,'-sd,
                                      ymax=',variable,'+sd),
                      color = gg_color_hue(9)[6],
                      size=2,
                      width = 0)+
        guides(color = guide_legend(override.aes = list(size = 5),
                                    title="Model",
                                    keyheight=.5,
                                    default.unit=\'inch\'))+
        labs(x=\'Effective Mass (kg)\',y=\'',label,'\')+
        scale_x_continuous(breaks=c(sort(unique(prefpilot$eff_mass))))+
        theme(legend.text=element_text(size=15),
              text = element_text(size=20),
              axis.text.x = element_text(size = 15),
              axis.text.y = element_text(size = 15),
              legend.text.align = 0)',sep = '')
    }
    
  } else {
    
    if (cs=='shape'){
      string = paste('g <- ggplot()+
        # geom_line(data=filter(temp_durs,model!=\'Pref\'),
        #                               aes(x=eff_mass,
        #                               y = ',variable,',
        #                               group = model),
        #                           color= \'grey\',
        #                           size=1)+
        # geom_line(data=filter(temp_durs,model==\'Pref\'),
        #                               aes(x=eff_mass,
        #                               y=',variable,'),
        #                           color= \'black\',
        #                           size=1)+
        geom_line(data=temp_durs,
                      aes(x=eff_mass,
                      y=',variable,',
                      color=factor(modelnum),
                      group=factor(modelnum)),
                  size=1)+
        geom_errorbar(data=errbar,aes(x=eff_mass,
                                      ymin=',variable,'-sd,
                                      ymax=',variable,'+sd),
                      color = \'black\',
                      size=1,
                      width = 0)+
        geom_point(data=temp_durs,aes(x=eff_mass,
                                      y=',variable,',
                                      group=factor(modelnum),
                                      shape=factor(modelnum)),
                                  size=3)+
        guides(shape = guide_legend(override.aes = list(size = 5),
                                    title="Model",
                                    keyheight=.5,
                                    default.unit=\'inch\'))+
        scale_shape_manual(values = shapes,
                    labels = parse(text = model_labs[models_to_plot]))+
        # scale_linetype_manual(values = c(\'dashed\',
        #                                  \'dashed\',
        #                                  \'dashed\',
        #                                  \'solid\',
        #                                  \'dashed\',
        #                                  \'solid\',
        #                                  \'solid\',
        #                                  \'dashed\',
        #                                  \'dashed\'),
        #                       guide = \'none\')+
        scale_color_manual(values = c(\'black\',
                                      \'black\',
                                      \'black\',
                                      \'blue\',
                                      \'blue\',
                                      \'blue\',
                                      \'blue\',
                                      \'blue\',
                                      \'blue\'),
                              guide = \'none\')+
        labs(x=\'Effective Mass (kg)\',y=\'',label,'\')+
        scale_x_continuous(breaks=c(sort(unique(prefpilot$eff_mass))))+
        theme(legend.text=element_text(size=15),
              text = element_text(size=20),
              axis.text.x = element_text(size = 15),
              axis.text.y = element_text(size = 15),
              legend.text.align = 0)+
        coord_cartesian(ylim=c(min(filter(temp_durs,model!=\'torque2\')$',variable,')*.99,
                        max(filter(temp_durs,model!=\'torque2\')$',variable,')*1.01))',sep = '')
      
    }
  
    if (cs == 'color'){
      string = paste('g <- ggplot()+
        geom_line(data=temp_durs,aes(x=eff_mass,
                                      y=',variable,',
                                      group=factor(modelnum),
                                      color=factor(modelnum),
                                      linetype = factor(modelnum)),
                                  size=2)+
        scale_linetype_manual(values=c(rep(\'dashed\',sum(models_to_plot<6)),
                                       \'solid\',
                                       rep(\'dashed\',sum(models_to_plot>6))),
                              guide = \'none\')+
        scale_color_manual(values = gg_color_hue(9)[models_to_plot],
                             labels=parse(text = model_labs[models_to_plot]))+
        guides(color = guide_legend(override.aes = list(size = 5),
                                    title="Model",
                                    keyheight=.5,
                                    default.unit=\'inch\'))+
        labs(x=\'Effective Mass (kg)\',y=\'',label,'\')+
        scale_x_continuous(breaks=c(sort(unique(prefpilot$eff_mass))))+
        theme(legend.text=element_text(size=15),
              text = element_text(size=20),
              axis.text.x = element_text(size = 15),
              axis.text.y = element_text(size = 15),
              legend.text.align = 0)+
        coord_cartesian(ylim=c(min(filter(temp_durs,model!=\'torque2\')$',variable,')*.99,
                        max(filter(temp_durs,model!=\'torque2\')$',variable,')*1.01))',sep = '')
    }
    
  }
  eval(parse(text = string))
  return(g)
}


model_plotting_addmass <- function(variable,label,temp_durs,errbar,cs,normalized){
  if (length(unique(temp_durs$model))==10){
    shapes = c(1:10)
  } else {
    shapes = c(16, 15, 17, 1, 0, 2, 5, 6, 11)
    # shapes = c(5,6,11,16,1,15,17,0,2)
  }
  if (normalized == 0){
    
    if (cs=='shape'){
      string = paste('g <- ggplot()+
        # geom_line(data=filter(temp_durs,model!=\'Pref\'),
        #                               aes(x=eff_mass,
        #                               y = ',variable,',
        #                               group = model),
        #                           color= \'grey\',
        #                           size=1)+
        # geom_line(data=filter(temp_durs,model==\'Pref\'),
        #                               aes(x=eff_mass,
        #                               y=',variable,'),
        #                           color= \'black\',
        #                           size=1)+
        geom_line(data=temp_durs,
                  aes(x=eff_mass,
                      y=',variable,',
                      color=factor(modelnum),
                      group=factor(modelnum)),
                  size=1)+
        geom_errorbar(data=errbar,aes(x=eff_mass,
                                      ymin=',variable,'-sd,
                                      ymax=',variable,'+sd),
                      color = \'black\',
                      size=1,
                      width = 0)+
        geom_point(data=temp_durs,
                   aes(x=eff_mass,
                       y=',variable,',
                       group=factor(modelnum),
                       shape=factor(modelnum)),
                   size=3)+
        guides(shape = guide_legend(override.aes = list(size = 5),
                                    title="Model",
                                    keyheight=.5,
                                    default.unit=\'inch\'))+
        scale_shape_manual(values = shapes,
                           labels = parse(text = model_labs[models_to_plot]))+
        # scale_linetype_manual(values = c(\'dashed\',
        #                                  \'dashed\',
        #                                  \'dashed\',
        #                                  \'solid\',
        #                                  \'dashed\',
        #                                  \'solid\',
        #                                  \'solid\',
        #                                  \'dashed\',
        #                                  \'dashed\'),
        #                       guide = \'none\')+
        scale_color_manual(values = c(\'black\',
                                      \'black\',
                                      \'black\',
                                      \'blue\',
                                      \'blue\',
                                      \'blue\',
                                      \'blue\',
                                      \'blue\',
                                      \'blue\'),
                              guide = \'none\')+
        labs(x=\'Added Mass (kg)\',y=\'',label,'\')+
        scale_x_continuous(breaks=c(sort(unique(prefpilot$eff_mass))))+
        theme(legend.text=element_text(size=15),
              text = element_text(size=20),
              axis.text.x = element_text(size = 15),
              axis.text.y = element_text(size = 15),
              legend.text.align = 0)',sep = '')
      
    }
  
    if (cs == 'color'){
      string = paste('g <- ggplot()+
        geom_line(data=temp_durs,aes(x=eff_mass,
                                      y=',variable,',
                                      group=factor(modelnum),
                                      color=factor(modelnum),
                                      linetype = factor(modelnum)),
                                  size=2)+
        scale_linetype_manual(values=c(rep(\'dashed\',sum(models_to_plot<6)),
                                       \'solid\',
                                       rep(\'dashed\',sum(models_to_plot>6))),
                              guide = \'none\')+
        scale_color_manual(values = gg_color_hue(9)[models_to_plot],
                             labels=parse(text = model_labs[models_to_plot]))+
        geom_errorbar(data=errbar,aes(x=eff_mass,
                                      ymin=',variable,'-sd,
                                      ymax=',variable,'+sd),
                      color = gg_color_hue(9)[6],
                      size=2,
                      width = 0)+
        guides(color = guide_legend(override.aes = list(size = 5),
                                    title="Model",
                                    keyheight=.5,
                                    default.unit=\'inch\'))+
        labs(x=\'Added Mass (kg)\',y=\'',label,'\')+
        scale_x_continuous(breaks=c(sort(unique(prefpilot$eff_mass))))+
        theme(legend.text=element_text(size=15),
              text = element_text(size=20),
              axis.text.x = element_text(size = 15),
              axis.text.y = element_text(size = 15),
              legend.text.align = 0)',sep = '')
    }
    
  } else {
    
    if (cs=='shape'){
      string = paste('g <- ggplot()+
        # geom_line(data=filter(temp_durs,model!=\'Pref\'),
        #                               aes(x=eff_mass,
        #                               y = ',variable,',
        #                               group = model),
        #                           color= \'grey\',
        #                           size=1)+
        # geom_line(data=filter(temp_durs,model==\'Pref\'),
        #                               aes(x=eff_mass,
        #                               y=',variable,'),
        #                           color= \'black\',
        #                           size=1)+
        geom_line(data=temp_durs,
                      aes(x=eff_mass,
                      y=',variable,',
                      color=factor(modelnum),
                      group=factor(modelnum)),
                  size=1)+
        geom_errorbar(data=errbar,aes(x=eff_mass,
                                      ymin=',variable,'-sd,
                                      ymax=',variable,'+sd),
                      color = \'black\',
                      size=1,
                      width = 0)+
        geom_point(data=temp_durs,aes(x=eff_mass,
                                      y=',variable,',
                                      group=factor(modelnum),
                                      shape=factor(modelnum)),
                                  size=3)+
        guides(shape = guide_legend(override.aes = list(size = 5),
                                    title="Model",
                                    keyheight=.5,
                                    default.unit=\'inch\'))+
        scale_shape_manual(values = shapes,
                    labels = parse(text = model_labs[models_to_plot]))+
        # scale_linetype_manual(values = c(\'dashed\',
        #                                  \'dashed\',
        #                                  \'dashed\',
        #                                  \'solid\',
        #                                  \'dashed\',
        #                                  \'solid\',
        #                                  \'solid\',
        #                                  \'dashed\',
        #                                  \'dashed\'),
        #                       guide = \'none\')+
        scale_color_manual(values = c(\'black\',
                                      \'black\',
                                      \'black\',
                                      \'blue\',
                                      \'blue\',
                                      \'blue\',
                                      \'blue\',
                                      \'blue\',
                                      \'blue\'),
                              guide = \'none\')+
        labs(x=\'Added Mass (kg)\',y=\'',label,'\')+
        scale_x_continuous(breaks=c(sort(unique(prefpilot$eff_mass))))+
        theme(legend.text=element_text(size=15),
              text = element_text(size=20),
              axis.text.x = element_text(size = 15),
              axis.text.y = element_text(size = 15),
              legend.text.align = 0)+
        coord_cartesian(ylim=c(min(filter(temp_durs,model!=\'torque2\')$',variable,')*.99,
                        max(filter(temp_durs,model!=\'torque2\')$',variable,')*1.01))',sep = '')
      
    }
  
    if (cs == 'color'){
      string = paste('g <- ggplot()+
        geom_line(data=temp_durs,aes(x=eff_mass,
                                      y=',variable,',
                                      group=factor(modelnum),
                                      color=factor(modelnum),
                                      linetype = factor(modelnum)),
                                  size=2)+
        scale_linetype_manual(values=c(rep(\'dashed\',sum(models_to_plot<6)),
                                       \'solid\',
                                       rep(\'dashed\',sum(models_to_plot>6))),
                              guide = \'none\')+
        scale_color_manual(values = gg_color_hue(9)[models_to_plot],
                             labels=parse(text = model_labs[models_to_plot]))+
        guides(color = guide_legend(override.aes = list(size = 5),
                                    title="Model",
                                    keyheight=.5,
                                    default.unit=\'inch\'))+
        labs(x=\'Added Mass (kg)\',y=\'',label,'\')+
        scale_x_continuous(breaks=c(sort(unique(prefpilot$eff_mass))))+
        theme(legend.text=element_text(size=15),
              text = element_text(size=20),
              axis.text.x = element_text(size = 15),
              axis.text.y = element_text(size = 15),
              legend.text.align = 0)+
        coord_cartesian(ylim=c(min(filter(temp_durs,model!=\'torque2\')$',variable,')*.99,
                        max(filter(temp_durs,model!=\'torque2\')$',variable,')*1.01))',sep = '')
    }
    
  }
  eval(parse(text = string))
  return(g)
}
```

## DF Creation

```{r, echo = FALSE, warning = FALSE}

options(warn=-1)
# ================  Fitting Movement Duration
# masses = unique(prefdata$eff_mass)
masses = unique(prefdata$condition)/2.2
models = c('Pref','MPNet_Cost','MGross_Cost','Utility','m1','Torque')
model_durs = data.frame('eff_mass' = cbind(rep(masses,17)),
                        'model' = c(rep('Pref',4),   
                                    rep('MPNet_Cost',4),
                                    rep('MGross_cost',4),
                                    rep('Util_gross',4),
                                    rep('Util_net',4),
                                    rep('Util_gross_rx',4),
                                    rep('Util_net_rx',4),
                                    rep('Util_comb_alpha_gross',4),
                                    rep('Util_comb_alpha_net',4),
                                    rep('m1',4),
                                    rep('m2',4),
                                    rep('torque2',4),
                                    rep('accuracy',4),
                                    rep('2b',4),
                                    rep('2c',4),
                                    rep('2b_util',4),
                                    rep('2c_util',4)),
                        'movedur' = c(aggregate(movedur~eff_mass,prefdata,mean)$movedur,
                                     met_net_dur,
                                     met_gross_dur,
                                     util_dur_gross,
                                     util_dur_net,
                                     util_dur_gross_rx,
                                     util_dur_net_rx,
                                     util_dur_pref_alpha_comb_gross[1:4],
                                     util_dur_pref_alpha_comb_net[1:4],
                                     m1_dur,
                                     m2_dur,
                                     torque_dur_2a,
                                     prob_dur_pref,
                                     aggregate(movedur~eff_mass,smalltdata,mean)$movedur,
                                     aggregate(movedur~eff_mass,pilotdata,mean)$movedur,
                                     util_dur_pref_alpha_comb_gross[5:8],
                                     util_dur_pilot_gross),
                        'modelnum' = c(rep(1,4),
                                       rep(7,4),
                                       rep(8,4),
                                       rep(17,4),
                                       rep(10,4),
                                       rep(11,4),
                                       rep(12,4),
                                       rep(4,4),
                                       rep(13,4),
                                       rep(14,4),
                                       rep(15,4),
                                       rep(9,4),
                                       rep(16,4),
                                       rep(2,4),
                                       rep(3,4),
                                       rep(5,4),
                                       rep(6,4)))
                                       
                          
                                       # rep(6,4),
                                       # rep(5,4),
                                       # rep(4,4),
                                       # rep(7,4),
                                       # rep(8,4),
                                       # rep(9,4),
                                       # rep(10,4),
                                       # rep(11,4),
                                       # rep(12,4),
                                       # rep(1,4),
                                       # rep(2,4),
                                       # rep(3,4),
                                       # rep(13,4),
                                       # rep(14,4),
                                       # rep(15,4),
                                       # rep(16,4),
                                       # rep(17,4)))


# 6, 5, 4, 13, 3, 11

norm_durs = c()
for (c in 1:length(unique(model_durs$modelnum))){
  x = model_durs$movedur[seq(4*c-3,4*c)]/model_durs$movedur[4*c-3]
  norm_durs = c(norm_durs,x)
}
model_durs$norm_durs = norm_durs

# model_labs = c(TeX('$Mass^1$'),
#                TeX('$Mass^2$'),
#                TeX('$Torque^2$'),
#                TeX('Met Cost\nGross'),
#                TeX('Met Cost\nNet'),
#                TeX('Preferred\nDuration'),
#                TeX('Utility Gross'),
#                TeX('Utility Net'),
#                TeX('Utility Gross'),
#                TeX('Utility Net'),
#                TeX('Utility Gross\nComb Alpha'),
#                TeX('Utility Net\nComb Alpha'),
#                TeX('Accuracy Prob'),
#                TeX('2b Duration'),
#                TeX('2c Duration'),
#                TeX('2b Utility'),
#                TeX('2c Utility'))
# models_to_plot = c(3,4,5,6,9,10,11,12)
model_labs = c(TeX('2a Duration'),
               TeX('2b Duration'),
               TeX('3c Duration'),
               TeX('2a Util'),
               TeX('2b Util'),
               TeX('2c Util'),
               TeX('Net Cost'),
               TeX('Gross Cost'),
               TeX('$Torque^2$'),
               TeX('4'),
               TeX('5'),
               TeX('6'),
               TeX('8'),
               TeX('9'),
               TeX('10'),
               TeX('12'),
               TeX('15'))
models_to_plot = c( 1,2,3,4,5,6,7,8,9)
# models_to_plot = c(4,6,11)
temp_durs = filter(model_durs, modelnum %in% models_to_plot)


```

## Peak Velocity Plotting

```{r, echo = FALSE, warning = FALSE}
#================  Peak Velocity Sim
min_jerk_vel <- function(t,d) (.1)*(30*(t/d)^2-60*(t/d)^3+30*(t/d)^4)
min_jerk_vel <- function(tm){
  ro = 0
  rf = 0.1
  dt=0.001
  
  tme=seq(0,tm,dt)
  ts=tme/tm
  
  t2=ts*ts
  t3=t2*ts
  t4=t3*ts
  t5=t4*ts
  
  v=((60*t3-30*t4-30*t2)/tm)*(ro-rf)
  return(max(v))
}
min_jerk_vel_2c <- function(tm, rf){
  ro = 0
  # rf = 0.1
  dt=0.001
  
  tme=seq(0,tm,dt)
  ts=tme/tm
  
  t2=ts*ts
  t3=t2*ts
  t4=t3*ts
  t5=t4*ts
  
  v=((60*t3-30*t4-30*t2)/tm)*(ro-rf)
  return(max(v))
} 


t <- seq(0, 0.66, 0.01)

met_net_peakvel =c(0,0,0,0)
met_gross_peakvel = c(0,0,0,0)
util_peakvel_gross = c(0,0,0,0)
util_peakvel_net = c(0,0,0,0)
util_peakvel_gross_rx = c(0,0,0,0)
util_peakvel_net_rx = c(0,0,0,0)
util_peakvel_comb_alpha_gross = c(0,0,0,0)
util_peakvel_comb_alpha_net = c(0,0,0,0)
m1_peakvel = c(0,0,0,0)
m2_peakvel = c(0,0,0,0)
torque_peakvel = c(0,0,0,0)
accuracy_peakvel = c(0,0,0,0)
twob_util_peakvel = c(0,0,0,0)
twoc_util_peakvel = c(0,0,0,0)
for (c in 1:4){
  met_net_peakvel[c] = min_jerk_vel(met_net_dur[c])
  met_gross_peakvel[c] = min_jerk_vel(met_gross_dur[c])
  util_peakvel_gross[c] = min_jerk_vel(util_dur_gross[c])
  util_peakvel_net[c] = min_jerk_vel(util_dur_net[c])
  util_peakvel_gross_rx[c] = min_jerk_vel(util_dur_gross_rx[c])
  util_peakvel_net_rx[c] = min_jerk_vel(util_dur_net_rx[c])
  util_peakvel_comb_alpha_gross[c] = min_jerk_vel(util_dur_pref_alpha_comb_gross[c])
  util_peakvel_comb_alpha_net[c] = min_jerk_vel(util_dur_pref_alpha_comb_net[c])
  m1_peakvel[c] = min_jerk_vel(m1_dur[c])
  m2_peakvel[c] = min_jerk_vel(m2_dur[c])
  torque_peakvel[c] = min_jerk_vel(torque_dur_2a[c])
  accuracy_peakvel[c] = min_jerk_vel(prob_dur_pref[c])
  twob_util_peakvel[c] = min_jerk_vel(util_dur_pref_alpha_comb_gross[c+4])
  twoc_util_peakvel[c] = min_jerk_vel_2c(util_dur_pilot_gross[c],
                                      aggregate(maxex ~ condition,pilotdata,mean)$maxex)
}

model_vels = data.frame('eff_mass' = cbind(rep(masses,17)),
                        'model' = c(rep('Pref',4),
                                    rep('MPNet_Cost',4),
                                    rep('MGross_cost',4),
                                    rep('Util_gross',4),
                                    rep('Util_net',4),
                                    rep('Util_gross_rx',4),
                                    rep('Util_net_rx',4),
                                    rep('Util_comb_alpha_gross',4),
                                    rep('Util_comb_alpha_net',4),
                                    rep('m1',4),
                                    rep('m2',4),
                                    rep('torque2',4),
                                    rep('accuracy',4),
                                    rep('2b',4),
                                    rep('2c',4),
                                    rep('2b_util',4),
                                    rep('2c_util',4)),
                        'peakvel' = c(aggregate(peakvel_target~eff_mass,prefdata,mean)$peakvel_target,
                                      met_net_peakvel,
                                      met_gross_peakvel,
                                      util_peakvel_gross,
                                      util_peakvel_net,
                                      util_peakvel_gross_rx,
                                      util_peakvel_net_rx,
                                      util_peakvel_comb_alpha_gross,
                                      util_peakvel_comb_alpha_net,
                                      m1_peakvel,
                                      m2_peakvel,
                                      torque_peakvel,
                                      accuracy_peakvel,
                                      aggregate(peakvel_target~eff_mass,smalltdata,mean)$peakvel_target,    
                                      aggregate(peakvel_target~eff_mass,pilotdata,mean)$peakvel_target,
                                      twob_util_peakvel,
                                      twoc_util_peakvel),
                        'modelnum' = c(rep(1,4),
                                       rep(7,4),
                                       rep(8,4),
                                       rep(17,4),
                                       rep(10,4),
                                       rep(11,4),
                                       rep(12,4),
                                       rep(4,4),
                                       rep(13,4),
                                       rep(14,4),
                                       rep(15,4),
                                       rep(9,4),
                                       rep(16,4),
                                       rep(2,4),
                                       rep(3,4),
                                       rep(5,4),
                                       rep(6,4)))
                                       
                          
                                       # rep(6,4),
                                       # rep(5,4),
                                       # rep(4,4),
                                       # rep(7,4),
                                       # rep(8,4),
                                       # rep(9,4),
                                       # rep(10,4),
                                       # rep(11,4),
                                       # rep(12,4),
                                       # rep(1,4),
                                       # rep(2,4),
                                       # rep(3,4),
                                       # rep(13,4),
                                       # rep(14,4),
                                       # rep(15,4),
                                       # rep(16,4),
                                       # rep(17,4)))

norm_vels = c()
for (c in 1:length(unique(model_durs$modelnum))){
  x = model_vels$peakvel[seq(4*c-3,4*c)]/model_vels$peakvel[4*c-3]
  norm_vels = c(norm_vels,x)
}
model_vels$norm_vels = norm_vels
temp_vels = model_vels

```

## SSE of models - Exp 2a
The utility combined alpha is using the alpha value predicted off fitting a utility model to the preferred and small target experiement at the same time. This alpha value is used to make figure \@ref(fig:groupedutilitymovedur1).

### Absolute

```{r, echo = FALSE, warning = FALSE}

Model_SSE_movedur = c()
Model_AIC_movedur = c()
Model_BIC_movedur = c()
Model_SSE_peakvel = c()
Model_AIC_peakvel = c()
Model_BIC_peakvel = c()
Model_SSE_colnames = c()
Model_SSE = c()

models_SSE = c('m1',
               'm2',
               'accuracy',
               'MGross_cost',
               'MPNet_Cost',
               'torque2',
               'Util_gross',
               'Util_gross_rx',
               'Util_net',
               'Util_net_rx',
               'Util_comb_alpha_gross',
               'Util_comb_alpha_net',
               'Pref')
for (model1 in models_SSE){
  if (model1 %in% c('Util_gross','Util_gross_rx','Util_net_rx','Util_net','Util_comb_alpha_gross','Util_comb_alpha_net')){
    n_params = 1
  } else {
    n_params = 0
  }
  
  model_movedur_temp1 = filter(model_durs,model==model1)$movedur
  model_movedur_temp2 = filter(model_durs,model=='Pref')$movedur
  SSE = sum((model_movedur_temp1-model_movedur_temp2)^2)
  Model_SSE_movedur = rbind(Model_SSE_movedur,SSE)
  
  Model_AIC_movedur = c(Model_AIC_movedur, 4*log(SSE)-4*log(4)+2*(n_params+1))
  Model_BIC_movedur = c(Model_BIC_movedur, 4*log(SSE)-4*log(4)+log(4)*(n_params+1))
  
  model_peakvel_temp1 = filter(model_vels,model==model1)$peakvel
  model_peakvel_temp2 = filter(model_vels,model=='Pref')$peakvel
  SSE = sum((model_peakvel_temp1-model_peakvel_temp2)^2)
  Model_SSE_peakvel = rbind(Model_SSE_peakvel,SSE)
  # Model_SSE_colnames = rbind(Model_SSE_colnames,model1)
  
  Model_AIC_peakvel = c(Model_AIC_peakvel, 4*log(SSE)-4*log(4)+2*(n_params+1))
  Model_BIC_peakvel = c(Model_BIC_peakvel, 4*log(SSE)-4*log(4)+log(4)*(n_params+1))
  
}

Model_SSE_movedur = formatC(Model_SSE_movedur,format = 'e', digits = 3)
Model_SSE_peakvel = formatC(Model_SSE_peakvel,format = 'e', digits = 3)

Model_AIC_movedur = formatC(Model_AIC_movedur,format = 'e', digits = 2)
Model_BIC_movedur = formatC(Model_BIC_movedur,format = 'e', digits = 2)
Model_AIC_peakvel = formatC(Model_AIC_peakvel,format = 'e', digits = 2)
Model_BIC_peakvel = formatC(Model_BIC_peakvel,format = 'e', digits = 2)

Model_SSE = as.data.frame(cbind(models_SSE,
                                Model_SSE_movedur,
                                Model_AIC_movedur,
                                Model_BIC_movedur,
                                Model_SSE_peakvel,
                                Model_AIC_peakvel,
                                Model_BIC_peakvel))

colnames(Model_SSE) <- c('model',
                         'Movement Duration SSE',
                         'Movement Duration AIC',
                         'Movement Duration BIC',
                         'Peak Velocity SSE',
                         'Peak Velocity AIC',
                         'Peak Velocity BIC')

Model_SSE = filter(Model_SSE,
                   model!='Pref',
                   model!='Util_net',
                   model!='m2',
                   model!='m1',
                   model!='Util_gross',
                   model!='Util_net')

Model_SSE$model = c('Accuracy Prob',
                    'Met Cost Gross',
                    'Met Cost Net',
                    'Torque^2',
                    'Utility Gross',
                    'Utility Net',
                    'Utility Gross Combined Alpha',
                    'Utility Net Combined Alpha')

colnames(Model_SSE) = c('Model',
                        'Movement Duration SSE',
                        'Movement Duration AIC',
                        'Movement Duration BIC',
                        'Peak Velocity SSE',
                        'Peak Velocity AIC',
                        'Peak Velocity BIC')
```

This table shows the SSE for the 2a movement duration and peak velocity predictions.

```{r ModelSSE1, echo = FALSE, warning = FALSE, tab.cap = 'Exp 2a - Sum squared errors for movement duration and peak velocity.'}
kable(Model_SSE, caption = 'Exp 2a - Sum squared errors for movement duration and peak velocity.')
```

### Normalized
```{r, echo = FALSE, warning = FALSE}
# Normalzied version
Model_SSE_movedur_norm = c()
Model_AIC_movedur_norm = c()
Model_BIC_movedur_norm = c()
Model_SSE_peakvel_norm = c()
Model_AIC_peakvel_norm = c()
Model_BIC_peakvel_norm = c()
Model_SSE_colnames_norm = c()
Model_SSE_norm = c()

for (model1 in models_SSE){
  if (model1 %in% c('Util_gross','Util_gross_rx','Util_net_rx','Util_net','Util_comb_alpha_gross','Util_comb_alpha_net')){
    n_params = 1
  } else {
    n_params = 0
  }
  
  model_movedur_temp1_norm = filter(model_durs,model==model1)$norm_durs
  model_movedur_temp2_norm = filter(model_durs,model=='Pref')$norm_durs
  SSE = sum((model_movedur_temp1_norm-model_movedur_temp2_norm)^2)
  Model_SSE_movedur_norm = rbind(Model_SSE_movedur_norm,SSE)
  
  Model_AIC_movedur_norm = c(Model_AIC_movedur_norm, 4*log(SSE)-4*log(4)+2*(n_params+1))
  Model_BIC_movedur_norm = c(Model_BIC_movedur_norm, 4*log(SSE)-4*log(4)+log(4)*(n_params+1))
  
  model_peakvel_temp1_norm = filter(model_vels,model==model1)$norm_vels
  model_peakvel_temp2_norm = filter(model_vels,model=='Pref')$norm_vels
  SSE = sum((model_peakvel_temp1_norm-model_peakvel_temp2_norm)^2)
  Model_SSE_peakvel_norm = rbind(Model_SSE_peakvel_norm,SSE)
  # Model_SSE_colnames = rbind(Model_SSE_colnames,model1)
  
  Model_AIC_peakvel_norm = c(Model_AIC_peakvel_norm, 4*log(SSE)-4*log(4)+2*(n_params+1))
  Model_BIC_peakvel_norm = c(Model_BIC_peakvel_norm, 4*log(SSE)-4*log(4)+log(4)*(n_params+1))
  
}
Model_SSE_movedur_norm = formatC(Model_SSE_movedur_norm,format = 'e', digits = 3)
Model_SSE_peakvel_norm = formatC(Model_SSE_peakvel_norm,format = 'e', digits = 3)

Model_AIC_movedur_norm = formatC(Model_AIC_movedur_norm,format = 'e', digits = 2)
Model_BIC_movedur_norm = formatC(Model_BIC_movedur_norm,format = 'e', digits = 2)
Model_AIC_peakvel_norm = formatC(Model_AIC_peakvel_norm,format = 'e', digits = 2)
Model_BIC_peakvel_norm = formatC(Model_BIC_peakvel_norm,format = 'e', digits = 2)

Model_SSE_norm = as.data.frame(cbind(models_SSE,
                                Model_SSE_movedur_norm,
                                Model_AIC_movedur_norm,
                                Model_BIC_movedur_norm,
                                Model_SSE_peakvel_norm,
                                Model_AIC_peakvel_norm,
                                Model_BIC_peakvel_norm))

colnames(Model_SSE_norm) <- c('model',
                         'Movement Duration SSE',
                         'Movement Duration AIC',
                         'Movement Duration BIC',
                         'Peak Velocity SSE',
                         'Peak Velocity AIC',
                         'Peak Velocity BIC')

Model_SSE_norm = filter(Model_SSE_norm,
                        model!='Pref',
                        model!='Util_net',
                        model!='m2',
                        model!='m1',
                        model!='Util_gross',
                        model!='Util_net')

Model_SSE_norm$model = c('Accuracy Prob',
                    'Met Cost Gross',
                    'Met Cost Net',
                    'Torque^2',
                    'Utility Gross',
                    'Utility Net',
                    'Utility Gross Combined Alpha',
                    'Utility Net Combined Alpha')

colnames(Model_SSE_norm) = c('Model',
                        'Movement Duration SSE',
                        'Movement Duration AIC',
                        'Movement Duration BIC',
                        'Peak Velocity SSE',
                        'Peak Velocity AIC',
                        'Peak Velocity BIC')
```

```{r ModelSSEnorm1, echo = FALSE, warning = FALSE, tab.cap = 'Exp 2a - Sum squared errors for NORMALIZED movement duration and peak velocity.'}
kable(Model_SSE_norm, caption = 'Exp 2a - Sum squared errors for NORMALIZED movement duration and peak velocity.')
```

## 2a Modeling Plot

```{r, echo = FALSE, warning = FALSE, fig.cap = 'Modeled movement durations and peak velocities.'}
## Making the Model Group plot

## Movement Duration
theme_set(theme_cowplot(font_size=12))

norm_vals <- function(data){
  dur0 = aggregate(movedur ~ eff_mass + subj, data, mean)
  vel0 = aggregate(peakvel_target ~ eff_mass + subj, data, mean)
  for (k in 1:length(data$subj)){
    data[k,'movedurnorm'] = data[k,'movedur']/filter(dur0,subj==data[k,'subj'])$movedur[1]
    data[k,'peakvelnorm'] = data[k,'peakvel_target']/filter(vel0,subj==data[k,'subj'])$peakvel_target[1]
  }
  return(data)
}

prefdata <- norm_vals(prefdata)
smalltdata <- norm_vals(smalltdata)
pilotdata <- norm_vals(pilotdata)

# errbar = rbind(cbind(aggregate(movedur~eff_mass,prefdata,mean),
#                      aggregate(movedur~eff_mass,prefdata,sd)[2]/sqrt(length(unique(prefdata$subj)))),
#                cbind(aggregate(movedur~eff_mass,smalltdata,mean),
#                      aggregate(movedur~eff_mass,smalltdata,sd)[2]/sqrt(length(unique(smalltdata$subj)))),
#                cbind(aggregate(movedur~eff_mass,pilotdata,mean),
#                      aggregate(movedur~eff_mass,pilotdata,sd)[2]/sqrt(length(unique(pilotdata$subj)))))
errbar = rbind(cbind(aggregate(movedur~condition,prefdata,mean),
                     aggregate(movedur~condition,prefdata,sd)[2]/sqrt(length(unique(prefdata$subj)))),
               cbind(aggregate(movedur~condition,smalltdata,mean),
                     aggregate(movedur~condition,smalltdata,sd)[2]/sqrt(length(unique(smalltdata$subj)))),
               cbind(aggregate(movedur~condition,pilotdata,mean),
                     aggregate(movedur~condition,pilotdata,sd)[2]/sqrt(length(unique(pilotdata$subj)))))
colnames(errbar) = c('eff_mass','movedur','sd')
errbar$eff_mass = errbar$eff_mass/2.2

Model_movedur_shape <- model_plotting_addmass('movedur','Movement Duration (s)',temp_durs,errbar,'shape',normalized = 0)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))

Model_movedur_color <- model_plotting_addmass('movedur','Movement Duration (s)',temp_durs,errbar,'color',normalized = 0)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))

setwd(pref_plots_dir)
if (save_plots){ggsave('Model_movedur_shape.pdf',plot=Model_movedur_shape, width = 7, height = 5, useDingbats = FALSE)}

temp_durs = model_durs
temp_durs = filter(model_durs, modelnum %in% models_to_plot)

# errbar = rbind(cbind(aggregate(movedurnorm~eff_mass,prefdata,mean),
#                      aggregate(movedurnorm~eff_mass,prefdata,sd)[2]/sqrt(length(unique(prefdata$subj)))),
#                cbind(aggregate(movedurnorm~eff_mass,smalltdata,mean),
#                      aggregate(movedurnorm~eff_mass,smalltdata,sd)[2]/sqrt(length(unique(smalltdata$subj)))),
#                cbind(aggregate(movedurnorm~eff_mass,pilotdata,mean),
#                      aggregate(movedurnorm~eff_mass,pilotdata,sd)[2]/sqrt(length(unique(pilotdata$subj)))))
# colnames(errbar) = c('eff_mass','norm_durs','sd')
errbar = rbind(cbind(aggregate(movedurnorm~condition,prefdata,mean),
                     aggregate(movedurnorm~condition,prefdata,sd)[2]/sqrt(length(unique(prefdata$subj)))),
               cbind(aggregate(movedurnorm~condition,smalltdata,mean),
                     aggregate(movedurnorm~condition,smalltdata,sd)[2]/sqrt(length(unique(smalltdata$subj)))),
               cbind(aggregate(movedurnorm~condition,pilotdata,mean),
                     aggregate(movedurnorm~condition,pilotdata,sd)[2]/sqrt(length(unique(pilotdata$subj)))))
colnames(errbar) = c('eff_mass','norm_durs','sd')
errbar$eff_mass = errbar$eff_mass/2.2

Model_normmovedur_shape <- model_plotting_addmass('norm_durs','Norm Movement Duration (s)',temp_durs,errbar,'shape',normalized = 1)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))
Model_normmovedur_color <- model_plotting_addmass('norm_durs','Norm Movement Duration (s)',temp_durs,errbar,'color',normalized = 1)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))

## Peak Velocity

temp_vels = model_vels
temp_vels = filter(temp_vels, modelnum %in% models_to_plot)

# errbar = rbind(cbind(aggregate(peakvel_target~eff_mass,prefdata,mean),
#                      aggregate(peakvel_target~eff_mass,prefdata,sd)[2]/sqrt(length(unique(prefdata$subj)))),
#                cbind(aggregate(peakvel_target~eff_mass,smalltdata,mean),
#                      aggregate(peakvel_target~eff_mass,smalltdata,sd)[2]/sqrt(length(unique(smalltdata$subj)))),
#                cbind(aggregate(peakvel_target~eff_mass,pilotdata,mean),
#                      aggregate(peakvel_target~eff_mass,pilotdata,sd)[2]/sqrt(length(unique(pilotdata$subj)))))
# colnames(errbar) = c('eff_mass','peakvel','sd')
errbar = rbind(cbind(aggregate(peakvel_target~condition,prefdata,mean),
                     aggregate(peakvel_target~condition,prefdata,sd)[2]/sqrt(length(unique(prefdata$subj)))),
               cbind(aggregate(peakvel_target~condition,smalltdata,mean),
                     aggregate(peakvel_target~condition,smalltdata,sd)[2]/sqrt(length(unique(smalltdata$subj)))),
               cbind(aggregate(peakvel_target~condition,pilotdata,mean),
                     aggregate(peakvel_target~condition,pilotdata,sd)[2]/sqrt(length(unique(pilotdata$subj)))))
colnames(errbar) = c('eff_mass','peakvel','sd')
errbar$eff_mass = errbar$eff_mass/2.2

Model_peakvel_shape <- model_plotting_addmass('peakvel','Peak Velocity (m/s)',
                                      temp_vels,errbar,'shape',normalized = 0)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))
Model_peakvel_color <- model_plotting_addmass('peakvel','Peak Velocity (m/s)',
                                      temp_vels,errbar,'color',normalized = 0)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))


# setwd(pref_plots_dir)
# if (save_plots){ggsave('Model_peakvel_shape.pdf',plot=Model_peakvel_shape,useDingbats = FALSE)}

temp_vels = model_vels
temp_vels = filter(temp_vels, modelnum %in% models_to_plot)

# errbar = rbind(cbind(aggregate(peakvelnorm~eff_mass,prefdata,mean),
#                      aggregate(peakvelnorm~eff_mass,prefdata,sd)[2]/sqrt(length(unique(prefdata$subj)))),
#                cbind(aggregate(peakvelnorm~eff_mass,smalltdata,mean),
#                      aggregate(peakvelnorm~eff_mass,smalltdata,sd)[2]/sqrt(length(unique(smalltdata$subj)))),
#                cbind(aggregate(peakvelnorm~eff_mass,pilotdata,mean),
#                      aggregate(peakvelnorm~eff_mass,pilotdata,sd)[2]/sqrt(length(unique(pilotdata$subj)))))
# colnames(errbar) = c('eff_mass','norm_vels','sd')
errbar = rbind(cbind(aggregate(peakvelnorm~condition,prefdata,mean),
                     aggregate(peakvelnorm~condition,prefdata,sd)[2]/sqrt(length(unique(prefdata$subj)))),
               cbind(aggregate(peakvelnorm~condition,smalltdata,mean),
                     aggregate(peakvelnorm~condition,smalltdata,sd)[2]/sqrt(length(unique(smalltdata$subj)))),
               cbind(aggregate(peakvelnorm~condition,pilotdata,mean),
                     aggregate(peakvelnorm~condition,pilotdata,sd)[2]/sqrt(length(unique(pilotdata$subj)))))
colnames(errbar) = c('eff_mass','norm_vels','sd')
errbar$eff_mass = errbar$eff_mass/2.2

Model_normpeakvel_shape <- model_plotting_addmass('norm_vels','Norm Peak Velocity (m/s)',
                                          temp_vels,errbar,'shape',normalized = 1)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))
Model_normpeakvel_color <- model_plotting_addmass('norm_vels','Norm Velocity (m/s)',
                                          temp_vels,errbar,'color',normalized = 1)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))

# setwd(pref_plots_dir)
# if (save_plots){ggsave('Model_peakvelnorm_shape.pdf',plot=Model_normpeakvel_shape,useDingbats = FALSE)}

## Grouping

add_legend_shape <- get_legend(Model_movedur_shape)
add_legend_color <- get_legend(Model_movedur_color)

plots_to_fix = c('Model_movedur_shape',
                 'Model_normmovedur_shape',
                 'Model_peakvel_shape',
                 'Model_normpeakvel_shape',
                 'Model_movedur_color',
                 'Model_normmovedur_color',
                 'Model_peakvel_color',
                 'Model_normpeakvel_color')

for (plot in plots_to_fix){
  string = paste(plot,'<-',plot,'+
                 # theme_classic()
                 theme(text        = element_text(size = 16, color=\'black\'),
                 axis.text         = element_text(color=\'black\'),
                 axis.ticks        = element_line(color=\'black\'),
                 plot.title        = element_text(hjust = 0.5),
                 axis.line         = element_line(color=\'black\'),
                 legend.position   = \'none\')',sep = '')
  eval(parse(text = string))
}

Results_model_r_shape <- plot_grid(Model_movedur_shape+theme(legend.position='none'),
         Model_normmovedur_shape+theme(legend.position='none'),
         Model_peakvel_shape+theme(legend.position='none'),
         Model_normpeakvel_shape+theme(legend.position='none'),
         nrow = 2,
         hjust = -1,
         labels = c('A','B','C','D'),
         label_size = 20,
         align = 'vh')
Results_model_r_shape<-plot_grid(Results_model_r_shape,add_legend_shape,nrow=1,rel_widths = c(.85,.15))

setwd(pref_plots_dir)
if (save_plots){ggsave('Results_model_r_shape.pdf',plot = Results_model_r_shape, height = 8, width = 8/.85, useDingbats = FALSE)}

Results_model_r_color <- plot_grid(Model_movedur_color+theme(legend.position='none'),
         Model_normmovedur_color+theme(legend.position='none'),
         Model_peakvel_color+theme(legend.position='none'),
         Model_normpeakvel_color+theme(legend.position='none'),
         nrow = 2,
         hjust = -1,
         labels = c('A','B','C','D'),
         label_size = 20,
         align = 'vh')
Results_model_r_color<-plot_grid(Results_model_r_color,add_legend_color,nrow=1,rel_widths = c(.85,.15))

# setwd(pref_plots_dir)
# if (save_plots){ggsave('Results_model_r_color.pdf',plot = Results_model_r_color, height = 8, width = 8/.85, useDingbats = FALSE)}
options(warn=0)
```

```{r Resultsmodelrshape2a, echo = FALSE, fig.width=9, fig.height=6, fig.cap = 'Modeling Results'}
Results_model_r_shape
```


<!-- ### SSE of models - Exp 2a to 2b -->

<!-- #### Absolute -->
<!-- ```{r, echo = FALSE, warning = FALSE} -->

<!-- Model_SSE_movedur = c() -->
<!-- Model_AIC_movedur = c() -->
<!-- Model_BIC_movedur = c() -->
<!-- Model_SSE_peakvel = c() -->
<!-- Model_AIC_peakvel = c() -->
<!-- Model_BIC_peakvel = c() -->
<!-- Model_SSE_colnames = c() -->
<!-- Model_SSE = c() -->

<!-- models_SSE = c('m1', -->
<!--                'm2', -->
<!--                'accuracy', -->
<!--                'MGross_cost', -->
<!--                'MPNet_Cost', -->
<!--                'torque2', -->
<!--                'Util_gross', -->
<!--                'Util_gross_rx', -->
<!--                'Util_net', -->
<!--                'Util_net_rx', -->
<!--                'Util_comb_alpha_gross', -->
<!--                'Util_comb_alpha_net', -->
<!--                'Pref') -->
<!-- for (model1 in models_SSE){ -->
<!--   if (model1 %in% c('Util_gross','Util_gross_rx','Util_net_rx','Util_net','Util_comb_alpha_gross','Util_comb_alpha_net')){ -->
<!--     n_params = 1 -->
<!--   } else { -->
<!--     n_params = 0 -->
<!--   } -->

<!--   model_movedur_temp1 = filter(model_durs,model==model1)$movedur -->
<!--   model_movedur_temp2 = aggregate(movedur~eff_mass,smalltdata,mean)$movedur -->
<!--   SSE = sum((model_movedur_temp1-model_movedur_temp2)^2) -->
<!--   Model_SSE_movedur = rbind(Model_SSE_movedur,SSE) -->

<!--   Model_AIC_movedur = c(Model_AIC_movedur, 4*log(SSE)-4*log(4)+2*(n_params+1)) -->
<!--   Model_BIC_movedur = c(Model_BIC_movedur, 4*log(SSE)-4*log(4)+log(4)*(n_params+1)) -->

<!--   model_peakvel_temp1 = filter(model_vels,model==model1)$peakvel -->
<!--   model_peakvel_temp2 = aggregate(peakvel_target~eff_mass,smalltdata,mean)$peakvel_target -->
<!--   SSE = sum((model_peakvel_temp1-model_peakvel_temp2)^2) -->
<!--   Model_SSE_peakvel = rbind(Model_SSE_peakvel,SSE) -->
<!--   # Model_SSE_colnames = rbind(Model_SSE_colnames,model1) -->

<!--   Model_AIC_peakvel = c(Model_AIC_peakvel, 4*log(SSE)-4*log(4)+2*(n_params+1)) -->
<!--   Model_BIC_peakvel = c(Model_BIC_peakvel, 4*log(SSE)-4*log(4)+log(4)*(n_params+1)) -->

<!-- } -->

<!-- Model_SSE_movedur = formatC(Model_SSE_movedur,format = 'e', digits = 3) -->
<!-- Model_SSE_peakvel = formatC(Model_SSE_peakvel,format = 'e', digits = 3) -->

<!-- Model_AIC_movedur = formatC(Model_AIC_movedur,format = 'e', digits = 2) -->
<!-- Model_BIC_movedur = formatC(Model_BIC_movedur,format = 'e', digits = 2) -->
<!-- Model_AIC_peakvel = formatC(Model_AIC_peakvel,format = 'e', digits = 2) -->
<!-- Model_BIC_peakvel = formatC(Model_BIC_peakvel,format = 'e', digits = 2) -->

<!-- Model_SSE = as.data.frame(cbind(models_SSE, -->
<!--                                 Model_SSE_movedur, -->
<!--                                 Model_AIC_movedur, -->
<!--                                 Model_BIC_movedur, -->
<!--                                 Model_SSE_peakvel, -->
<!--                                 Model_AIC_peakvel, -->
<!--                                 Model_BIC_peakvel)) -->

<!-- colnames(Model_SSE) <- c('model', -->
<!--                          'Movement Duration SSE', -->
<!--                          'Movement Duration AIC', -->
<!--                          'Movement Duration BIC', -->
<!--                          'Peak Velocity SSE', -->
<!--                          'Peak Velocity AIC', -->
<!--                          'Peak Velocity BIC') -->

<!-- Model_SSE = filter(Model_SSE, -->
<!--                    model!='Pref', -->
<!--                    model!='Util_net', -->
<!--                    model!='m2', -->
<!--                    model!='m1', -->
<!--                    model!='Util_gross', -->
<!--                    model!='Util_net') -->

<!-- Model_SSE$model = c('Accuracy Prob', -->
<!--                     'Met Cost Gross', -->
<!--                     'Met Cost Net', -->
<!--                     'Torque^2', -->
<!--                     'Utility Gross', -->
<!--                     'Utility Net', -->
<!--                     'Utility Gross Combined Alpha', -->
<!--                     'Utility Net Combined Alpha') -->

<!-- colnames(Model_SSE) = c('Model', -->
<!--                         'Movement Duration SSE', -->
<!--                         'Movement Duration AIC', -->
<!--                         'Movement Duration BIC', -->
<!--                         'Peak Velocity SSE', -->
<!--                         'Peak Velocity AIC', -->
<!--                         'Peak Velocity BIC') -->
<!-- ``` -->

<!-- This table shows the SSE for the 2b movement duration and peak velocity predictions. These SSE's are calculated from only taking the predicted durations as before, and seeing how they compare to 2b. No new model fitting was done. -->

<!-- ```{r ModelSSE2ato2b, echo = FALSE, warning = FALSE, tab.cap = 'Exp 2b - Sum squared errors for movement duration and peak velocity.'} -->
<!-- kable(Model_SSE, caption = 'Exp 2b - Sum squared errors for movement duration and peak velocity.') -->
<!-- ``` -->

<!-- #### Normalized -->
<!-- ```{r, echo = FALSE, warning = FALSE} -->
<!-- # Noramlzied version -->
<!-- Model_SSE_movedur_norm = c() -->
<!-- Model_AIC_movedur_norm = c() -->
<!-- Model_BIC_movedur_norm = c() -->
<!-- Model_SSE_peakvel_norm = c() -->
<!-- Model_AIC_peakvel_norm = c() -->
<!-- Model_BIC_peakvel_norm = c() -->
<!-- Model_SSE_colnames_norm = c() -->
<!-- Model_SSE_norm = c() -->

<!-- for (model1 in models_SSE){ -->
<!--   if (model1 %in% c('Util_gross','Util_gross_rx','Util_net_rx','Util_net','Util_comb_alpha_gross','Util_comb_alpha_net')){ -->
<!--     n_params = 1 -->
<!--   } else { -->
<!--     n_params = 0 -->
<!--   } -->

<!--   model_movedur_temp1_norm = filter(model_durs,model==model1)$norm_durs -->
<!--   model_movedur_temp2_norm = aggregate(movedur~eff_mass,smalltdata,mean)$movedur/aggregate(movedur~eff_mass,smalltdata,mean)$movedur[1] -->
<!--   SSE = sum((model_movedur_temp1_norm-model_movedur_temp2_norm)^2) -->
<!--   Model_SSE_movedur_norm = rbind(Model_SSE_movedur_norm,SSE) -->

<!--   Model_AIC_movedur_norm = c(Model_AIC_movedur_norm, 4*log(SSE)-4*log(4)+2*(n_params+1)) -->
<!--   Model_BIC_movedur_norm = c(Model_BIC_movedur_norm, 4*log(SSE)-4*log(4)+log(4)*(n_params+1)) -->

<!--   model_peakvel_temp1_norm = filter(model_vels,model==model1)$norm_vels -->
<!--   model_peakvel_temp2_norm = aggregate(peakvel_target~eff_mass,smalltdata,mean)$movedur/aggregate(peakvel_target~eff_mass,smalltdata,mean)$peakvel_target[1] -->
<!--   SSE = sum((model_peakvel_temp1_norm-model_peakvel_temp2_norm)^2) -->
<!--   Model_SSE_peakvel_norm = rbind(Model_SSE_peakvel_norm,SSE) -->
<!--   # Model_SSE_colnames = rbind(Model_SSE_colnames,model1) -->

<!--   Model_AIC_peakvel_norm = c(Model_AIC_peakvel_norm, 4*log(SSE)-4*log(4)+2*(n_params+1)) -->
<!--   Model_BIC_peakvel_norm = c(Model_BIC_peakvel_norm, 4*log(SSE)-4*log(4)+log(4)*(n_params+1)) -->

<!-- } -->
<!-- Model_SSE_movedur_norm = formatC(Model_SSE_movedur_norm,format = 'e', digits = 3) -->
<!-- Model_SSE_peakvel_norm = formatC(Model_SSE_peakvel_norm,format = 'e', digits = 3) -->

<!-- Model_AIC_movedur_norm = formatC(Model_AIC_movedur_norm,format = 'e', digits = 2) -->
<!-- Model_BIC_movedur_norm = formatC(Model_BIC_movedur_norm,format = 'e', digits = 2) -->
<!-- Model_AIC_peakvel_norm = formatC(Model_AIC_peakvel_norm,format = 'e', digits = 2) -->
<!-- Model_BIC_peakvel_norm = formatC(Model_BIC_peakvel_norm,format = 'e', digits = 2) -->

<!-- Model_SSE_norm = as.data.frame(cbind(models_SSE, -->
<!--                                 Model_SSE_movedur_norm, -->
<!--                                 Model_AIC_movedur_norm, -->
<!--                                 Model_BIC_movedur_norm, -->
<!--                                 Model_SSE_peakvel_norm, -->
<!--                                 Model_AIC_peakvel_norm, -->
<!--                                 Model_BIC_peakvel_norm)) -->

<!-- colnames(Model_SSE_norm) <- c('model', -->
<!--                          'Movement Duration SSE', -->
<!--                          'Movement Duration AIC', -->
<!--                          'Movement Duration BIC', -->
<!--                          'Peak Velocity SSE', -->
<!--                          'Peak Velocity AIC', -->
<!--                          'Peak Velocity BIC') -->

<!-- Model_SSE_norm = filter(Model_SSE_norm, -->
<!--                         model!='Pref', -->
<!--                         model!='Util_net', -->
<!--                         model!='m2', -->
<!--                         model!='m1', -->
<!--                         model!='Util_gross', -->
<!--                         model!='Util_net') -->

<!-- Model_SSE_norm$model = c('Accuracy Prob', -->
<!--                     'Met Cost Gross', -->
<!--                     'Met Cost Net', -->
<!--                     'Torque^2', -->
<!--                     'Utility Gross', -->
<!--                     'Utility Net', -->
<!--                     'Utility Gross Combined Alpha', -->
<!--                     'Utility Net Combined Alpha') -->

<!-- colnames(Model_SSE_norm) = c('Model', -->
<!--                         'Movement Duration SSE', -->
<!--                         'Movement Duration AIC', -->
<!--                         'Movement Duration BIC', -->
<!--                         'Peak Velocity SSE', -->
<!--                         'Peak Velocity AIC', -->
<!--                         'Peak Velocity BIC') -->
<!-- ``` -->

<!-- ```{r ModelSSEnorm2ato2b, echo = FALSE, warning = FALSE, tab.cap = 'Exp 2b - Sum squared errors for NORMALIZED movement duration and peak velocity.'} -->
<!-- kable(Model_SSE_norm, caption = 'Exp 2b - Sum squared errors for NORMALIZED movement duration and peak velocity.') -->
<!-- ``` -->

<!-- ### SSE of models - Exp 2a  to 2c -->


<!-- #### Absolute -->

<!-- ```{r, echo = FALSE, warning = FALSE} -->

<!-- Model_SSE_movedur = c() -->
<!-- Model_AIC_movedur = c() -->
<!-- Model_BIC_movedur = c() -->
<!-- Model_SSE_peakvel = c() -->
<!-- Model_AIC_peakvel = c() -->
<!-- Model_BIC_peakvel = c() -->
<!-- Model_SSE_colnames = c() -->
<!-- Model_SSE = c() -->

<!-- for (model1 in models_SSE){ -->
<!--   if (model1 %in% c('Util_gross','Util_gross_rx','Util_net_rx','Util_net','Util_comb_alpha_gross','Util_comb_alpha_net')){ -->
<!--     n_params = 1 -->
<!--   } else { -->
<!--     n_params = 0 -->
<!--   } -->

<!--   model_movedur_temp1 = filter(model_durs,model==model1)$movedur -->
<!--   model_movedur_temp2 = aggregate(movedur~eff_mass,pilotdata,mean)$movedur -->
<!--   SSE = sum((model_movedur_temp1-model_movedur_temp2)^2) -->
<!--   Model_SSE_movedur = rbind(Model_SSE_movedur,SSE) -->

<!--   Model_AIC_movedur = c(Model_AIC_movedur, 4*log(SSE)-4*log(4)+2*(n_params+1)) -->
<!--   Model_BIC_movedur = c(Model_BIC_movedur, 4*log(SSE)-4*log(4)+log(4)*(n_params+1)) -->

<!--   model_peakvel_temp1 = filter(model_vels,model==model1)$peakvel -->
<!--   model_peakvel_temp2 = aggregate(peakvel_target~eff_mass,pilotdata,mean)$peakvel_target -->
<!--   SSE = sum((model_peakvel_temp1-model_peakvel_temp2)^2) -->
<!--   Model_SSE_peakvel = rbind(Model_SSE_peakvel,SSE) -->
<!--   # Model_SSE_colnames = rbind(Model_SSE_colnames,model1) -->

<!--   Model_AIC_peakvel = c(Model_AIC_peakvel, 4*log(SSE)-4*log(4)+2*(n_params+1)) -->
<!--   Model_BIC_peakvel = c(Model_BIC_peakvel, 4*log(SSE)-4*log(4)+log(4)*(n_params+1)) -->

<!-- } -->

<!-- Model_SSE_movedur = formatC(Model_SSE_movedur,format = 'e', digits = 3) -->
<!-- Model_SSE_peakvel = formatC(Model_SSE_peakvel,format = 'e', digits = 3) -->

<!-- Model_AIC_movedur = formatC(Model_AIC_movedur,format = 'e', digits = 2) -->
<!-- Model_BIC_movedur = formatC(Model_BIC_movedur,format = 'e', digits = 2) -->
<!-- Model_AIC_peakvel = formatC(Model_AIC_peakvel,format = 'e', digits = 2) -->
<!-- Model_BIC_peakvel = formatC(Model_BIC_peakvel,format = 'e', digits = 2) -->

<!-- Model_SSE = as.data.frame(cbind(models_SSE, -->
<!--                                 Model_SSE_movedur, -->
<!--                                 Model_AIC_movedur, -->
<!--                                 Model_BIC_movedur, -->
<!--                                 Model_SSE_peakvel, -->
<!--                                 Model_AIC_peakvel, -->
<!--                                 Model_BIC_peakvel)) -->

<!-- colnames(Model_SSE) <- c('model', -->
<!--                          'Movement Duration SSE', -->
<!--                          'Movement Duration AIC', -->
<!--                          'Movement Duration BIC', -->
<!--                          'Peak Velocity SSE', -->
<!--                          'Peak Velocity AIC', -->
<!--                          'Peak Velocity BIC') -->

<!-- Model_SSE = filter(Model_SSE, -->
<!--                    model!='Pref', -->
<!--                    model!='Util_net', -->
<!--                    model!='m2', -->
<!--                    model!='m1', -->
<!--                    model!='Util_gross', -->
<!--                    model!='Util_net') -->

<!-- Model_SSE$model = c('Accuracy Prob', -->
<!--                     'Met Cost Gross', -->
<!--                     'Met Cost Net', -->
<!--                     'Torque^2', -->
<!--                     'Utility Gross', -->
<!--                     'Utility Net', -->
<!--                     'Utility Gross Combined Alpha', -->
<!--                     'Utility Net Combined Alpha') -->

<!-- colnames(Model_SSE) = c('Model', -->
<!--                         'Movement Duration SSE', -->
<!--                         'Movement Duration AIC', -->
<!--                         'Movement Duration BIC', -->
<!--                         'Peak Velocity SSE', -->
<!--                         'Peak Velocity AIC', -->
<!--                         'Peak Velocity BIC') -->
<!-- ``` -->

<!-- This table shows the SSE for the 2c movement duration and peak velocity predictions. These SSE's are calculated from only taking the predicted durations as before, and seeing how they compare to 2b. No new model fitting was done. -->

<!-- ```{r ModelSSE2ato2c, echo = FALSE, warning = FALSE, tab.cap = 'Exp 2c - Sum squared errors for movement duration and peak velocity.'} -->
<!-- kable(Model_SSE, caption = 'Exp 2c - Sum squared errors for movement duration and peak velocity.') -->
<!-- ``` -->

<!-- #### Normalized -->

<!-- ```{r, echo = FALSE, warning = FALSE} -->
<!-- # Noramlzied version -->
<!-- Model_SSE_movedur_norm = c() -->
<!-- Model_AIC_movedur_norm = c() -->
<!-- Model_BIC_movedur_norm = c() -->
<!-- Model_SSE_peakvel_norm = c() -->
<!-- Model_AIC_peakvel_norm = c() -->
<!-- Model_BIC_peakvel_norm = c() -->
<!-- Model_SSE_colnames_norm = c() -->
<!-- Model_SSE_norm = c() -->

<!-- for (model1 in models_SSE){ -->
<!--   if (model1 %in% c('Util_gross','Util_gross_rx','Util_net_rx','Util_net','Util_comb_alpha_gross','Util_comb_alpha_net')){ -->
<!--     n_params = 1 -->
<!--   } else { -->
<!--     n_params = 0 -->
<!--   } -->

<!--   model_movedur_temp1_norm = filter(model_durs,model==model1)$norm_durs -->
<!--   model_movedur_temp2_norm = aggregate(movedur~eff_mass,pilotdata,mean)$movedur/aggregate(movedur~eff_mass,pilotdata,mean)$movedur[1] -->
<!--   SSE = sum((model_movedur_temp1_norm-model_movedur_temp2_norm)^2) -->
<!--   Model_SSE_movedur_norm = rbind(Model_SSE_movedur_norm,SSE) -->

<!--   Model_AIC_movedur_norm = c(Model_AIC_movedur_norm, 4*log(SSE)-4*log(4)+2*(n_params+1)) -->
<!--   Model_BIC_movedur_norm = c(Model_BIC_movedur_norm, 4*log(SSE)-4*log(4)+log(4)*(n_params+1)) -->

<!--   model_peakvel_temp1_norm = filter(model_vels,model==model1)$norm_vels -->
<!--   model_peakvel_temp2_norm = aggregate(peakvel_target~eff_mass,pilotdata,mean)$movedur/aggregate(peakvel_target~eff_mass,pilotdata,mean)$peakvel_target[1] -->
<!--   SSE = sum((model_peakvel_temp1_norm-model_peakvel_temp2_norm)^2) -->
<!--   Model_SSE_peakvel_norm = rbind(Model_SSE_peakvel_norm,SSE) -->
<!--   # Model_SSE_colnames = rbind(Model_SSE_colnames,model1) -->

<!--   Model_AIC_peakvel_norm = c(Model_AIC_peakvel_norm, 4*log(SSE)-4*log(4)+2*(n_params+1)) -->
<!--   Model_BIC_peakvel_norm = c(Model_BIC_peakvel_norm, 4*log(SSE)-4*log(4)+log(4)*(n_params+1)) -->

<!-- } -->
<!-- Model_SSE_movedur_norm = formatC(Model_SSE_movedur_norm,format = 'e', digits = 3) -->
<!-- Model_SSE_peakvel_norm = formatC(Model_SSE_peakvel_norm,format = 'e', digits = 3) -->

<!-- Model_AIC_movedur_norm = formatC(Model_AIC_movedur_norm,format = 'e', digits = 2) -->
<!-- Model_BIC_movedur_norm = formatC(Model_BIC_movedur_norm,format = 'e', digits = 2) -->
<!-- Model_AIC_peakvel_norm = formatC(Model_AIC_peakvel_norm,format = 'e', digits = 2) -->
<!-- Model_BIC_peakvel_norm = formatC(Model_BIC_peakvel_norm,format = 'e', digits = 2) -->

<!-- Model_SSE_norm = as.data.frame(cbind(models_SSE, -->
<!--                                 Model_SSE_movedur_norm, -->
<!--                                 Model_AIC_movedur_norm, -->
<!--                                 Model_BIC_movedur_norm, -->
<!--                                 Model_SSE_peakvel_norm, -->
<!--                                 Model_AIC_peakvel_norm, -->
<!--                                 Model_BIC_peakvel_norm)) -->

<!-- colnames(Model_SSE_norm) <- c('model', -->
<!--                          'Movement Duration SSE', -->
<!--                          'Movement Duration AIC', -->
<!--                          'Movement Duration BIC', -->
<!--                          'Peak Velocity SSE', -->
<!--                          'Peak Velocity AIC', -->
<!--                          'Peak Velocity BIC') -->

<!-- Model_SSE_norm = filter(Model_SSE_norm, -->
<!--                         model!='Pref', -->
<!--                         model!='Util_net', -->
<!--                         model!='m2', -->
<!--                         model!='m1', -->
<!--                         model!='Util_gross', -->
<!--                         model!='Util_net') -->

<!-- Model_SSE_norm$model = c('Accuracy Prob', -->
<!--                     'Met Cost Gross', -->
<!--                     'Met Cost Net', -->
<!--                     'Torque^2', -->
<!--                     'Utility Gross', -->
<!--                     'Utility Net', -->
<!--                     'Utility Gross Combined Alpha', -->
<!--                     'Utility Net Combined Alpha') -->

<!-- colnames(Model_SSE_norm) = c('Model', -->
<!--                         'Movement Duration SSE', -->
<!--                         'Movement Duration AIC', -->
<!--                         'Movement Duration BIC', -->
<!--                         'Peak Velocity SSE', -->
<!--                         'Peak Velocity AIC', -->
<!--                         'Peak Velocity BIC') -->
<!-- ``` -->

<!-- ```{r ModelSSEnorm2ato2c, echo = FALSE, warning = FALSE, tab.cap = 'Exp 2c - Sum squared errors for NORMALIZED movement duration and peak velocity.'} -->
<!-- kable(Model_SSE_norm, caption = 'Exp 2c - Sum squared errors for NORMALIZED movement duration and peak velocity.') -->
<!-- ``` -->
# 2b Durations

## DF Creation

```{r, echo = FALSE, warning = FALSE}

options(warn=-1)
# ================  Fitting Movement Duration
masses = unique(prefdata$eff_mass)
models = c('Smallt','MPNet_Cost','MGross_Cost','Utility','m1','Torque')
model_durs = data.frame('eff_mass' = cbind(rep(masses,13)),
                        # Change here for 2a/b/c
                        'model' = c(rep('Smallt',4),
                                    rep('MPNet_Cost',4),
                                    rep('MGross_cost',4),
                                    rep('Util_gross',4),
                                    rep('Util_net',4),
                                    # Change here for 2a/b/c
                                    rep('util_dur_smallt_gross',4),
                                    rep('util_dur_smallt_net',4),
  
                                    rep('Util_comb_alpha_gross',4),
                                    rep('Util_comb_alpha_net',4),
                                    rep('m1',4),
                                    rep('m2',4),
                                    rep('torque2',4),
                                    rep('accuracy',4)),
                        'movedur' = c(aggregate(movedur~eff_mass,smalltdata,mean)$movedur,
                                     met_net_dur,
                                     met_gross_dur,
                                     util_dur_gross,
                                     util_dur_net,
                                     # Change here for 2a/b/c
                                     util_dur_smallt_gross,
                                     util_dur_smallt_net,
  
                                     util_dur_pref_alpha_comb_gross[1:4],
                                     util_dur_pref_alpha_comb_net[1:4],
                                     m1_dur,
                                     m2_dur,
                                     torque_dur_2a,
                                     prob_dur_pref),
                        'modelnum' = c(rep(6,4),
                                      rep(5,4),
                                      rep(4,4),
                                      rep(7,4),
                                      rep(8,4),
                                      rep(9,4),
                                      rep(10,4),
                                      rep(11,4),
                                      rep(12,4),
                                      rep(1,4),
                                      rep(2,4),
                                      rep(3,4),
                                      rep(13,4)))

norm_durs = c()
for (c in 1:length(unique(model_durs$modelnum))){
  x = model_durs$movedur[seq(4*c-3,4*c)]/model_durs$movedur[4*c-3]
  norm_durs = c(norm_durs,x)
}
model_durs$norm_durs = norm_durs

model_labs = c(TeX('$Mass^1$'),
               TeX('$Mass^2$'),
               TeX('$Torque^2$'),
               TeX('Met Cost\nGross'),
               TeX('Met Cost\nNet'),
               TeX('Preferred\nDuration'),
               TeX('Utility Gross'),
               TeX('Utility Net'),
               TeX('Utility Gross'),
               TeX('Utility Net'),
               TeX('Utility Gross\nComb Alpha'),
               TeX('Utility Net\nComb Alpha'),
               TeX('Accuracy Prob'))
models_to_plot = c(3,4,5,6,9,10,11,12)
temp_durs = filter(model_durs, modelnum %in% models_to_plot)


```

## Peak Velocity Plotting

```{r, echo = FALSE, warning = FALSE}
#================  Peak Velocity Sim
min_jerk_vel <- function(t,d) (.1)*(30*(t/d)^2-60*(t/d)^3+30*(t/d)^4)
min_jerk_vel <- function(tm){
  ro = 0
  rf = 0.1
  dt=0.001
  
  tme=seq(0,tm,dt)
  ts=tme/tm
  
  t2=ts*ts
  t3=t2*ts
  t4=t3*ts
  t5=t4*ts
  
  v=((60*t3-30*t4-30*t2)/tm)*(ro-rf)
  return(max(v))
} 

t <- seq(0, 0.66, 0.01)

met_net_peakvel =c(0,0,0,0)
met_gross_peakvel = c(0,0,0,0)
util_peakvel_gross = c(0,0,0,0)
util_peakvel_net = c(0,0,0,0)
util_peakvel_gross_rx = c(0,0,0,0)
util_peakvel_net_rx = c(0,0,0,0)
util_peakvel_comb_alpha_gross = c(0,0,0,0)
util_peakvel_comb_alpha_net = c(0,0,0,0)
m1_peakvel = c(0,0,0,0)
m2_peakvel = c(0,0,0,0)
torque_peakvel = c(0,0,0,0)
accuracy_peakvel = c(0,0,0,0)
for (c in 1:4){
  met_net_peakvel[c] = min_jerk_vel(met_net_dur[c])
  met_gross_peakvel[c] = min_jerk_vel(met_gross_dur[c])
  util_peakvel_gross[c] = min_jerk_vel(util_dur_gross[c])
  util_peakvel_net[c] = min_jerk_vel(util_dur_net[c])
  # Change here for 2a/b/c
  util_peakvel_gross_rx[c] = min_jerk_vel(util_dur_smallt_gross[c])
  util_peakvel_net_rx[c] = min_jerk_vel(util_dur_smallt_net[c])
  
  util_peakvel_comb_alpha_gross[c] = min_jerk_vel(util_dur_pref_alpha_comb_gross[c])
  util_peakvel_comb_alpha_net[c] = min_jerk_vel(util_dur_pref_alpha_comb_net[c])
  m1_peakvel[c] = min_jerk_vel(m1_dur[c])
  m2_peakvel[c] = min_jerk_vel(m2_dur[c])
  torque_peakvel[c] = min_jerk_vel(torque_dur_2a[c])
  accuracy_peakvel[c] = min_jerk_vel(prob_dur_pref[c])
}

model_vels = data.frame('eff_mass' = cbind(rep(masses,13)),
                        # Change here for 2a/b/c
                        'model' = c(rep('Smallt',4),
                                    rep('MPNet_Cost',4),
                                    rep('MGross_cost',4),
                                    rep('Util_gross',4),
                                    rep('Util_net',4),
                                    # Change here for 2a/b/c
                                    rep('util_dur_smallt_gross',4),
                                    rep('util_dur_smallt_net',4),
                                    
                                    rep('Util_comb_alpha_gross',4),
                                    rep('Util_comb_alpha_net',4),
                                    rep('m1',4),
                                    rep('m2',4),
                                    rep('torque2',4),
                                    rep('accuracy',4)),
                        'peakvel' = c(aggregate(peakvel_target~eff_mass,smalltdata,mean)$peakvel_target,
                                      met_net_peakvel,
                                      met_gross_peakvel,
                                      util_peakvel_gross,
                                      util_peakvel_net,
                                      util_peakvel_gross_rx,
                                      util_peakvel_net_rx,
                                      
                                      util_peakvel_comb_alpha_gross,
                                      util_peakvel_comb_alpha_net,
                                      m1_peakvel,
                                      m2_peakvel,
                                      torque_peakvel,
                                      accuracy_peakvel),
                        'modelnum' = c(rep(6,4),
                                      rep(5,4),
                                      rep(4,4),
                                      rep(7,4),
                                      rep(8,4),
                                      rep(9,4),
                                      rep(10,4),
                                      rep(11,4),
                                      rep(12,4),
                                      rep(1,4),
                                      rep(2,4),
                                      rep(3,4),
                                      rep(13,4)))

norm_vels = c()
for (c in 1:length(unique(model_durs$modelnum))){
  x = model_vels$peakvel[seq(4*c-3,4*c)]/model_vels$peakvel[4*c-3]
  norm_vels = c(norm_vels,x)
}
model_vels$norm_vels = norm_vels
temp_vels = model_vels

```

## SSE of models - Exp 2b
The utility combined alpha is using the alpha value predicted off fitting a utility model to the preferred and small target experiement at the same time. This alpha value is used to make figure \@ref(fig:groupedutilitymovedur1).

### Absolute
```{r, echo = FALSE, warning = FALSE}

Model_SSE_movedur = c()
Model_AIC_movedur = c()
Model_BIC_movedur = c()
Model_SSE_peakvel = c()
Model_AIC_peakvel = c()
Model_BIC_peakvel = c()
Model_SSE_colnames = c()
Model_SSE = c()

models_SSE = c('m1',
               'm2',
               'accuracy',
               'MGross_cost',
               'MPNet_Cost',
               'torque2',
               'Util_gross',
               # Change here for 2a/b/c
               'util_dur_smallt_gross',
               'Util_net',
               'util_dur_smallt_net',
               'Util_comb_alpha_gross',
               'Util_comb_alpha_net',
               'Smallt')
for (model1 in models_SSE){
  # Change here for 2a/b/c
  if (model1 %in% c('Util_gross','util_dur_smallt_gross','util_dur_smallt_net','Util_net','Util_comb_alpha_gross','Util_comb_alpha_net')){
    n_params = 1
  } else {
    n_params = 0
  }
  
  model_movedur_temp1 = filter(model_durs,model==model1)$movedur
  # Change here for 2a/b/c
  model_movedur_temp2 = filter(model_durs,model=='Smallt')$movedur
  SSE = sum((model_movedur_temp1-model_movedur_temp2)^2)
  Model_SSE_movedur = rbind(Model_SSE_movedur,SSE)
  
  Model_AIC_movedur = c(Model_AIC_movedur, 4*log(SSE)-4*log(4)+2*(n_params+1))
  Model_BIC_movedur = c(Model_BIC_movedur, 4*log(SSE)-4*log(4)+log(4)*(n_params+1))
  
  model_peakvel_temp1 = filter(model_vels,model==model1)$peakvel
  # Change here for 2a/b/c
  model_peakvel_temp2 = filter(model_vels,model=='Smallt')$peakvel
  SSE = sum((model_peakvel_temp1-model_peakvel_temp2)^2)
  Model_SSE_peakvel = rbind(Model_SSE_peakvel,SSE)
  # Model_SSE_colnames = rbind(Model_SSE_colnames,model1)
  
  Model_AIC_peakvel = c(Model_AIC_peakvel, 4*log(SSE)-4*log(4)+2*(n_params+1))
  Model_BIC_peakvel = c(Model_BIC_peakvel, 4*log(SSE)-4*log(4)+log(4)*(n_params+1))
  
}

Model_SSE_movedur = formatC(Model_SSE_movedur,format = 'e', digits = 3)
Model_SSE_peakvel = formatC(Model_SSE_peakvel,format = 'e', digits = 3)

Model_AIC_movedur = formatC(Model_AIC_movedur,format = 'e', digits = 2)
Model_BIC_movedur = formatC(Model_BIC_movedur,format = 'e', digits = 2)
Model_AIC_peakvel = formatC(Model_AIC_peakvel,format = 'e', digits = 2)
Model_BIC_peakvel = formatC(Model_BIC_peakvel,format = 'e', digits = 2)

Model_SSE = as.data.frame(cbind(models_SSE,
                                Model_SSE_movedur,
                                Model_AIC_movedur,
                                Model_BIC_movedur,
                                Model_SSE_peakvel,
                                Model_AIC_peakvel,
                                Model_BIC_peakvel))

colnames(Model_SSE) <- c('model',
                         'Movement Duration SSE',
                         'Movement Duration AIC',
                         'Movement Duration BIC',
                         'Peak Velocity SSE',
                         'Peak Velocity AIC',
                         'Peak Velocity BIC')

Model_SSE = filter(Model_SSE,
                   model!='Smallt',
                   model!='Util_net',
                   model!='m2',
                   model!='m1',
                   model!='Util_gross',
                   model!='Util_net')

Model_SSE$model = c('Accuracy Prob',
                    'Met Cost Gross',
                    'Met Cost Net',
                    'Torque^2',
                    'Utility Gross',
                    'Utility Net',
                    'Utility Gross Combined Alpha',
                    'Utility Net Combined Alpha')

colnames(Model_SSE) = c('Model',
                        'Movement Duration SSE',
                        'Movement Duration AIC',
                        'Movement Duration BIC',
                        'Peak Velocity SSE',
                        'Peak Velocity AIC',
                        'Peak Velocity BIC')
```


This table shows the SSE for the 2b movement duration and peak velocity predictions.

```{r ModelSSE2b, echo = FALSE, warning = FALSE, tab.cap = 'Exp 2b - Sum squared errors for movement duration and peak velocity.'}
# Change here for 2a/b/c
kable(Model_SSE, caption = 'Exp 2b - Sum squared errors for movement duration and peak velocity.')
```

### Normalized

```{r, echo = FALSE, warning = FALSE}
# Noramlzied version
Model_SSE_movedur_norm = c()
Model_AIC_movedur_norm = c()
Model_BIC_movedur_norm = c()
Model_SSE_peakvel_norm = c()
Model_AIC_peakvel_norm = c()
Model_BIC_peakvel_norm = c()
Model_SSE_colnames_norm = c()
Model_SSE_norm = c()

for (model1 in models_SSE){
  # Change here for 2a/b/c
  if (model1 %in% c('Util_gross','util_dur_smallt_gross','util_dur_smallt_net','Util_net','Util_comb_alpha_gross','Util_comb_alpha_net')){
    n_params = 1
  } else {
    n_params = 0
  }
  
  model_movedur_temp1_norm = filter(model_durs,model==model1)$norm_durs
  # Change here for 2a/b/c
  model_movedur_temp2_norm = filter(model_durs,model=='Smallt')$norm_durs
  SSE = sum((model_movedur_temp1_norm-model_movedur_temp2_norm)^2)
  Model_SSE_movedur_norm = rbind(Model_SSE_movedur_norm,SSE)
  
  Model_AIC_movedur_norm = c(Model_AIC_movedur_norm, 4*log(SSE)-4*log(4)+2*(n_params+1))
  Model_BIC_movedur_norm = c(Model_BIC_movedur_norm, 4*log(SSE)-4*log(4)+log(4)*(n_params+1))
  
  model_peakvel_temp1_norm = filter(model_vels,model==model1)$norm_vels
  # Change here for 2a/b/c
  model_peakvel_temp2_norm = filter(model_vels,model=='Smallt')$norm_vels
  SSE = sum((model_peakvel_temp1_norm-model_peakvel_temp2_norm)^2)
  Model_SSE_peakvel_norm = rbind(Model_SSE_peakvel_norm,SSE)
  # Model_SSE_colnames = rbind(Model_SSE_colnames,model1)
  
  Model_AIC_peakvel_norm = c(Model_AIC_peakvel_norm, 4*log(SSE)-4*log(4)+2*(n_params+1))
  Model_BIC_peakvel_norm = c(Model_BIC_peakvel_norm, 4*log(SSE)-4*log(4)+log(4)*(n_params+1))
  
}
Model_SSE_movedur_norm = formatC(Model_SSE_movedur_norm,format = 'e', digits = 3)
Model_SSE_peakvel_norm = formatC(Model_SSE_peakvel_norm,format = 'e', digits = 3)

Model_AIC_movedur_norm = formatC(Model_AIC_movedur_norm,format = 'e', digits = 2)
Model_BIC_movedur_norm = formatC(Model_BIC_movedur_norm,format = 'e', digits = 2)
Model_AIC_peakvel_norm = formatC(Model_AIC_peakvel_norm,format = 'e', digits = 2)
Model_BIC_peakvel_norm = formatC(Model_BIC_peakvel_norm,format = 'e', digits = 2)

Model_SSE_norm = as.data.frame(cbind(models_SSE,
                                Model_SSE_movedur_norm,
                                Model_AIC_movedur_norm,
                                Model_BIC_movedur_norm,
                                Model_SSE_peakvel_norm,
                                Model_AIC_peakvel_norm,
                                Model_BIC_peakvel_norm))

colnames(Model_SSE_norm) <- c('model',
                         'Movement Duration SSE',
                         'Movement Duration AIC',
                         'Movement Duration BIC',
                         'Peak Velocity SSE',
                         'Peak Velocity AIC',
                         'Peak Velocity BIC')

Model_SSE_norm = filter(Model_SSE_norm,
                        model!='Smallt',
                        model!='Util_net',
                        model!='m2',
                        model!='m1',
                        model!='Util_gross',
                        model!='Util_net')

Model_SSE_norm$model = c('Accuracy Prob',
                    'Met Cost Gross',
                    'Met Cost Net',
                    'Torque^2',
                    'Utility Gross',
                    'Utility Net',
                    'Utility Gross Combined Alpha',
                    'Utility Net Combined Alpha')

colnames(Model_SSE_norm) = c('Model',
                        'Movement Duration SSE',
                        'Movement Duration AIC',
                        'Movement Duration BIC',
                        'Peak Velocity SSE',
                        'Peak Velocity AIC',
                        'Peak Velocity BIC')
```

```{r ModelSSEnorm2b, echo = FALSE, warning = FALSE, tab.cap = 'Exp 2a - Sum squared errors for NORMALIZED movement duration and peak velocity.'}
kable(Model_SSE_norm, caption = 'Exp 2a - Sum squared errors for NORMALIZED movement duration and peak velocity.')
```


## 2b Modeling Plot

```{r, echo = FALSE, warning = FALSE, fig.cap = 'Modeled movement durations and peak velocities.'}
## Making the Model Group plot

## Movement Duration
theme_set(theme_cowplot(font_size=12))

errbar = cbind(aggregate(movedur~eff_mass,smalltdata,mean),
               aggregate(movedur~eff_mass,smalltdata,sd)[2]/sqrt(length(unique(smalltdata$subj))))
colnames(errbar) = c('eff_mass','movedur','sd')

Model_movedur_shape <- model_plotting('movedur','Movement Duration (s)',temp_durs,errbar,'shape',normalized = 0)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))

Model_movedur_color <- model_plotting('movedur','Movement Duration (s)',temp_durs,errbar,'color',normalized = 0)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))

# setwd(pref_plots_dir)
# if (save_plots){ggsave('Model_movedur_shape.pdf',plot=Model_movedur_shape, useDingbats = FALSE)}


temp_durs = model_durs
temp_durs = filter(model_durs, modelnum %in% models_to_plot)

errbar = cbind(aggregate(movedurnorm~eff_mass,smalltdata,mean),
               aggregate(movedurnorm~eff_mass,smalltdata,sd)[2]/sqrt(length(unique(smalltdata$subj))))
colnames(errbar) = c('eff_mass','norm_durs','sd')

Model_normmovedur_shape <- model_plotting('norm_durs','Norm Movement Duration (s)',temp_durs,errbar,'shape',normalized = 1)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))
Model_normmovedur_color <- model_plotting('norm_durs','Norm Movement Duration (s)',temp_durs,errbar,'color',normalized = 1)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))

## Peak Velocity

temp_vels = model_vels
temp_vels = filter(temp_vels, modelnum %in% models_to_plot)


errbar = cbind(aggregate(peakvel_target~eff_mass,smalltdata,mean),
               aggregate(peakvel_target~eff_mass,smalltdata,sd)[2]/sqrt(length(unique(smalltdata$subj))))
colnames(errbar) = c('eff_mass','peakvel','sd')

Model_peakvel_shape <- model_plotting('peakvel','Peak Velocity (m/s)',
                                      temp_vels,errbar,'shape',normalized = 0)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))
Model_peakvel_color <- model_plotting('peakvel','Peak Velocity (m/s)',
                                      temp_vels,errbar,'color',normalized = 0)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))


# setwd(pref_plots_dir)
# if (save_plots){ggsave('Model_peakvel_shape.pdf',plot=Model_peakvel_shape,useDingbats = FALSE)}

norm_vels = c()
for (c in 1:length(unique(model_durs$modelnum))){
  x = model_vels$peakvel[seq(4*c-3,4*c)]/model_vels$peakvel[4*c-3]
  norm_vels = c(norm_vels,x)
}
model_vels$norm_vels = norm_vels
temp_vels = model_vels

temp_vels = model_vels
temp_vels = filter(temp_vels, modelnum %in% models_to_plot)

errbar = cbind(aggregate(peakvelnorm~eff_mass,smalltdata,mean),
               aggregate(peakvelnorm~eff_mass,smalltdata,sd)[2]/sqrt(length(unique(smalltdata$subj))))
colnames(errbar) = c('eff_mass','norm_vels','sd')

Model_normpeakvel_shape <- model_plotting('norm_vels','Norm Peak Velocity (m/s)',
                                          temp_vels,errbar,'shape',normalized = 1)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))
Model_normpeakvel_color <- model_plotting('norm_vels','Norm Velocity (m/s)',
                                          temp_vels,errbar,'color',normalized = 1)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))

# setwd(pref_plots_dir)
# if (save_plots){ggsave('Model_peakvelnorm_shape.pdf',plot=Model_normpeakvel_shape,useDingbats = FALSE)}

## Grouping

add_legend_shape <- get_legend(Model_movedur_shape)
add_legend_color <- get_legend(Model_movedur_color)

plots_to_fix = c('Model_movedur_shape',
                 'Model_normmovedur_shape',
                 'Model_peakvel_shape',
                 'Model_normpeakvel_shape',
                 'Model_movedur_color',
                 'Model_normmovedur_color',
                 'Model_peakvel_color',
                 'Model_normpeakvel_color')

for (plot in plots_to_fix){
  string = paste(plot,'<-',plot,'+
                 # theme_classic()
                 theme(text        = element_text(size = 16, color=\'black\'),
                 axis.text         = element_text(color=\'black\'),
                 axis.ticks        = element_line(color=\'black\'),
                 plot.title        = element_text(hjust = 0.5),
                 axis.line         = element_line(color=\'black\'),
                 legend.position   = \'none\')',sep = '')
  eval(parse(text = string))
}

Results_model_r_shape <- plot_grid(Model_movedur_shape+theme(legend.position='none'),
         Model_normmovedur_shape+theme(legend.position='none'),
         Model_peakvel_shape+theme(legend.position='none'),
         Model_normpeakvel_shape+theme(legend.position='none'),
         nrow = 2,
         hjust = -1,
         labels = c('A','B','C','D'),
         label_size = 20,
         align = 'vh')
Results_model_r_shape<-plot_grid(Results_model_r_shape,add_legend_shape,nrow=1,rel_widths = c(.85,.15))

setwd(pref_plots_dir)
if (save_plots){ggsave('Results_model_r_shape.pdf',plot = Results_model_r_shape, height = 8, width = 8/.85, useDingbats = FALSE)}

Results_model_r_color <- plot_grid(Model_movedur_color+theme(legend.position='none'),
         Model_normmovedur_color+theme(legend.position='none'),
         Model_peakvel_color+theme(legend.position='none'),
         Model_normpeakvel_color+theme(legend.position='none'),
         nrow = 2,
         hjust = -1,
         labels = c('A','B','C','D'),
         label_size = 20,
         align = 'vh')
Results_model_r_color<-plot_grid(Results_model_r_color,add_legend_color,nrow=1,rel_widths = c(.85,.15))

# setwd(pref_plots_dir)
# if (save_plots){ggsave('Results_model_r_color.pdf',plot = Results_model_r_color, height = 8, width = 8/.85, useDingbats = FALSE)}
options(warn=0)
```

```{r Resultsmodelrshape2b, echo = FALSE, fig.width=9, fig.height=6, fig.cap = 'Modeling Results'}
Results_model_r_shape
```


<!-- ### SSE of models - Exp 2b to 2a -->

<!-- #### Absolute -->
<!-- ```{r, echo = FALSE, warning = FALSE} -->

<!-- Model_SSE_movedur = c() -->
<!-- Model_AIC_movedur = c() -->
<!-- Model_BIC_movedur = c() -->
<!-- Model_SSE_peakvel = c() -->
<!-- Model_AIC_peakvel = c() -->
<!-- Model_BIC_peakvel = c() -->
<!-- Model_SSE_colnames = c() -->
<!-- Model_SSE = c() -->


<!-- for (model1 in models_SSE){ -->
<!--   # Change here for 2a/b/c -->
<!--   if (model1 %in% c('Util_gross','util_dur_smallt_gross','util_dur_smallt_net','Util_net','Util_comb_alpha_gross','Util_comb_alpha_net')){ -->
<!--     n_params = 1 -->
<!--   } else { -->
<!--     n_params = 0 -->
<!--   } -->

<!--   model_movedur_temp1 = filter(model_durs,model==model1)$movedur -->
<!--   # Change here for 2a/b/c -->
<!--   model_movedur_temp2 = aggregate(movedur~eff_mass,prefdata,mean)$movedur -->
<!--   SSE = sum((model_movedur_temp1-model_movedur_temp2)^2) -->
<!--   Model_SSE_movedur = rbind(Model_SSE_movedur,SSE) -->

<!--   Model_AIC_movedur = c(Model_AIC_movedur, 4*log(SSE)-4*log(4)+2*(n_params+1)) -->
<!--   Model_BIC_movedur = c(Model_BIC_movedur, 4*log(SSE)-4*log(4)+log(4)*(n_params+1)) -->

<!--   model_peakvel_temp1 = filter(model_vels,model==model1)$peakvel -->
<!--   # Change here for 2a/b/c -->
<!--   model_peakvel_temp2 = aggregate(peakvel_target~eff_mass,prefdata,mean)$peakvel_target -->
<!--   SSE = sum((model_peakvel_temp1-model_peakvel_temp2)^2) -->
<!--   Model_SSE_peakvel = rbind(Model_SSE_peakvel,SSE) -->

<!--   Model_AIC_peakvel = c(Model_AIC_peakvel, 4*log(SSE)-4*log(4)+2*(n_params+1)) -->
<!--   Model_BIC_peakvel = c(Model_BIC_peakvel, 4*log(SSE)-4*log(4)+log(4)*(n_params+1)) -->

<!-- } -->

<!-- Model_SSE_movedur = formatC(Model_SSE_movedur,format = 'e', digits = 3) -->
<!-- Model_SSE_peakvel = formatC(Model_SSE_peakvel,format = 'e', digits = 3) -->

<!-- Model_AIC_movedur = formatC(Model_AIC_movedur,format = 'e', digits = 2) -->
<!-- Model_BIC_movedur = formatC(Model_BIC_movedur,format = 'e', digits = 2) -->
<!-- Model_AIC_peakvel = formatC(Model_AIC_peakvel,format = 'e', digits = 2) -->
<!-- Model_BIC_peakvel = formatC(Model_BIC_peakvel,format = 'e', digits = 2) -->

<!-- Model_SSE = as.data.frame(cbind(models_SSE, -->
<!--                                 Model_SSE_movedur, -->
<!--                                 Model_AIC_movedur, -->
<!--                                 Model_BIC_movedur, -->
<!--                                 Model_SSE_peakvel, -->
<!--                                 Model_AIC_peakvel, -->
<!--                                 Model_BIC_peakvel)) -->

<!-- colnames(Model_SSE) <- c('model', -->
<!--                          'Movement Duration SSE', -->
<!--                          'Movement Duration AIC', -->
<!--                          'Movement Duration BIC', -->
<!--                          'Peak Velocity SSE', -->
<!--                          'Peak Velocity AIC', -->
<!--                          'Peak Velocity BIC') -->

<!-- Model_SSE = filter(Model_SSE, -->
<!--                    model!='Smallt', -->
<!--                    model!='Util_net', -->
<!--                    model!='m2', -->
<!--                    model!='m1', -->
<!--                    model!='Util_gross', -->
<!--                    model!='Util_net') -->

<!-- Model_SSE$model = c('Accuracy Prob', -->
<!--                     'Met Cost Gross', -->
<!--                     'Met Cost Net', -->
<!--                     'Torque^2', -->
<!--                     'Utility Gross', -->
<!--                     'Utility Net', -->
<!--                     'Utility Gross Combined Alpha', -->
<!--                     'Utility Net Combined Alpha') -->

<!-- colnames(Model_SSE) = c('Model', -->
<!--                         'Movement Duration SSE', -->
<!--                         'Movement Duration AIC', -->
<!--                         'Movement Duration BIC', -->
<!--                         'Peak Velocity SSE', -->
<!--                         'Peak Velocity AIC', -->
<!--                         'Peak Velocity BIC') -->
<!-- ``` -->

<!-- This table shows the SSE for the 2b movement duration and peak velocity predictions. These SSE's are calculated from only taking the predicted durations as before, and seeing how they compare to 2b. No new model fitting was done. -->

<!-- ```{r ModelSSE2bto2a, echo = FALSE, warning = FALSE, tab.cap = 'Exp 2b - Sum squared errors for movement duration and peak velocity.'} -->
<!-- kable(Model_SSE, caption = 'Exp 2b - Sum squared errors for movement duration and peak velocity.') -->
<!-- ``` -->


<!-- #### Normalized -->
<!-- ```{r, echo = FALSE, warning = FALSE} -->
<!-- # Noramlzied version -->
<!-- Model_SSE_movedur_norm = c() -->
<!-- Model_AIC_movedur_norm = c() -->
<!-- Model_BIC_movedur_norm = c() -->
<!-- Model_SSE_peakvel_norm = c() -->
<!-- Model_AIC_peakvel_norm = c() -->
<!-- Model_BIC_peakvel_norm = c() -->
<!-- Model_SSE_colnames_norm = c() -->
<!-- Model_SSE_norm = c() -->

<!-- for (model1 in models_SSE){ -->
<!--   # Change here for 2a/b/c -->
<!--   if (model1 %in% c('Util_gross','util_dur_smallt_gross','util_dur_smallt_net','Util_net','Util_comb_alpha_gross','Util_comb_alpha_net')){ -->
<!--     n_params = 1 -->
<!--   } else { -->
<!--     n_params = 0 -->
<!--   } -->

<!--   model_movedur_temp1_norm = filter(model_durs,model==model1)$norm_durs -->
<!--   # Change here for 2a/b/c -->
<!--   model_movedur_temp2_norm = aggregate(movedur~eff_mass,prefdata,mean)$movedur/aggregate(movedur~eff_mass,prefdata,mean)$movedur[1] -->
<!--   SSE = sum((model_movedur_temp1_norm-model_movedur_temp2_norm)^2) -->
<!--   Model_SSE_movedur_norm = rbind(Model_SSE_movedur_norm,SSE) -->

<!--   Model_AIC_movedur_norm = c(Model_AIC_movedur_norm, 4*log(SSE)-4*log(4)+2*(n_params+1)) -->
<!--   Model_BIC_movedur_norm = c(Model_BIC_movedur_norm, 4*log(SSE)-4*log(4)+log(4)*(n_params+1)) -->

<!--   model_peakvel_temp1_norm = filter(model_vels,model==model1)$norm_vels -->
<!--   # Change here for 2a/b/c -->
<!--   model_peakvel_temp2_norm = aggregate(peakvel_target~eff_mass,prefdata,mean)$peakvel_target/aggregate(peakvel_target~eff_mass,prefdata,mean)$peakvel_target[1] -->
<!--   SSE = sum((model_peakvel_temp1_norm-model_peakvel_temp2_norm)^2) -->
<!--   Model_SSE_peakvel_norm = rbind(Model_SSE_peakvel_norm,SSE) -->
<!--   # Model_SSE_colnames = rbind(Model_SSE_colnames,model1) -->

<!--   Model_AIC_peakvel_norm = c(Model_AIC_peakvel_norm, 4*log(SSE)-4*log(4)+2*(n_params+1)) -->
<!--   Model_BIC_peakvel_norm = c(Model_BIC_peakvel_norm, 4*log(SSE)-4*log(4)+log(4)*(n_params+1)) -->

<!-- } -->
<!-- Model_SSE_movedur_norm = formatC(Model_SSE_movedur_norm,format = 'e', digits = 3) -->
<!-- Model_SSE_peakvel_norm = formatC(Model_SSE_peakvel_norm,format = 'e', digits = 3) -->

<!-- Model_AIC_movedur_norm = formatC(Model_AIC_movedur_norm,format = 'e', digits = 2) -->
<!-- Model_BIC_movedur_norm = formatC(Model_BIC_movedur_norm,format = 'e', digits = 2) -->
<!-- Model_AIC_peakvel_norm = formatC(Model_AIC_peakvel_norm,format = 'e', digits = 2) -->
<!-- Model_BIC_peakvel_norm = formatC(Model_BIC_peakvel_norm,format = 'e', digits = 2) -->

<!-- Model_SSE_norm = as.data.frame(cbind(models_SSE, -->
<!--                                 Model_SSE_movedur_norm, -->
<!--                                 Model_AIC_movedur_norm, -->
<!--                                 Model_BIC_movedur_norm, -->
<!--                                 Model_SSE_peakvel_norm, -->
<!--                                 Model_AIC_peakvel_norm, -->
<!--                                 Model_BIC_peakvel_norm)) -->

<!-- colnames(Model_SSE_norm) <- c('model', -->
<!--                          'Movement Duration SSE', -->
<!--                          'Movement Duration AIC', -->
<!--                          'Movement Duration BIC', -->
<!--                          'Peak Velocity SSE', -->
<!--                          'Peak Velocity AIC', -->
<!--                          'Peak Velocity BIC') -->

<!-- Model_SSE_norm = filter(Model_SSE_norm, -->
<!--                         model!='Smallt', -->
<!--                         model!='Util_net', -->
<!--                         model!='m2', -->
<!--                         model!='m1', -->
<!--                         model!='Util_gross', -->
<!--                         model!='Util_net') -->

<!-- Model_SSE_norm$model = c('Accuracy Prob', -->
<!--                     'Met Cost Gross', -->
<!--                     'Met Cost Net', -->
<!--                     'Torque^2', -->
<!--                     'Utility Gross', -->
<!--                     'Utility Net', -->
<!--                     'Utility Gross Combined Alpha', -->
<!--                     'Utility Net Combined Alpha') -->

<!-- colnames(Model_SSE_norm) = c('Model', -->
<!--                         'Movement Duration SSE', -->
<!--                         'Movement Duration AIC', -->
<!--                         'Movement Duration BIC', -->
<!--                         'Peak Velocity SSE', -->
<!--                         'Peak Velocity AIC', -->
<!--                         'Peak Velocity BIC') -->
<!-- ``` -->

<!-- ```{r ModelSSEnorm2bto2a, echo = FALSE, warning = FALSE, tab.cap = 'Exp 2b - Sum squared errors for NORMALIZED movement duration and peak velocity.'} -->
<!-- kable(Model_SSE_norm, caption = 'Exp 2b - Sum squared errors for NORMALIZED movement duration and peak velocity.') -->
<!-- ``` -->

<!-- ### SSE of models - Exp 2b to 2c -->

<!-- #### Absolute -->

<!-- ```{r, echo = FALSE, warning = FALSE} -->

<!-- Model_SSE_movedur = c() -->
<!-- Model_AIC_movedur = c() -->
<!-- Model_BIC_movedur = c() -->
<!-- Model_SSE_peakvel = c() -->
<!-- Model_AIC_peakvel = c() -->
<!-- Model_BIC_peakvel = c() -->
<!-- Model_SSE_colnames = c() -->
<!-- Model_SSE = c() -->

<!-- for (model1 in models_SSE){ -->
<!--   # Change here for 2a/b/c -->
<!--   if (model1 %in% c('Util_gross','util_dur_smallt_gross','util_dur_smallt_net','Util_net','Util_comb_alpha_gross','Util_comb_alpha_net')){ -->
<!--     n_params = 1 -->
<!--   } else { -->
<!--     n_params = 0 -->
<!--   } -->

<!--   model_movedur_temp1 = filter(model_durs,model==model1)$movedur -->
<!--   # Change here for 2a/b/c -->
<!--   model_movedur_temp2 = aggregate(movedur~eff_mass,pilotdata,mean)$movedur -->
<!--   SSE = sum((model_movedur_temp1-model_movedur_temp2)^2) -->
<!--   Model_SSE_movedur = rbind(Model_SSE_movedur,SSE) -->

<!--   Model_AIC_movedur = c(Model_AIC_movedur, 4*log(SSE)-4*log(4)+2*(n_params+1)) -->
<!--   Model_BIC_movedur = c(Model_BIC_movedur, 4*log(SSE)-4*log(4)+log(4)*(n_params+1)) -->

<!--   model_peakvel_temp1 = filter(model_vels,model==model1)$peakvel -->
<!--   # Change here for 2a/b/c -->
<!--   model_peakvel_temp2 = aggregate(peakvel_target~eff_mass,pilotdata,mean)$peakvel_target -->
<!--   SSE = sum((model_peakvel_temp1-model_peakvel_temp2)^2) -->
<!--   Model_SSE_peakvel = rbind(Model_SSE_peakvel,SSE) -->
<!--   # Model_SSE_colnames = rbind(Model_SSE_colnames,model1) -->

<!--   Model_AIC_peakvel = c(Model_AIC_peakvel, 4*log(SSE)-4*log(4)+2*(n_params+1)) -->
<!--   Model_BIC_peakvel = c(Model_BIC_peakvel, 4*log(SSE)-4*log(4)+log(4)*(n_params+1)) -->

<!-- } -->

<!-- Model_SSE_movedur = formatC(Model_SSE_movedur,format = 'e', digits = 3) -->
<!-- Model_SSE_peakvel = formatC(Model_SSE_peakvel,format = 'e', digits = 3) -->

<!-- Model_AIC_movedur = formatC(Model_AIC_movedur,format = 'e', digits = 2) -->
<!-- Model_BIC_movedur = formatC(Model_BIC_movedur,format = 'e', digits = 2) -->
<!-- Model_AIC_peakvel = formatC(Model_AIC_peakvel,format = 'e', digits = 2) -->
<!-- Model_BIC_peakvel = formatC(Model_BIC_peakvel,format = 'e', digits = 2) -->

<!-- Model_SSE = as.data.frame(cbind(models_SSE, -->
<!--                                 Model_SSE_movedur, -->
<!--                                 Model_AIC_movedur, -->
<!--                                 Model_BIC_movedur, -->
<!--                                 Model_SSE_peakvel, -->
<!--                                 Model_AIC_peakvel, -->
<!--                                 Model_BIC_peakvel)) -->

<!-- colnames(Model_SSE) <- c('model', -->
<!--                          'Movement Duration SSE', -->
<!--                          'Movement Duration AIC', -->
<!--                          'Movement Duration BIC', -->
<!--                          'Peak Velocity SSE', -->
<!--                          'Peak Velocity AIC', -->
<!--                          'Peak Velocity BIC') -->

<!-- Model_SSE = filter(Model_SSE, -->
<!--                    model!='Smallt', -->
<!--                    model!='Util_net', -->
<!--                    model!='m2', -->
<!--                    model!='m1', -->
<!--                    model!='Util_gross', -->
<!--                    model!='Util_net') -->

<!-- Model_SSE$model = c('Accuracy Prob', -->
<!--                     'Met Cost Gross', -->
<!--                     'Met Cost Net', -->
<!--                     'Torque^2', -->
<!--                     'Utility Gross', -->
<!--                     'Utility Net', -->
<!--                     'Utility Gross Combined Alpha', -->
<!--                     'Utility Net Combined Alpha') -->

<!-- colnames(Model_SSE) = c('Model', -->
<!--                         'Movement Duration SSE', -->
<!--                         'Movement Duration AIC', -->
<!--                         'Movement Duration BIC', -->
<!--                         'Peak Velocity SSE', -->
<!--                         'Peak Velocity AIC', -->
<!--                         'Peak Velocity BIC') -->
<!-- ``` -->

<!-- This table shows the SSE for the 2c movement duration and peak velocity predictions. These SSE's are calculated from only taking the predicted durations as before, and seeing how they compare to 2b. No new model fitting was done. -->

<!-- ```{r ModelSSE2bto2c, echo = FALSE, warning = FALSE, tab.cap = 'Exp 2c - Sum squared errors for movement duration and peak velocity.'} -->
<!-- kable(Model_SSE, caption = 'Exp 2c - Sum squared errors for movement duration and peak velocity.') -->
<!-- ``` -->

<!-- #### Normalized -->

<!-- ```{r, echo = FALSE, warning = FALSE} -->
<!-- # Noramlzied version -->
<!-- Model_SSE_movedur_norm = c() -->
<!-- Model_AIC_movedur_norm = c() -->
<!-- Model_BIC_movedur_norm = c() -->
<!-- Model_SSE_peakvel_norm = c() -->
<!-- Model_AIC_peakvel_norm = c() -->
<!-- Model_BIC_peakvel_norm = c() -->
<!-- Model_SSE_colnames_norm = c() -->
<!-- Model_SSE_norm = c() -->

<!-- for (model1 in models_SSE){ -->
<!--   # Change here for 2a/b/c -->
<!--   if (model1 %in% c('Util_gross','util_dur_smallt_gross','util_dur_smallt_net','Util_net','Util_comb_alpha_gross','Util_comb_alpha_net')){ -->
<!--     n_params = 1 -->
<!--   } else { -->
<!--     n_params = 0 -->
<!--   } -->

<!--   model_movedur_temp1_norm = filter(model_durs,model==model1)$norm_durs -->
<!--   # Change here for 2a/b/c -->
<!--   model_movedur_temp2_norm = aggregate(movedur~eff_mass,pilotdata,mean)$movedur/aggregate(movedur~eff_mass,pilotdata,mean)$movedur[1] -->
<!--   SSE = sum((model_movedur_temp1_norm-model_movedur_temp2_norm)^2) -->
<!--   Model_SSE_movedur_norm = rbind(Model_SSE_movedur_norm,SSE) -->

<!--   Model_AIC_movedur_norm = c(Model_AIC_movedur_norm, 4*log(SSE)-4*log(4)+2*(n_params+1)) -->
<!--   Model_BIC_movedur_norm = c(Model_BIC_movedur_norm, 4*log(SSE)-4*log(4)+log(4)*(n_params+1)) -->

<!--   model_peakvel_temp1_norm = filter(model_vels,model==model1)$norm_vels -->
<!--   # Change here for 2a/b/c -->
<!--   model_peakvel_temp2_norm = aggregate(peakvel_target~eff_mass,pilotdata,mean)$peakvel_target/aggregate(peakvel_target~eff_mass,pilotdata,mean)$peakvel_target[1] -->
<!--   SSE = sum((model_peakvel_temp1_norm-model_peakvel_temp2_norm)^2) -->
<!--   Model_SSE_peakvel_norm = rbind(Model_SSE_peakvel_norm,SSE) -->
<!--   # Model_SSE_colnames = rbind(Model_SSE_colnames,model1) -->

<!--   Model_AIC_peakvel_norm = c(Model_AIC_peakvel_norm, 4*log(SSE)-4*log(4)+2*(n_params+1)) -->
<!--   Model_BIC_peakvel_norm = c(Model_BIC_peakvel_norm, 4*log(SSE)-4*log(4)+log(4)*(n_params+1)) -->

<!-- } -->
<!-- Model_SSE_movedur_norm = formatC(Model_SSE_movedur_norm,format = 'e', digits = 3) -->
<!-- Model_SSE_peakvel_norm = formatC(Model_SSE_peakvel_norm,format = 'e', digits = 3) -->

<!-- Model_AIC_movedur_norm = formatC(Model_AIC_movedur_norm,format = 'e', digits = 2) -->
<!-- Model_BIC_movedur_norm = formatC(Model_BIC_movedur_norm,format = 'e', digits = 2) -->
<!-- Model_AIC_peakvel_norm = formatC(Model_AIC_peakvel_norm,format = 'e', digits = 2) -->
<!-- Model_BIC_peakvel_norm = formatC(Model_BIC_peakvel_norm,format = 'e', digits = 2) -->

<!-- Model_SSE_norm = as.data.frame(cbind(models_SSE, -->
<!--                                 Model_SSE_movedur_norm, -->
<!--                                 Model_AIC_movedur_norm, -->
<!--                                 Model_BIC_movedur_norm, -->
<!--                                 Model_SSE_peakvel_norm, -->
<!--                                 Model_AIC_peakvel_norm, -->
<!--                                 Model_BIC_peakvel_norm)) -->

<!-- colnames(Model_SSE_norm) <- c('model', -->
<!--                          'Movement Duration SSE', -->
<!--                          'Movement Duration AIC', -->
<!--                          'Movement Duration BIC', -->
<!--                          'Peak Velocity SSE', -->
<!--                          'Peak Velocity AIC', -->
<!--                          'Peak Velocity BIC') -->

<!-- Model_SSE_norm = filter(Model_SSE_norm, -->
<!--                         model!='Smallt', -->
<!--                         model!='Util_net', -->
<!--                         model!='m2', -->
<!--                         model!='m1', -->
<!--                         model!='Util_gross', -->
<!--                         model!='Util_net') -->

<!-- Model_SSE_norm$model = c('Accuracy Prob', -->
<!--                     'Met Cost Gross', -->
<!--                     'Met Cost Net', -->
<!--                     'Torque^2', -->
<!--                     'Utility Gross', -->
<!--                     'Utility Net', -->
<!--                     'Utility Gross Combined Alpha', -->
<!--                     'Utility Net Combined Alpha') -->

<!-- colnames(Model_SSE_norm) = c('Model', -->
<!--                         'Movement Duration SSE', -->
<!--                         'Movement Duration AIC', -->
<!--                         'Movement Duration BIC', -->
<!--                         'Peak Velocity SSE', -->
<!--                         'Peak Velocity AIC', -->
<!--                         'Peak Velocity BIC') -->
<!-- ``` -->

<!-- ```{r ModelSSEnorm2bto2c, echo = FALSE, warning = FALSE, tab.cap = 'Exp 2c - Sum squared errors for NORMALIZED movement duration and peak velocity.'} -->
<!-- kable(Model_SSE_norm, caption = 'Exp 2c - Sum squared errors for NORMALIZED movement duration and peak velocity.') -->
<!-- ``` -->

# 2c Durations

## DF Creation

```{r, echo = FALSE, warning = FALSE}

options(warn=-1)
# ================  Fitting Movement Duration
masses = unique(prefdata$eff_mass)
models = c('Pilot','MPNet_Cost','MGross_Cost','Utility','m1','Torque')
model_durs = data.frame('eff_mass' = cbind(rep(masses,13)),
                        # Change here for 2a/b/c
                        'model' = c(rep('Pilot',4),
                                    rep('MPNet_Cost',4),
                                    rep('MGross_cost',4),
                                    rep('Util_gross',4),
                                    rep('Util_net',4),
                                    # Change here for 2a/b/c
                                    rep('util_dur_pilot_gross',4),
                                    rep('util_dur_pilot_net',4),
  
                                    rep('Util_comb_alpha_gross',4),
                                    rep('Util_comb_alpha_net',4),
                                    rep('m1',4),
                                    rep('m2',4),
                                    rep('torque2',4),
                                    rep('accuracy',4)),
                        'movedur' = c(aggregate(movedur~eff_mass,pilotdata,mean)$movedur,
                                     met_net_dur,
                                     met_gross_dur,
                                     util_dur_gross,
                                     util_dur_net,
                                     # Change here for 2a/b/c
                                     util_dur_pilot_gross,
                                     util_dur_pilot_net,
  
                                     util_dur_pref_alpha_comb_gross[1:4],
                                     util_dur_pref_alpha_comb_net[1:4],
                                     m1_dur,
                                     m2_dur,
                                     torque_dur_2a,
                                     prob_dur_pref),
                        'modelnum' = c(rep(6,4),
                                      rep(5,4),
                                      rep(4,4),
                                      rep(7,4),
                                      rep(8,4),
                                      rep(9,4),
                                      rep(10,4),
                                      rep(11,4),
                                      rep(12,4),
                                      rep(1,4),
                                      rep(2,4),
                                      rep(3,4),
                                      rep(13,4)))

norm_durs = c()
for (c in 1:length(unique(model_durs$modelnum))){
  x = model_durs$movedur[seq(4*c-3,4*c)]/model_durs$movedur[4*c-3]
  norm_durs = c(norm_durs,x)
}
model_durs$norm_durs = norm_durs

model_labs = c(TeX('$Mass^1$'),
               TeX('$Mass^2$'),
               TeX('$Torque^2$'),
               TeX('Met Cost\nGross'),
               TeX('Met Cost\nNet'),
               TeX('Preferred\nDuration'),
               TeX('Utility Gross'),
               TeX('Utility Net'),
               TeX('Utility Gross'),
               TeX('Utility Net'),
               TeX('Utility Gross\nComb Alpha'),
               TeX('Utility Net\nComb Alpha'),
               TeX('Accuracy Prob'))
models_to_plot = c(3,4,5,6,9,10,11,12)
temp_durs = filter(model_durs, modelnum %in% models_to_plot)


```

## Peak Velocity Plotting

```{r, echo = FALSE, warning = FALSE}
#================  Peak Velocity Sim
min_jerk_vel <- function(t,d) (.1)*(30*(t/d)^2-60*(t/d)^3+30*(t/d)^4)
min_jerk_vel <- function(tm){
  ro = 0
  rf = 0.1
  dt=0.001
  
  tme=seq(0,tm,dt)
  ts=tme/tm
  
  t2=ts*ts
  t3=t2*ts
  t4=t3*ts
  t5=t4*ts
  
  v=((60*t3-30*t4-30*t2)/tm)*(ro-rf)
  return(max(v))
} 

t <- seq(0, 0.66, 0.01)

met_net_peakvel =c(0,0,0,0)
met_gross_peakvel = c(0,0,0,0)
util_peakvel_gross = c(0,0,0,0)
util_peakvel_net = c(0,0,0,0)
util_peakvel_gross_rx = c(0,0,0,0)
util_peakvel_net_rx = c(0,0,0,0)
util_peakvel_comb_alpha_gross = c(0,0,0,0)
util_peakvel_comb_alpha_net = c(0,0,0,0)
m1_peakvel = c(0,0,0,0)
m2_peakvel = c(0,0,0,0)
torque_peakvel = c(0,0,0,0)
accuracy_peakvel = c(0,0,0,0)
for (c in 1:4){
  met_net_peakvel[c] = min_jerk_vel(met_net_dur[c])
  met_gross_peakvel[c] = min_jerk_vel(met_gross_dur[c])
  util_peakvel_gross[c] = min_jerk_vel(util_dur_gross[c])
  util_peakvel_net[c] = min_jerk_vel(util_dur_net[c])
  # Change here for 2a/b/c
  util_peakvel_gross_rx[c] = min_jerk_vel(util_dur_pilot_gross[c])
  util_peakvel_net_rx[c] = min_jerk_vel(util_dur_pilot_net[c])
  
  util_peakvel_comb_alpha_gross[c] = min_jerk_vel(util_dur_pref_alpha_comb_gross[c])
  util_peakvel_comb_alpha_net[c] = min_jerk_vel(util_dur_pref_alpha_comb_net[c])
  m1_peakvel[c] = min_jerk_vel(m1_dur[c])
  m2_peakvel[c] = min_jerk_vel(m2_dur[c])
  torque_peakvel[c] = min_jerk_vel(torque_dur_2a[c])
  accuracy_peakvel[c] = min_jerk_vel(prob_dur_pref[c])
}

model_vels = data.frame('eff_mass' = cbind(rep(masses,13)),
                        # Change here for 2a/b/c
                        'model' = c(rep('Pilot',4),
                                    rep('MPNet_Cost',4),
                                    rep('MGross_cost',4),
                                    rep('Util_gross',4),
                                    rep('Util_net',4),
                                    # Change here for 2a/b/c
                                    rep('util_dur_pilot_gross',4),
                                    rep('util_dur_pilot_net',4),
                                    rep('Util_comb_alpha_gross',4),
                                    rep('Util_comb_alpha_net',4),
                                    rep('m1',4),
                                    rep('m2',4),
                                    rep('torque2',4),
                                    rep('accuracy',4)),
                        'peakvel' = c(aggregate(peakvel_target~eff_mass,pilotdata,mean)$peakvel_target,
                                      met_net_peakvel,
                                      met_gross_peakvel,
                                      util_peakvel_gross,
                                      util_peakvel_net,
                                      util_peakvel_gross_rx,
                                      util_peakvel_net_rx,
                                      util_peakvel_comb_alpha_gross,
                                      util_peakvel_comb_alpha_net,
                                      m1_peakvel,
                                      m2_peakvel,
                                      torque_peakvel,
                                      accuracy_peakvel),
                        'modelnum' = c(rep(6,4),
                                      rep(5,4),
                                      rep(4,4),
                                      rep(7,4),
                                      rep(8,4),
                                      rep(9,4),
                                      rep(10,4),
                                      rep(11,4),
                                      rep(12,4),
                                      rep(1,4),
                                      rep(2,4),
                                      rep(3,4),
                                      rep(13,4)))

norm_vels = c()
for (c in 1:length(unique(model_durs$modelnum))){
  x = model_vels$peakvel[seq(4*c-3,4*c)]/model_vels$peakvel[4*c-3]
  norm_vels = c(norm_vels,x)
}
model_vels$norm_vels = norm_vels
temp_vels = model_vels

```

## SSE of models - Exp 2c
The utility combined alpha is using the alpha value predicted off fitting a utility model to the preferred and small target experiment at the same time. This alpha value is used to make figure \@ref(fig:groupedutilitymovedur1).

### Absolute
```{r, echo = FALSE, warning = FALSE}

Model_SSE_movedur = c()
Model_AIC_movedur = c()
Model_BIC_movedur = c()
Model_SSE_peakvel = c()
Model_AIC_peakvel = c()
Model_BIC_peakvel = c()
Model_SSE_colnames = c()
Model_SSE = c()

models_SSE = c('m1',
               'm2',
               'accuracy',
               'MGross_cost',
               'MPNet_Cost',
               'torque2',
               'Util_gross',
               # Change here for 2a/b/c
               'util_dur_pilot_gross',
               'Util_net',
               'util_dur_pilot_net',
               'Util_comb_alpha_gross',
               'Util_comb_alpha_net',
               'Pilot')
for (model1 in models_SSE){
  # Change here for 2a/b/c
  if (model1 %in% c('Util_gross','util_dur_pilot_gross','util_dur_pilot_net','Util_net','Util_comb_alpha_gross','Util_comb_alpha_net')){
    n_params = 1
  } else {
    n_params = 0
  }
  
  model_movedur_temp1 = filter(model_durs,model==model1)$movedur
  # Change here for 2a/b/c
  model_movedur_temp2 = filter(model_durs,model=='Pilot')$movedur
  SSE = sum((model_movedur_temp1-model_movedur_temp2)^2)
  Model_SSE_movedur = rbind(Model_SSE_movedur,SSE)
  
  Model_AIC_movedur = c(Model_AIC_movedur, 4*log(SSE)-4*log(4)+2*(n_params+1))
  Model_BIC_movedur = c(Model_BIC_movedur, 4*log(SSE)-4*log(4)+log(4)*(n_params+1))
  
  model_peakvel_temp1 = filter(model_vels,model==model1)$peakvel
  # Change here for 2a/b/c
  model_peakvel_temp2 = filter(model_vels,model=='Pilot')$peakvel
  SSE = sum((model_peakvel_temp1-model_peakvel_temp2)^2)
  Model_SSE_peakvel = rbind(Model_SSE_peakvel,SSE)
  # Model_SSE_colnames = rbind(Model_SSE_colnames,model1)
  
  Model_AIC_peakvel = c(Model_AIC_peakvel, 4*log(SSE)-4*log(4)+2*(n_params+1))
  Model_BIC_peakvel = c(Model_BIC_peakvel, 4*log(SSE)-4*log(4)+log(4)*(n_params+1))
  
}

Model_SSE_movedur = formatC(Model_SSE_movedur,format = 'e', digits = 3)
Model_SSE_peakvel = formatC(Model_SSE_peakvel,format = 'e', digits = 3)

Model_AIC_movedur = formatC(Model_AIC_movedur,format = 'e', digits = 2)
Model_BIC_movedur = formatC(Model_BIC_movedur,format = 'e', digits = 2)
Model_AIC_peakvel = formatC(Model_AIC_peakvel,format = 'e', digits = 2)
Model_BIC_peakvel = formatC(Model_BIC_peakvel,format = 'e', digits = 2)

Model_SSE = as.data.frame(cbind(models_SSE,
                                Model_SSE_movedur,
                                Model_AIC_movedur,
                                Model_BIC_movedur,
                                Model_SSE_peakvel,
                                Model_AIC_peakvel,
                                Model_BIC_peakvel))

colnames(Model_SSE) <- c('model',
                         'Movement Duration SSE',
                         'Movement Duration AIC',
                         'Movement Duration BIC',
                         'Peak Velocity SSE',
                         'Peak Velocity AIC',
                         'Peak Velocity BIC')

Model_SSE = filter(Model_SSE,
                   model!='Pilot',
                   model!='Util_net',
                   model!='m2',
                   model!='m1',
                   model!='Util_gross',
                   model!='Util_net')

Model_SSE$model = c('Accuracy Prob',
                    'Met Cost Gross',
                    'Met Cost Net',
                    'Torque^2',
                    'Utility Gross',
                    'Utility Net',
                    'Utility Gross Combined Alpha',
                    'Utility Net Combined Alpha')

colnames(Model_SSE) = c('Model',
                        'Movement Duration SSE',
                        'Movement Duration AIC',
                        'Movement Duration BIC',
                        'Peak Velocity SSE',
                        'Peak Velocity AIC',
                        'Peak Velocity BIC')
```


This table shows the SSE for the 2b movement duration and peak velocity predictions.

```{r ModelSSE2c, echo = FALSE, warning = FALSE, tab.cap = 'Exp 2b - Sum squared errors for movement duration and peak velocity.'}
# Change here for 2a/b/c
kable(Model_SSE, caption = 'Exp 2b - Sum squared errors for movement duration and peak velocity.')
```

### Normalized

```{r, echo = FALSE, warning = FALSE}
# Noramlzied version
Model_SSE_movedur_norm = c()
Model_AIC_movedur_norm = c()
Model_BIC_movedur_norm = c()
Model_SSE_peakvel_norm = c()
Model_AIC_peakvel_norm = c()
Model_BIC_peakvel_norm = c()
Model_SSE_colnames_norm = c()
Model_SSE_norm = c()

for (model1 in models_SSE){
  # Change here for 2a/b/c
  if (model1 %in% c('Util_gross','util_dur_pilot_gross','util_dur_pilot_net','Util_net','Util_comb_alpha_gross','Util_comb_alpha_net')){
    n_params = 1
  } else {
    n_params = 0
  }
  
  model_movedur_temp1_norm = filter(model_durs,model==model1)$norm_durs
  # Change here for 2a/b/c
  model_movedur_temp2_norm = filter(model_durs,model=='Pilot')$norm_durs
  SSE = sum((model_movedur_temp1_norm-model_movedur_temp2_norm)^2)
  Model_SSE_movedur_norm = rbind(Model_SSE_movedur_norm,SSE)
  
  Model_AIC_movedur_norm = c(Model_AIC_movedur_norm, 4*log(SSE)-4*log(4)+2*(n_params+1))
  Model_BIC_movedur_norm = c(Model_BIC_movedur_norm, 4*log(SSE)-4*log(4)+log(4)*(n_params+1))
  
  model_peakvel_temp1_norm = filter(model_vels,model==model1)$norm_vels
  # Change here for 2a/b/c
  model_peakvel_temp2_norm = filter(model_vels,model=='Pilot')$norm_vels
  SSE = sum((model_peakvel_temp1_norm-model_peakvel_temp2_norm)^2)
  Model_SSE_peakvel_norm = rbind(Model_SSE_peakvel_norm,SSE)
  # Model_SSE_colnames = rbind(Model_SSE_colnames,model1)
  
  Model_AIC_peakvel_norm = c(Model_AIC_peakvel_norm, 4*log(SSE)-4*log(4)+2*(n_params+1))
  Model_BIC_peakvel_norm = c(Model_BIC_peakvel_norm, 4*log(SSE)-4*log(4)+log(4)*(n_params+1))
  
}
Model_SSE_movedur_norm = formatC(Model_SSE_movedur_norm,format = 'e', digits = 3)
Model_SSE_peakvel_norm = formatC(Model_SSE_peakvel_norm,format = 'e', digits = 3)

Model_AIC_movedur_norm = formatC(Model_AIC_movedur_norm,format = 'e', digits = 2)
Model_BIC_movedur_norm = formatC(Model_BIC_movedur_norm,format = 'e', digits = 2)
Model_AIC_peakvel_norm = formatC(Model_AIC_peakvel_norm,format = 'e', digits = 2)
Model_BIC_peakvel_norm = formatC(Model_BIC_peakvel_norm,format = 'e', digits = 2)

Model_SSE_norm = as.data.frame(cbind(models_SSE,
                                Model_SSE_movedur_norm,
                                Model_AIC_movedur_norm,
                                Model_BIC_movedur_norm,
                                Model_SSE_peakvel_norm,
                                Model_AIC_peakvel_norm,
                                Model_BIC_peakvel_norm))

colnames(Model_SSE_norm) <- c('model',
                         'Movement Duration SSE',
                         'Movement Duration AIC',
                         'Movement Duration BIC',
                         'Peak Velocity SSE',
                         'Peak Velocity AIC',
                         'Peak Velocity BIC')

Model_SSE_norm = filter(Model_SSE_norm,
                        model!='Pilot',
                        model!='Util_net',
                        model!='m2',
                        model!='m1',
                        model!='Util_gross',
                        model!='Util_net')

Model_SSE_norm$model = c('Accuracy Prob',
                    'Met Cost Gross',
                    'Met Cost Net',
                    'Torque^2',
                    'Utility Gross',
                    'Utility Net',
                    'Utility Gross Combined Alpha',
                    'Utility Net Combined Alpha')

colnames(Model_SSE_norm) = c('Model',
                        'Movement Duration SSE',
                        'Movement Duration AIC',
                        'Movement Duration BIC',
                        'Peak Velocity SSE',
                        'Peak Velocity AIC',
                        'Peak Velocity BIC')
```

```{r ModelSSEnorm2c, echo = FALSE, warning = FALSE, tab.cap = 'Exp 2a - Sum squared errors for NORMALIZED movement duration and peak velocity.'}
kable(Model_SSE_norm, caption = 'Exp 2a - Sum squared errors for NORMALIZED movement duration and peak velocity.')
```


## 2c Modeling Plot

```{r, echo = FALSE, warning = FALSE, fig.cap = 'Modeled movement durations and peak velocities.'}
## Making the Model Group plot

## Movement Duration
theme_set(theme_cowplot(font_size=12))

# pilotdata <- norm_vals(pilotdata)

errbar = cbind(aggregate(movedur~eff_mass,pilotdata,mean),
               aggregate(movedur~eff_mass,pilotdata,sd)[2]/sqrt(length(unique(pilotdata$subj))))
colnames(errbar) = c('eff_mass','movedur','sd')

Model_movedur_shape <- model_plotting('movedur','Movement Duration (s)',temp_durs,errbar,'shape',normalized = 0)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))

Model_movedur_color <- model_plotting('movedur','Movement Duration (s)',temp_durs,errbar,'color',normalized = 0)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))

# setwd(pref_plots_dir)
# if (save_plots){ggsave('Model_movedur_shape.pdf',plot=Model_movedur_shape, useDingbats = FALSE)}


temp_durs = model_durs
temp_durs = filter(model_durs, modelnum %in% models_to_plot)

errbar = cbind(aggregate(movedurnorm~eff_mass,pilotdata,mean),
               aggregate(movedurnorm~eff_mass,pilotdata,sd)[2]/sqrt(length(unique(pilotdata$subj))))
colnames(errbar) = c('eff_mass','norm_durs','sd')

Model_normmovedur_shape <- model_plotting('norm_durs','Norm Movement Duration (s)',temp_durs,errbar,'shape',normalized = 1)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))
Model_normmovedur_color <- model_plotting('norm_durs','Norm Movement Duration (s)',temp_durs,errbar,'color',normalized = 1)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))

## Peak Velocity

temp_vels = model_vels
temp_vels = filter(temp_vels, modelnum %in% models_to_plot)


errbar = cbind(aggregate(peakvel_target~eff_mass,pilotdata,mean),
               aggregate(peakvel_target~eff_mass,pilotdata,sd)[2]/sqrt(length(unique(pilotdata$subj))))
colnames(errbar) = c('eff_mass','peakvel','sd')

Model_peakvel_shape <- model_plotting('peakvel','Peak Velocity (m/s)',
                                      temp_vels,errbar,'shape',normalized = 0)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))
Model_peakvel_color <- model_plotting('peakvel','Peak Velocity (m/s)',
                                      temp_vels,errbar,'color',normalized = 0)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))


# setwd(pref_plots_dir)
# if (save_plots){ggsave('Model_peakvel_shape.pdf',plot=Model_peakvel_shape,useDingbats = FALSE)}

norm_vels = c()
for (c in 1:length(unique(model_durs$modelnum))){
  x = model_vels$peakvel[seq(4*c-3,4*c)]/model_vels$peakvel[4*c-3]
  norm_vels = c(norm_vels,x)
}
model_vels$norm_vels = norm_vels
temp_vels = model_vels

temp_vels = model_vels
temp_vels = filter(temp_vels, modelnum %in% models_to_plot)

errbar = cbind(aggregate(peakvelnorm~eff_mass,pilotdata,mean),
               aggregate(peakvelnorm~eff_mass,pilotdata,sd)[2]/sqrt(length(unique(pilotdata$subj))))
colnames(errbar) = c('eff_mass','norm_vels','sd')

Model_normpeakvel_shape <- model_plotting('norm_vels','Norm Peak Velocity (m/s)',
                                          temp_vels,errbar,'shape',normalized = 1)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))
Model_normpeakvel_color <- model_plotting('norm_vels','Norm Velocity (m/s)',
                                          temp_vels,errbar,'color',normalized = 1)+
  # theme_classic()
  theme(text              = element_text(color='black'),
        axis.text         = element_text(color='black'),
        axis.ticks        = element_line(color='black'),
        plot.title        = element_text(hjust = 0.5),
        axis.line         = element_line(color='black'))

# setwd(pref_plots_dir)
# if (save_plots){ggsave('Model_peakvelnorm_shape.pdf',plot=Model_normpeakvel_shape,useDingbats = FALSE)}

## Grouping

add_legend_shape <- get_legend(Model_movedur_shape)
add_legend_color <- get_legend(Model_movedur_color)

plots_to_fix = c('Model_movedur_shape',
                 'Model_normmovedur_shape',
                 'Model_peakvel_shape',
                 'Model_normpeakvel_shape',
                 'Model_movedur_color',
                 'Model_normmovedur_color',
                 'Model_peakvel_color',
                 'Model_normpeakvel_color')

for (plot in plots_to_fix){
  string = paste(plot,'<-',plot,'+
                 # theme_classic()
                 theme(text        = element_text(size = 16, color=\'black\'),
                 axis.text         = element_text(color=\'black\'),
                 axis.ticks        = element_line(color=\'black\'),
                 plot.title        = element_text(hjust = 0.5),
                 axis.line         = element_line(color=\'black\'),
                 legend.position   = \'none\')',sep = '')
  eval(parse(text = string))
}

Results_model_r_shape <- plot_grid(Model_movedur_shape+theme(legend.position='none'),
         Model_normmovedur_shape+theme(legend.position='none'),
         Model_peakvel_shape+theme(legend.position='none'),
         Model_normpeakvel_shape+theme(legend.position='none'),
         nrow = 2,
         hjust = -1,
         labels = c('A','B','C','D'),
         label_size = 20,
         align = 'vh')
Results_model_r_shape<-plot_grid(Results_model_r_shape,add_legend_shape,nrow=1,rel_widths = c(.85,.15))

setwd(pref_plots_dir)
if (save_plots){ggsave('Results_model_r_shape.pdf',plot = Results_model_r_shape, height = 8, width = 8/.85, useDingbats = FALSE)}

Results_model_r_color <- plot_grid(Model_movedur_color+theme(legend.position='none'),
         Model_normmovedur_color+theme(legend.position='none'),
         Model_peakvel_color+theme(legend.position='none'),
         Model_normpeakvel_color+theme(legend.position='none'),
         nrow = 2,
         hjust = -1,
         labels = c('A','B','C','D'),
         label_size = 20,
         align = 'vh')
Results_model_r_color<-plot_grid(Results_model_r_color,add_legend_color,nrow=1,rel_widths = c(.85,.15))

# setwd(pref_plots_dir)
# if (save_plots){ggsave('Results_model_r_color.pdf',plot = Results_model_r_color, height = 8, width = 8/.85, useDingbats = FALSE)}
options(warn=0)
```

```{r Resultsmodelrshape2c, echo = FALSE, fig.width=9, fig.height=6, fig.cap = 'Modeling Results'}
Results_model_r_shape
```